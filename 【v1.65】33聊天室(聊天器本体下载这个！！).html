<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>33聊天室</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Long+Cang&display=swap" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=ZCOOL+KuaiLe&display=swap');
        /* --- 1. 全局与主题 --- */
        :root {
            --theme-color-1: #F4E8DD; /* 奶油杏 */
            --theme-color-2: #EDD4D8; /* 柔粉 */
            --theme-color-3: #CCD4CC; /* 灰绿 */
            --theme-color-4: #B5BFCF; /* 雾蓝 */
            /* --- 颜色修改 --- */
            --accent-color: #A7C7E7; /* 强调色-浅蓝 */
            --accent-color-deep: #88A9D1; /* 深一点的浅蓝 */
            /* --- 颜色修改结束 --- */
            --text-color-dark: #5D534A; /* 深棕 */
            --text-color-medium: #7E746D;
            --text-color-light: #A39B94;
            --text-color-white: #FFFFFF;
            --bg-main: #F7F8FA; /* 改为柔和的浅灰色背景 */
            --bg-light: rgba(255, 255, 255, 0.7);
            --border-color: rgba(0, 0, 0, 0.08);
            --shadow-light: 0 4px 15px rgba(0, 0, 0, 0.05);
            --shadow-medium: 0 6px 20px rgba(0, 0, 0, 0.1);
            --font-main: "SimSun", "宋体", serif; /* 全局字体，默认楷体 */
            --font-title: "Kaiti", "楷体", serif;
            --font-bubble: "LXGW WenKai Screen", "Kaiti", "楷体", serif; /* 气泡字体，默认楷体 */
            --font-inner-voice: "Long Cang", cursive; /* 心声字体，默认龙藏体 */
            --font-essay: "Long Cang", cursive; /* 随笔字体，默认龙藏体 */
            --font-bubble-size: 0.95rem; /* 使用CSS变量 */
            --unread-bg: #ff4d4d;
            --red-packet-red: #DB5445;
            --red-packet-gold: #F8D69A;
            
            /* --- 新增：气泡主题化变量 --- */
            --player-bubble-bg: var(--accent-color); /* 我的消息背景色 (A类气泡) */
            --friend-bubble-bg: var(--text-color-white);  /* 好友消息背景色 (A类气泡) */
            --player-bubble-text-color: var(--text-color-dark); /* 我的消息字体颜色 */
            --friend-bubble-text-color: var(--text-color-dark);  /* 好友消息字体颜色 */
        }
        @keyframes paw-pulse { /* 新增 */
            0% { transform: scale(1); }
            50% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
/* --- 开屏动画样式 (参考样式) --- */
#splash-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: var(--bg-main);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 99999;
    transition: opacity 0.5s ease-out;
}
#splash-screen.hidden {
    opacity: 0;
    pointer-events: none;
}
.splash-logo {
    font-family: 'ZCOOL KuaiLe', cursive; /* 使用参考文件字体 */
    font-size: 36px; /* 参考文件字体大小 */
    color: var(--accent-color-2); /* 使用参考文件颜色风格，映射到当前主题 */
    margin-bottom: 20px;
}
.splash-loader {
    width: 50px;
    height: 50px;
    border: 3px solid var(--theme-color-2); /* 边框颜色映射 */
    border-top-color: var(--accent-color); /* 顶部颜色映射 */
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent; /* 移除移动端点击高亮 */
        }

        html, body {
            height: 100%;
            overflow: hidden;
            font-family: var(--font-main);
            color: var(--text-color-dark);
        }

    body {
        background: var(--bg-main);
        display: flex;
        justify-content: center;
        align-items: center;
        font-family: var(--font-main); /* 应用全局字体 */
    }

        #app-container {
            width: 100%;
            height: 100%;
            max-width: 500px;
            background-color: var(--bg-light);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: var(--shadow-medium);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #main-content {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
            display: flex;
        }

        /* --- 2. 页面切换与布局 --- */
        .page {
            display: none;
            flex-grow: 1;
            flex-direction: column;
            overflow: hidden;
            animation: fadeIn 0.4s ease-in-out;
        }
        .page.active {
            display: flex;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to { opacity: 1; transform: scale(1); }
        }

        .page-header {
            padding: 15px 10px;
            display: grid;
            grid-template-columns: 50px 1fr auto; /* 调整右侧为自适应宽度 */
            align-items: center;
            background: rgba(255, 255, 255, 0.5);
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
        }
        .page-header h1 {
            font-family: var(--font-title);
            font-size: 1.3rem; /* 减小字体大小 */
            /* 移除绝对定位和变换，由父级wrapper控制 */
        }
        .page-header .header-icon {
            font-size: 1.3rem;
            cursor: pointer;
            color: var(--text-color-medium);
            z-index: 2;
        }

        .page-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
            -webkit-overflow-scrolling: touch;
        }
        .page-content::-webkit-scrollbar {
            width: 4px;
        }
        .page-content::-webkit-scrollbar-thumb {
            background: var(--theme-color-4);
            border-radius: 2px;
        }
        
        /* --- 3. 底部导航栏 --- */
        #bottom-nav {
            display: flex;
            width: 100%;
            background-color: var(--bg-light);
            border-top: 1px solid var(--border-color);
            padding: 8px 0;
            flex-shrink: 0;
        }
        .nav-item {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-color-light);
            transition: color 0.3s, transform 0.3s;
        }
        .nav-item:hover {
            color: var(--accent-color);
        }
        .nav-item.active {
            color: var(--accent-color-deep);
            transform: scale(1.1);
        }
        .nav-item i {
            font-size: 1.4rem;
            margin-bottom: 4px;
        }
        .nav-item span {
            font-size: 0.75rem;
        }

        /* --- 4. 消息列表页面 --- */
        #page-messages .page-header {
            padding: 10px 15px;
        }
        #my-avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            object-fit: cover;
            cursor: pointer;
            border: 2px solid var(--text-color-white);
            box-shadow: var(--shadow-light);
        }
        .message-list {
            list-style: none;
            padding: 0;
        }
        .message-item {
            display: flex;
            align-items: center;
            padding: 12px 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            border-bottom: 1px solid var(--border-color);
        }
        .message-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        .item-avatar {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .item-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .item-name {
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 6px;
        }
        .item-last-msg {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .item-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-left: 10px;
            flex-shrink: 0;
        }
        .item-time {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-bottom: 8px;
        }
        .unread-badge {
            background-color: var(--unread-bg);
            color: white;
            font-size: 0.7rem;
            min-width: 20px;
            height: 20px;
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0 6px;
        }
        /* --- 4.1 页面头部图标调整 --- */
        #header-link-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background-color: rgba(0,0,0,0.05);
            color: var(--text-color-medium);
            display: flex;
            justify-content: center;
            align-items: center;
            text-decoration: none;
            justify-self: end;
            margin-right: 15px;
            transition: all 0.2s;
        }
        #header-link-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }

        .page-header .header-icon {
            font-size: 1.2rem; /* 缩小图标 */
            padding: 0 10px; /* 调整点击区域 */
        }
        /* 将右侧图标推到最右边 */
        .page-header .header-icon:last-child {
            justify-self: end;
            padding-right: 15px; /* 增加右边距 */
        }
        .header-icon-group {
            display: flex;
            gap: 10px; /* 减小间距 */
            align-items: center;
            justify-self: end;
            padding-right: 15px;
        }
        #batch-delete-btn:hover i,
        #batch-delete-btn:active i,
        #page-contacts.selection-mode #batch-delete-btn i {
             color: #e74c3c;
        }
        /* --- 4.2. 底部上移样式 --- */
        #app-container.bottom-offset-active {
            padding-bottom: 30px; /* 为系统导航栏留出空间 */
            height: calc(100% - 30px); /* 相应地调整高度 */
        }
        /* --- 5. 通讯录页面 --- */
        .tabs {
            display: flex;
            justify-content: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border-color);
        }
        .tab-btn {
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 20px;
            background-color: transparent;
            border: 1px solid transparent;
            color: var(--text-color-medium);
            transition: all 0.3s;
        }
        .tab-btn.active {
            background-color: var(--text-color-white);
            border-color: var(--theme-color-2);
            color: var(--accent-color-deep);
            font-weight: bold;
            box-shadow: var(--shadow-light);
        }
        .contact-section {
            display: none;
        }
        .contact-section.active {
            display: block;
        }
        .contact-list-header {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 5px;
            color: var(--text-color-light);
        }
        .sort-btn {
            cursor: pointer;
            font-size: 0.9rem;
        }
        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .contact-item-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            margin-right: 15px;
            background-color: var(--theme-color-4);
        }
        .contact-item-name {
            flex-grow: 1;
            font-size: 1.1rem;
        }
        .contact-info-btn {
            font-size: 1.2rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px;
        }
        .contact-list .contact-select-checkbox {
            display: none;
            margin-right: 15px;
            width: 20px;
            height: 20px;
            accent-color: var(--accent-color);
        }
        .contact-list.selection-mode .contact-select-checkbox {
            display: block;
        }
        .contact-list.selection-mode .contact-item {
            cursor: pointer;
        }
        .contact-list.selection-mode .contact-info-btn {
            display: none; /* 选择模式下隐藏详情按钮 */
        }

        #contacts-friend-folders .prompt-folder {
            margin-bottom: 8px; /* 减小分组间距 */
        }
        #contacts-friend-folders .prompt-folder-header h3 {
            font-weight: normal; /* 移除分组名称加粗 */
        }

        /* --- 6. 设置页面 --- */
        .settings-list {
            padding-top: 10px;
        }
        .setting-item {
            display: flex;
            align-items: center;
            padding: 18px 15px;
            background-color: var(--text-color-white);
            margin: 0 10px 12px;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .setting-item:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-light);
        }
        .setting-item i {
            font-size: 1.3rem;
            color: var(--accent-color);
            margin-right: 15px;
            width: 25px;
            text-align: center;
        }
        .setting-item span {
            font-size: 1.1rem;
            flex-grow: 1;
        }
        .setting-item .fa-chevron-right {
            color: var(--text-color-light);
            font-size: 1rem;
        }

        /* --- 7. 聊天页面 --- */
        #page-chat .page-header .header-title {
            max-width: 80%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 1.1rem; /* 新增：缩小字体大小 */
        }
        .header-title-wrapper {
            grid-column: 2 / 3; /* 占据中间栏 */
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden; /* 防止内容溢出 */
        }
        .typing-indicator-container {
            font-size: 0.75rem; /* 进一步调小 */
            color: var(--text-color-medium);
            display: none; /* Initially hidden */
            margin-top: 1px; /* 微调与标题的间距 */
        }
        .chat-area {
            flex-grow: 1;
            padding: 20px 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            /* 关键修复：让聊天区域拥有自己的背景，而不是透明 */
            background-color: var(--theme-color-1); 
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }
        /* --- 新增：聊天背景容器 --- */
        #app-container {
            /* ... (保留原有样式) */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            background-attachment: fixed; /* 关键：使背景固定不滚动 */
        }
        
        /* --- 新增：主题设置弹窗内样式 (参考 聊天背景上传.html) --- */
        .theme-settings-modal .form-group {
            margin-bottom: 25px;
        }

        .theme-settings-modal .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: bold;
            color: var(--form-label-color, #555);
        }

        .theme-settings-modal .background-upload-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            padding: 15px;
            border: 1px dashed var(--border-color);
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.5);
        }

        .theme-settings-modal .background-preview {
            width: 150px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }

        .theme-settings-modal .cover-preview {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-light);
            background-color: #e9e9e9;
        }
        
        .theme-settings-modal .color-input-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .theme-settings-modal .color-input-group input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .theme-settings-modal .color-input-group input[type="color"]::-webkit-color-swatch { border: 2px solid var(--border-color); border-radius: 8px; }

        .message-row {
            display: flex;
            max-width: 80%;
            width: -webkit-fit-content;
            width: -moz-fit-content;
            width: fit-content;
        }
        .message-row.sent {
            align-self: flex-end;
            flex-direction: row-reverse;
        }
        .message-row.received {
            align-self: flex-start;
        }
        .message-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            background-color: var(--theme-color-3);
            flex-shrink: 0;
        }
        .message-avatar.group-avatar-style {
            border-radius: 12px; /* 方形圆角 */
        }
        .message-row.sent .message-avatar {
            margin-left: 10px;
        }
        .message-row.received .message-avatar {
            margin-right: 10px;
        }
        .message-content {
            display: flex;
            flex-direction: column;
        }
        .message-row.sent .message-content {
            align-items: flex-end;
        }
        .message-row.received .message-content {
            align-items: flex-start;
        }
        .message-name {
            font-size: 0.8rem;
            color: var(--text-color-light);
            margin-bottom: 5px;
            padding: 0 5px;
        }
    .bubble {
        padding: 8px 12px;
        border-radius: 16px;
        word-break: break-word;
        font-family: var(--font-bubble); /* 应用气泡字体 */
        font-size: var(--font-bubble-size, 0.95rem); /* 使用CSS变量 */
        line-height: 1.4;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        position: relative;
        border: none; /* 移除默认边框，由具体样式控制 */
    }
        @keyframes popIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        
        /* --- 默认气泡样式 (A类, 边框变色) --- */
        #app-container.app-bubble-style-default .bubble {
            background: white; /* 固定背景为白色 */
            color: var(--text-color-dark); /* 固定文字颜色为深色 */
        }
        #app-container.app-bubble-style-default .bubble.received {
            border: 1px solid var(--friend-bubble-bg); /* 边框颜色由变量控制 */
            border-top-left-radius: 5px;
        }
        #app-container.app-bubble-style-default .bubble.sent {
            border: 1px solid var(--player-bubble-bg); /* 边框颜色由变量控制 */
            border-top-right-radius: 5px;
        }
        #app-container.app-bubble-style-default .message-row.sent .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--player-bubble-bg); 
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .message-row.received .quote-block {
            background-color: rgba(0, 0, 0, 0.04);
            border-color: var(--friend-bubble-bg);
            color: var(--text-color-dark);
        }
        #app-container.app-bubble-style-default .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-default .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }


        /* --- 立体3D气泡样式 (A类) --- */
        #app-container.app-bubble-style-3d .bubble {
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            border-bottom-width: 3px;
            border-bottom-style: solid;
        }
        #app-container.app-bubble-style-3d .bubble.received {
            background: var(--friend-bubble-bg);
            color: var(--friend-bubble-text-color);
            border-color: rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-3d .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-color: rgba(0,0,0,0.2);
        }


        /* --- 可爱条纹 (B类) --- */
        #app-container.app-bubble-style-stripey .bubble {
            background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);
            color: #a3505f;
            border: 2px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #app-container.app-bubble-style-stripey .voice-wave-bar { background-color: #a3505f; }

        /* --- 渐变彩虹 (B类, 动画) --- */
        @keyframes gradientBG {
            0% { background-position: 0% 50%; } 50% { background-position: 100% 50%; } 100% { background-position: 0% 50%; }
        }
        #app-container.app-bubble-style-gradient .bubble {
            background: linear-gradient(45deg, #ff9a9e, #fad0c4, #a1c4fd, #c2e9fb, #ff9a9e);
            background-size: 300% 300%;
            animation: gradientBG 8s ease infinite;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        #app-container.app-bubble-style-gradient .voice-wave-bar { background-color: white; }

        /* --- 手绘涂鸦 (B类) --- */
        #app-container.app-bubble-style-doodle .bubble {
            border: 2px solid #333;
            border-radius: 15px 10px 15px 12px;
            background: white;
            color: #333;
            box-shadow: 3px 3px 0px #ccc;
        }
        #app-container.app-bubble-style-doodle .bubble.sent {
            border-radius: 10px 15px 12px 15px;
        }
        #app-container.app-bubble-style-doodle .quote-block {
            border-left-width: 2px;
            border-left-style: dashed;
            background-color: #f7f7f7;
        }
        #app-container.app-bubble-style-doodle .voice-wave-bar { background-color: #333; }

        /* --- 手绘涂鸦2 (B类) --- */
        #app-container.app-bubble-style-hand-drawn .bubble {
            background: white; border: 3px solid #333; position: relative;
            box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: 'Comic Sans MS', cursive;
            color: #333;
        }
        #app-container.app-bubble-style-hand-drawn .bubble.received { border-radius: 0 20px 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .bubble.sent { border-radius: 20px 0 20px 20px; }
        #app-container.app-bubble-style-hand-drawn .voice-wave-bar { background-color: #333; }

        /* --- 拟态 (A类) --- */
        #app-container.app-bubble-style-neumorphic .bubble {
            background: var(--friend-bubble-bg);
            border-radius: 20px;
            box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff;
            color: var(--friend-bubble-text-color);
            border: none;
        }
        #app-container.app-bubble-style-neumorphic .bubble.sent {
            background: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            box-shadow: inset 6px 6px 12px #b8b9be, inset -6px -6px 12px #fff;
        }
        #app-container.app-bubble-style-neumorphic .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        #app-container.app-bubble-style-neumorphic .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }

        /* --- 柔和条纹 (A类) --- */
        #app-container.app-bubble-style-stripes .bubble {
            background-color: var(--friend-bubble-bg);
            background-image: repeating-linear-gradient(
                45deg,
                rgba(255, 255, 255, 0.2),
                rgba(255, 255, 255, 0.2) 15px,
                rgba(255, 255, 255, 0.1) 15px,
                rgba(255, 255, 255, 0.1) 30px
            );
            color: var(--friend-bubble-text-color);
            border: none;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }
         #app-container.app-bubble-style-stripes .bubble.sent {
            background-color: var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
        }

        /* --- 网格 (A类) - 修复 --- */
        #app-container.app-bubble-style-grid .bubble {
            background-image: 
                linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 15px 15px;
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 80%, transparent); /* 增加透明度 */
            border: 1px solid rgba(0, 0, 0, 0.1);
            color: var(--friend-bubble-text-color);
        }
         #app-container.app-bubble-style-grid .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent); /* 增加透明度 */
            color: var(--player-bubble-text-color);
        }

        /* --- 可爱风 (A类, 边框变色) --- */
        #app-container.app-bubble-style-cute .bubble {
            background: transparent;
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-cute .bubble.received {
            border: 2px solid var(--friend-bubble-bg);
            border-radius: 25px 25px 25px 5px;
        }
        #app-container.app-bubble-style-cute .bubble.sent {
            border: 2px solid var(--player-bubble-bg);
            color: var(--player-bubble-text-color);
            border-radius: 25px 25px 5px 25px;
        }

        /* --- 毛玻璃 (A类) --- */
        #app-container.app-bubble-style-frosted-glass .bubble {
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-frosted-glass .bubble.received {
            background-color: color-mix(in srgb, var(--friend-bubble-bg) 60%, transparent); /* 增加不透明度 */
            color: var(--friend-bubble-text-color);
        }
        #app-container.app-bubble-style-frosted-glass .bubble.sent {
            background-color: color-mix(in srgb, var(--player-bubble-bg) 60%, transparent); /* 增加不透明度 */
            color: var(--player-bubble-text-color);
        }

        /* --- 发光果冻 (B类) --- */
        #app-container.app-bubble-style-glow-jelly .bubble.received {
            background: linear-gradient(135deg, #00c9ff, #92fe9d);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 201, 255, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
        }
        #app-container.app-bubble-style-glow-jelly .bubble.sent {
            background: linear-gradient(135deg, #ff7e5f, #feb47b);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
        }
        #app-container.app-bubble-style-glow-jelly .voice-wave-bar { background-color: white; }
        #app-container.app-bubble-style-glow-jelly .bubble.received .voice-wave-bar { background-color: black; }

        /* --- 金属质感 (B类) --- */
        #app-container.app-bubble-style-metal .bubble {
            background: linear-gradient(145deg, #e0e0e0, #c0c0c0); border: 1px solid #a0a0a0;
            color: #333; box-shadow: 0 2px 4px rgba(0,0,0,0.1), inset 0 1px 3px rgba(255,255,255,0.8);
            position: relative; overflow: hidden;
            border-radius: 16px; /* 基础圆角 */
        }
        #app-container.app-bubble-style-metal .bubble.received { border-top-left-radius: 5px; } /* 尖角 */
        #app-container.app-bubble-style-metal .bubble.sent { border-top-right-radius: 5px; } /* 尖角 */

        #app-container.app-bubble-style-metal .bubble::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: linear-gradient(to bottom right, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 45%, rgba(255,255,255,0) 55%, rgba(255,255,255,0.2) 100%);
            transform: rotate(30deg);
        }
        #app-container.app-bubble-style-metal .voice-wave-bar { background-color: #333; }
        
        /* --- 海洋风 (B类, 带尖角) --- */
        #app-container.app-bubble-style-ocean .bubble {
            background: linear-gradient(160deg, #0077b6, #00b4d8);
            color: white;
            border: 2px solid transparent; /* 匹配可爱风尺寸，但透明 */
            border-radius: 16px;
            position: relative;
        }
        #app-container.app-bubble-style-ocean .bubble.received { border-bottom-left-radius: 5px; }
        #app-container.app-bubble-style-ocean .bubble.sent { border-bottom-right-radius: 5px; }

        /* --- 猫爪风 (B类) --- */
        #app-container.app-bubble-style-paw .bubble.received {
            background: #fce1cb;
            color: #8b5e34;
            border: none;
            border-radius: 20px 20px 20px 5px;
        }
        #app-container.app-bubble-style-paw .bubble.sent {
            background: #cbe7fc;
            color: #345c8b;
            border: none;
            border-radius: 20px 20px 5px 20px;
        }
        #app-container.app-bubble-style-paw .bubble::before {
            content: '🐾';
            position: absolute;
            bottom: -10px;
            font-size: 1.5rem;
            opacity: 0.2;
        }
        #app-container.app-bubble-style-paw .bubble.received::before { left: 10px; }
        #app-container.app-bubble-style-paw .bubble.sent::before { right: 10px; }
        #app-container.app-bubble-style-paw .voice-wave-bar { background-color: #8b5e34; }
        #app-container.app-bubble-style-paw .bubble.sent .voice-wave-bar { background-color: #345c8b; }
        
        /* --- 古风 (B类) --- */
        #app-container.app-bubble-style-ancient .bubble.received {
            background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }
        #app-container.app-bubble-style-ancient .bubble.sent {
            background: #d7ccc8; color: #4e342e; border: 2px solid #795548;
            font-family: 'SimSun', serif; box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.1);
        }

        /* --- 国风 (B类) --- */
        #app-container.app-bubble-style-chinese .bubble {
            border-radius: 0;
            clip-path: polygon(0 10px, 10px 0, calc(100% - 10px) 0, 100% 10px, 100% calc(100% - 10px), calc(100% - 10px) 100%, 10px 100%, 0 calc(100% - 10px));
        }
        #app-container.app-bubble-style-chinese .bubble.received {
            background: white; border: 1px solid #c81e1e; color: #c81e1e;
        }
        #app-container.app-bubble-style-chinese .bubble.sent {
            background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;
        }
        #app-container.app-bubble-style-chinese .voice-wave-bar { background-color: #f9d56e; }
        #app-container.app-bubble-style-chinese .bubble.received .voice-wave-bar { background-color: #c81e1e; }

        /* --- 拟态2 (B类, 效果固定) - 新增 --- */
        #app-container.app-bubble-style-neumorphic-2 .bubble {
            background: #F0F0F3;
            font-weight: 500;
            color: #888;
            text-shadow: 1px 1px 1px #fff;
            border: 1px solid rgba(0,0,0,0.05);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.received {
            border-radius: 25px 25px 25px 5px; /* 应用尖角 */
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        #app-container.app-bubble-style-neumorphic-2 .bubble.sent {
            border-radius: 25px 25px 5px 25px; /* 应用尖角 */
             box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.9), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        /* --- 引用和语音消息的通用适配 --- */
        .quote-block {
            padding: 8px 12px;
            border-left: 3px solid; /* 颜色由父级样式决定 */
            background-color: rgba(0, 0, 0, 0.04); /* 新增：浅灰色背景 */
            line-height: 1.4;
            font-size: 0.85em;
            border-radius: 8px;
            color: var(--text-color-dark); /* 新增：确保文字颜色 */
        }
        .quote-block .quoted-name { font-weight: bold; }

        .voice-duration {
            font-size: 0.8rem;
            color: #000000; /* 改为黑色 */
            margin-right: 10px;
            font-weight: bold;
        }
        .voice-wave {
            display: flex;
            align-items: center;
            height: 20px;
            flex-grow: 1;
            justify-content: flex-end;
        }
        .voice-wave-bar {
            width: 3px;
            background-color: #000000; /* 改为黑色 */
            margin: 0 2px;
            border-radius: 2px;
            animation: voiceWave 1.5s infinite ease-in-out;
            transform-origin: bottom;
        }
        @keyframes voiceWave {
            0%, 100% { transform: scaleY(0.4); }
            50% { transform: scaleY(1.0); }
        }
        .voice-wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .voice-wave-bar:nth-child(2) { height: 12px; animation-delay: 0.2s; }
        .voice-wave-bar:nth-child(3) { height: 16px; animation-delay: 0.4s; }
        .voice-wave-bar:nth-child(4) { height: 12px; animation-delay: 0.6s; }
        .voice-wave-bar:nth-child(5) { height: 8px; animation-delay: 0.8s; }

        /* --- 剩余基础样式保持不变 --- */
        .bubble-emoji {
            background: none !important; border: none !important; box-shadow: none !important; padding: 0;
            max-width: 120px; overflow: hidden;
        }
        .bubble-emoji img { max-width: 100%; display: block; border-radius: 12px; }
        .bubble.quote-message-bubble { display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble { max-width: 120px; max-height: 120px; padding: 3px; display: flex; flex-direction: column; gap: 8px; }
        .bubble.image-with-desc-bubble img { max-width: 100%; border-radius: 8px; display: block; background-color: var(--theme-color-1); }
        .bubble.image-with-desc-bubble .description-text { display: none; padding: 0 4px; font-size: 0.9rem; line-height: 1.5; color: var(--text-color-dark); }
        .bubble.voice-message-bubble {
            display: flex;
            align-items: center;
            padding: 12px 16px !important; /* 使用 !important 强制覆盖主题样式 */
            background-color: white !important; /* 使用 !important 强制覆盖主题样式 */
            border-radius: 18px !important; /* 使用 !important 强制覆盖主题样式 */
            border: 1px solid var(--theme-color-1) !important; /* 使用 !important 强制覆盖主题样式 */
            cursor: pointer;
            position: relative;
            transition: all 0.3s ease;
            z-index: 1;
            min-width: 80px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05) !important; /* 使用 !important 强制覆盖主题样式 */
        }
        .bubble.voice-message-bubble:hover {
            background-color: #f9f9f9 !important;
        }
        .message-row.sent .voice-duration { color: var(--player-bubble-text-color); }
        .message-row.sent .voice-wave-bar { background-color: var(--player-bubble-text-color); }
        .message-row.received .voice-wave-bar { background-color: var(--friend-bubble-text-color); }
        .bubble-and-tag-wrapper { position: relative; display: flex; flex-direction: column; align-items: flex-start; }
        .message-row.sent .bubble-and-tag-wrapper { align-items: flex-end; }
        .voice-transcript { position: absolute; top: calc(100% + 5px); left: 0; width: max-content; max-width: 250px; background: #e6f7ff; border: 1px dashed #91d5ff; color: #03a9f4; border-radius: 10px; padding: 8px 12px; font-size: 0.85rem; z-index: 5; display: none; word-wrap: break-word; }
        .voice-transcript.show { display: block; }
        .message-row.sent .voice-transcript { left: auto; right: 0; }
        .bubble-retracted { background: #e0e0e0; font-style: italic; color: #888; animation: retract 0.5s ease-in-out forwards; }
        .retract-button-wrapper { position: absolute; bottom: calc(100% + 5px); z-index: 5; animation: popIn 0.2s ease-out; background: rgba(0, 0, 0, 0.7); border-radius: 15px; padding: 4px; gap: 4px; display: none; }
        .message-row.sent .retract-button-wrapper { right: 0; }
        .message-row.received .retract-button-wrapper { left: 0; }
        .retract-button-wrapper.show { display: flex; }
        .retract-btn { background: transparent; color: white; border: none; border-radius: 12px; padding: 6px 12px; font-size: 0.8rem; cursor: pointer; transition: background 0.2s; display: flex; align-items: center; gap: 5px; }
        .retract-btn:hover { background: rgba(255, 255, 255, 0.2); }
        @keyframes retract { 0% { transform: scale(1); opacity: 1; } 100% { transform: scale(0.8); opacity: 0; } }
        /* AI Typing Indicator Bubble */
        .bubble-typing { display: flex; gap: 5px; align-items: center; padding: 10px 15px; background: var(--text-color-white); border: 1px solid var(--theme-color-2); border-top-left-radius: 5px; }
        .typing-dot { width: 8px; height: 8px; background-color: var(--text-color-light); border-radius: 50%; animation: typing-pulse 1.4s infinite ease-in-out both; }
        .typing-dot:nth-child(1) { animation-delay: -0.32s; }
        .typing-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes typing-pulse { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }

        .time-divider, .retracted-notice, .system-notice {
            align-self: center;
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
        }

        .chat-area::-webkit-scrollbar {
            width: 6px;
        }
        .chat-area::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.02);
        }
        .chat-area::-webkit-scrollbar-thumb {
            background-color: var(--theme-color-4);
            border-radius: 3px;
        }
        .chat-area::-webkit-scrollbar-thumb:hover {
            background-color: var(--accent-color);
        }

        #history-loader {
            text-align: center;
            padding: 10px;
            display: none; /* Initially hidden */
        }
        #history-loader.visible {
            display: block;
        }
        #history-loader .loader-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid var(--theme-color-2);
            border-top-color: var(--accent-color);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
        }

        .retracted-notice {
            cursor: pointer;
            transition: background 0.3s;
        }
        .retracted-notice:hover {
            background: rgba(0, 0, 0, 0.2);
        }

        /* --- 4.3. 消息列表长按弹窗 --- */
        .message-list-popover {
            position: absolute;
            z-index: 100;
            background: rgba(40, 40, 40, 0.9);
            backdrop-filter: blur(8px);
            border-radius: 12px;
            padding: 5px;
            display: flex;
            gap: 5px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            opacity: 0;
            transform: scale(0.9);
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            color: white;
        }
        .message-list-popover-btn {
            background: transparent;
            border: none;
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: background-color 0.2s;
        }
        .message-list-popover-btn:hover {
            background-color: rgba(255,255,255,0.15);
        }
        .message-item .item-pin-icon {
            color: var(--accent-color);
            margin-right: 8px;
            font-size: 0.9rem;
        }

        .chat-input-area {
            display: flex;
            flex-direction: column; /* 改为纵向布局 */
            padding: 10px 15px;
            border-top: 1px solid var(--border-color);
            background-color: white;
            flex-shrink: 0;
            position: relative; /* 为表情面板定位 */
        }
        /* 聊天页面顶部*/
        #page-chat .page-header {
            background: white;
        }


        /* --- 功能：引用预览样式 --- */
        .quote-preview-area {
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 8px;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: var(--text-color-medium);
            margin-bottom: 8px; /* 和下方输入框的间距 */
            display: none; /* 默认隐藏 */
        }
        .quote-preview-content { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .cancel-quote-btn { background: none; border: none; font-size: 1.2rem; color: #999; cursor: pointer; padding: 0 5px;}

        /* 输入和发送按钮的容器 */
        .input-top-row {
            display: flex;
            align-items: flex-end;
            width: 100%;
        }
        
        /* 新增：包裹层，用于横向滚动 */
        .input-feature-row-wrapper {
            width: 100%;
            overflow-x: auto;
            padding-bottom: 5px; /* 为滚动条预留空间，如果可见 */
            margin-bottom: -5px; /* 补偿内边距，避免增加额外高度 */
        }
        .input-feature-row-wrapper::-webkit-scrollbar {
            display: none; /* 隐藏滚动条 (Chrome, Safari) */
        }
        .input-feature-row-wrapper {
            -ms-overflow-style: none;  /* 隐藏滚动条 (IE, Edge) */
            scrollbar-width: none;  /* 隐藏滚动条 (Firefox) */
        }

        /* 新增的功能按钮行 */
        .input-feature-row {
            display: flex;
            align-items: center;
            gap: 12px;
            padding-top: 8px;
            width: max-content; /* 关键：让行内容不换行，从而可以滚动 */
        }
        .feature-btn {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .feature-btn:hover {
            background: white;
            color: var(--accent-color);
        }

        /* 表情包面板 */
        .emoji-card {
            position: absolute;
            bottom: 100%; /* 位于输入区域正上方 */
            left: 10px; right: 10px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
            padding: 15px;
            z-index: 100;
            display: none;
            max-height: 250px;
            overflow-y: auto;
        }
        .emoji-card.active { display: block; }

        .emoji-item-add {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-color-light);
            font-size: 24px;
        }
        .emoji-item-add:hover {
            background-color: rgba(0,0,0,0.05);
            color: var(--accent-color);
            border-color: var(--accent-color);
        }

.emoji-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr); /* 4列 */
    grid-template-rows: repeat(2, auto); /* 2行 */
    gap: 15px; /* 增大间距 */
    min-height: 140px; /* 调整最小高度以适应新布局 */
}
        .emoji-nav {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        .emoji-nav button {
            background: none;
            border: none;
            font-size: 1.1rem;
            color: var(--text-color-light);
            cursor: pointer;
            padding: 5px 15px;
        }
        .emoji-nav button:hover {
            color: var(--accent-color);
        }
        #emoji-page-indicator {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            min-width: 30px;
            text-align: center;
        }
        
        .emoji-item { cursor: pointer; text-align: center; transition: transform 0.2s; }
        .emoji-item:hover { transform: scale(1.1); }
        .emoji-item img { width: 60px; height: 60px; object-fit: contain; }
        .emoji-item { position: relative; } /* 为绝对定位提供基准 */
        .favorite-emoji-toggle {
            position: absolute;
            top: -2px;
            right: -2px;
            width: 22px;
            height: 22px;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            color: #ccc;
            font-size: 0.8rem;
            transition: all 0.2s;
            opacity: 0.5; /* 新增：降低默认透明度，避免视觉干扰 */
        }
        .favorite-emoji-toggle:hover {
            transform: scale(1.1);
            opacity: 1; /* 新增：悬浮时完全不透明 */
        }
        .favorite-emoji-toggle.is-favorite {
            color: #ffc107; /* 黄色星星 */
            background-color: white;
            border-color: #ffc107;
        }
        #ai-request-btn {
            background: none; border: none; font-size: 1.8rem; color: var(--accent-color); cursor: pointer; padding: 5px 10px 5px 0; transition: transform 0.2s;
        }
        #ai-request-btn:hover {
             transform: scale(1.1);
        }
        #message-input {
            flex-grow: 1;
            border: none;
            background: var(--text-color-white);
            padding: 12px;
            border-radius: 18px;
            resize: none;
            font-size: 1rem;
            font-family: var(--font-main);
            max-height: 100px;
            outline: none;
            margin-left: 10px; /* 和左侧AI按钮的间距 */
        }
        #send-btn {
            background: linear-gradient(135deg, var(--accent-color) 0%, var(--theme-color-2) 100%);
            color: white;
            border: none;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            font-size: 1.2rem;
            margin-left: 10px;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s, box-shadow 0.3s;
            flex-shrink: 0; /* 防止被挤压 */
            box-shadow: 0 4px 10px rgba(167, 199, 231, 0.4);
        }
        #send-btn:hover {
            background-color: var(--accent-color-deep);
            transform: scale(1.05);
        }

        /* --- 8. 模态框/弹窗 --- */
        #modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2500; /* 提升层级，高于侧边栏的 2000 */
        }
        #modal-overlay.visible {
            display: flex;
            animation: fadeIn 0.3s;
        }
        .modal-content {
            background: var(--bg-main);
            padding: 25px;
            border-radius: 20px;
            width: 90%;
            max-width: 450px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: var(--shadow-medium);
            animation: slideInUp 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes slideInUp {
            from { transform: translateY(50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .modal-header {
            font-family: var(--font-title);
            font-size: 1.6rem;
            margin-bottom: 20px;
            text-align: center;
            color: var(--text-color-dark);
        }

        /* --- 详情页样式 (来自参考文件) --- */
        .details-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            padding: 20px;
            box-shadow: var(--shadow-light);
            margin-bottom: 20px;
        }
        .details-header {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            position: relative; /* 新增：为绝对定位的子元素提供定位参考 */
        }
        .details-header-attribution {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            z-index: 2;
            flex-shrink: 0; /* 防止被标题挤压 */
        }
        .details-header-attribution:hover {
            transform: scale(1.1);
            background-color: var(--accent-color);
        }
        .details-header .avatar {
            width: 64px;
            height: 64px;
            border-radius: 12px;
            margin-right: 20px;
            object-fit: cover;
        }
        .details-info .name {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--text-color-dark);
        }
        .details-info .id {
            font-size: 0.9rem;
            color: var(--text-color-light);
        }
        .details-section {
            margin-top: 20px;
        }
        .details-section-title {
            font-size: 1rem;
            color: var(--text-color-medium);
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .details-field {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 1rem;
        }
        .details-field .label { color: var(--text-color-medium); }
        .details-field .value { color: var(--text-color-dark); text-align: right; }
        .details-section p {
            white-space: pre-wrap; /* 关键：让换行符生效 */
            max-height: 150px;     /* 限制最大高度 */
            overflow-y: auto;      /* 内容超出时显示滚动条 */
            line-height: 1.6;
            color: var(--text-color-medium);
            background-color: rgba(0,0,0,0.02); /* 加一点淡淡的底色以区分 */
            padding: 10px;
            border-radius: 8px;
        }
        .details-section p::-webkit-scrollbar { width: 4px; }
        .details-section p::-webkit-scrollbar-thumb { background: var(--theme-color-4); border-radius: 2px; }
        .member-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 15px;
        }
        .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .member-item .avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            margin: 0;
        }
        .member-item .name {
            font-size: 0.8rem;
            margin-top: 5px;
            text-align: center;
            width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .details-actions {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .details-btn {
            width: 100%;
            padding: 14px;
            font-size: 1rem;
            font-weight: 500;
            border-radius: 8px; /* 调整圆角 */
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(255, 255, 255, 0.2); /* 透明背景 */
            border: 1px dashed var(--text-color-light); /* 虚线边框 */
            color: var(--text-color-dark); /* 深色文字 */
        }
        .details-btn:hover {
            background: rgba(255, 255, 255, 0.4);
            border-color: var(--accent-color);
            color: var(--accent-color-deep);
        }
        /* 移除特定的背景色，使其风格统一 */
        .btn-details-primary {
            /* 样式已由 .details-btn 统一处理 */
        }
        .btn-details-danger {
            /* 样式已由 .details-btn 统一处理 */
        }
        .btn-details-danger:hover {
            border-color: #e74c3c;
            color: #c0392b;
        }
        /* --- 结束：详情页样式 --- */

        .form-group {
            margin-bottom: 18px;
        }
        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--text-color-medium);
        }
        .form-group input, .form-group select, .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            border-radius: 10px;
            font-size: 1rem;
            font-family: var(--font-main);
            outline-color: var(--accent-color);
        }
        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }
        .modal-content .form-group textarea {
    max-height: 25vh; /* 限制最大高度为视窗的25% */
    overflow-y: auto; /* 确保内容超出时可滚动 */
}
        .avatar-uploader {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .avatar-preview {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            object-fit: cover;
            background-color: transparent; /* 改为透明 */
            border: 2px solid white;
        }
        .upload-btn {
            padding: 8px 15px;
            background: var(--theme-color-4);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }
        .modal-btn {
            padding: 10px 25px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
        }

        /* --- 新增：颜色选择器样式 --- */
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 4px;
            background-color: var(--text-color-white);
        }
        .color-picker-container input[type="color"] {
            width: 30px;
            height: 30px;
            border: none;
            cursor: pointer;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        .color-picker-container input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-container input[type="color"]::-webkit-color-swatch { border: 1px solid var(--border-color); border-radius: 6px; }

        .color-picker-container .color-hex-input {
            border: none;
            outline: none;
            width: 70px;
            font-family: monospace;
            font-size: 0.9rem;
            background-color: transparent;
            color: var(--text-color-dark);
            text-align: center;
        }
        /* --- 新增结束 --- */

        /* --- Neumorphic Modal Style --- */
        .modal-content.modal-neumorphic {
            background: #F0F0F3;
            border-radius: 20px;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
            border: 1px solid rgba(255, 255, 255, 0.5);
            padding: 25px;
        }
        .modal-neumorphic .modal-header {
            color: #555;
            font-family: var(--font-title);
            text-shadow: 1px 1px 1px #fff;
            text-align: center;
            margin-bottom: 25px;
        }
        .modal-neumorphic .form-group label {
            color: #888;
            font-weight: 500;
            text-shadow: 1px 1px 1px #fff;
        }
        .modal-neumorphic .form-group input,
        .modal-neumorphic .form-group select,
        .modal-neumorphic .form-group textarea {
            background: #F0F0F3;
            border: none;
            border-radius: 12px;
            padding: 12px 15px;
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.7),
                inset 5px 5px 9px rgba(174, 174, 192, 0.2);
            color: var(--text-color-dark);
            font-size: 1rem;
            outline: none;
        }
        .modal-neumorphic .modal-actions {
            display: flex;
            justify-content: space-around; /* Space them out */
            margin-top: 30px;
        }
        .modal-neumorphic .modal-btn {
            padding: 12px 0; /* Vertical padding, horizontal from flex */
            flex: 1; /* Take up equal space */
            margin: 0 10px; /* Spacing between buttons */
            border-radius: 12px;
            border: none;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }
        .modal-neumorphic .btn-primary {
            background: #5A8DEE;
            color: white;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-primary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            background: #4a7de0; /* Slightly darker on hover */
            color: #f0f0f0;
        }
        .modal-neumorphic .btn-secondary {
            background: #F0F0F3;
            color: #888;
            box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.7), 5px 5px 9px rgba(174, 174, 192, 0.4);
        }
        .modal-neumorphic .btn-secondary:hover {
            box-shadow: inset -5px -5px 9px rgba(255, 255, 255, 0.7), inset 5px 5px 9px rgba(174, 174, 192, 0.4);
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background-color: #ccc;
            color: #333;
        }
        .btn-secondary:hover {
            background-color: #bbb;
        }
        .btn-danger {
            background-color: #e74c3c;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .persona-modal-card {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow-light);
        }
        .persona-modal-card h4 {
            font-family: var(--font-title);
            color: var(--accent-color-deep);
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
    .persona-modal-card p {
        font-family: var(--font-inner-voice); /* 应用心声字体 */
        line-height: 1.6;
        color: var(--text-color-dark);
    }
    .note-paper {
        font-family: var(--font-essay); /* 应用随笔字体 */
        background-color: #fdf5d3;
        background-image:
            linear-gradient(90deg, rgba(200, 180, 140, 0.15) 1px, transparent 1px),
            linear-gradient(rgba(200, 180, 140, 0.15) 1px, transparent 1px);
        background-size: 20px 20px;
        border: 1px solid #e0d9c3;
        position: relative;
        padding-top: 30px; /* 为图钉留出空间 */
    }
        .note-paper::before {
            content: '';
            position: absolute;
            top: 5px;
            right: 15px;
            width: 20px;
            height: 20px;
            background: #ff7675;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
            border: 2px solid white;
        }
        .member-select-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 5px;
        }
        .member-select-item {
            display: flex;
            align-items: center; /* 垂直居中对齐 */
            padding: 8px;
            cursor: pointer; /* 让整行都可以点击 */
        }

        .member-select-item input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
        }

        .group-info-modal-body .form-group {
            margin-bottom: 10px;
        }
        .group-info-modal-body .member-list-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(50px, 1fr));
            gap: 15px;
            max-height: 250px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0,0,0,0.02);
            border-radius: 8px;
        }
        .group-info-modal-body .member-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .group-info-modal-body .member-item img {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-bottom: 5px;
            border: 2px solid white;
        }
        .group-info-modal-body .member-item span {
            font-size: 0.8rem;
            color: var(--text-color-medium);
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        /* --- 8.5. 顶部浮窗通知 --- */
        #top-notification-container {
            position: absolute;
            top: 15px; /* 从顶部留出一些间距 */
            left: 50%;
            transform: translateX(-50%);
            width: 95%;
            max-width: 480px; /* 匹配app-container的最大宽度 */
            z-index: 5000;
            pointer-events: none; /* 允许点击穿透容器本身 */
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .notification-banner {
            pointer-events: auto; /* 仅banner可点击 */
            background-color: #FBFBFC; /* 柔和的灰白色 */
            border: 1px solid var(--border-color); /* 使用通用边框色 */
            border-radius: 16px; /* 圆角 */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1); /* 增强阴影效果 */
            padding: 12px 18px; /* 增大内边距 */
            display: flex;
            align-items: center;
            gap: 15px; /* 增大间距 */
            width: fit-content;
            max-width: 95%; /* 限制最大宽度 */
            min-width: 280px; /* 增大最小宽度 */
            cursor: pointer;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: notification-enter 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        
        @keyframes notification-enter {
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        @keyframes notification-exit {
            from {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            to {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
            }
        }

        .notification-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .notification-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .notification-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            gap: 8px;
        }
        .notification-name {
            font-weight: bold;
            color: var(--text-color-dark);
            white-space: nowrap;
        }
        .notification-time {
            font-size: 0.7rem;
            color: var(--text-color-light);
            flex-shrink: 0;
        }
        .notification-message {
            font-size: 0.9rem;
            color: var(--text-color-medium);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* --- 8.5.1 特殊：随笔更新浮窗 --- */
        .essay-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .essay-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .essay-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        .essay-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* 给图标留出空间 */
        }
        .essay-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        @keyframes expand-toast {
            0% { width: 48px; }
            50%, 100% { width: 220px; }
        }

        @keyframes move-icon {
            0% {
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
            }
            40% {
                left: 24px;
                transform: translate(-50%, -50%) scale(0.9);
            }
            50%, 100% {
                left: 24px;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes show-text {
            0%, 50% { opacity: 0; transform: translateX(-10px); }
            100% { opacity: 1; transform: translateX(0); }
        }



        /* --- 8.7. Toast 轻量提示 --- */
        .toast-notification {
            position: fixed; /* 修复：使用fixed定位，相对于视口 */
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.75);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9rem;
            z-index: 10000; /* 确保高于所有其他元素 */
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease-in-out, transform 0.3s ease-in-out;
            animation: toast-in 0.3s forwards;
        }

        @keyframes toast-in {
            from {
                opacity: 0;
                transform: translate(-50%, 20px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 0);
            }
        }

        .toast-notification.hiding {
            opacity: 0;
        }
        /* --- 8.8. Bottom Sheet --- */
        #bottom-sheet-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            backdrop-filter: blur(5px);
            z-index: 3000; /* 高于模态框 */
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out; /* 只对 opacity 过渡 */
        }
        #bottom-sheet-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .bottom-sheet-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            max-height: 50vh;
            background: white;
            border-top-left-radius: 20px;
            border-top-right-radius: 20px;
            box-shadow: 0 -5px 20px rgba(0,0,0,0.1);
            transform: translateY(100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            display: flex;
            flex-direction: column;
        }
        #bottom-sheet-overlay.visible .bottom-sheet-content {
            transform: translateY(0);
        }
        .bottom-sheet-header {
            padding: 15px 20px;
            font-size: 1.2rem;
            font-weight: bold;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }
        .bottom-sheet-body {
            padding: 10px;
            overflow-y: auto;
            max-height: 40vh; /* 新增：设置最大高度以启用滚动 */
        }
        .bottom-sheet-item {
            padding: 15px 20px;
            font-size: 1.1rem;
            cursor: pointer;
            text-align: center;
            border-bottom: 1px solid var(--border-color);
        }
        .bottom-sheet-item:last-child {
            border-bottom: none;
        }
        .bottom-sheet-item:hover {
            background-color: rgba(0,0,0,0.03);
        }
        /* Neumorphic style for bottom sheet */
        .bottom-sheet-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px -7px 20px 0px #fff,
                7px 7px 20px 0px #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item {
            color: var(--text-color-dark);
            border-bottom-color: #d1d9e6;
        }
        .bottom-sheet-content.neumorphic .bottom-sheet-item:hover {
            background: #e6e6e9;
        }
        .bottom-sheet-content.compact-list .bottom-sheet-item {
            padding: 10px 20px; /* Reduced vertical padding */
            font-size: 1rem; /* Slightly smaller font */
        }
/* --- 9. 点击特效 --- */
#click-effect-layer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 9999;
}
.ripple {
    position: absolute;
    border-radius: 50%;
    background-color: var(--accent-color);
    transform: scale(0);
    animation: ripple-effect 0.6s ease-out;
    opacity: 0.5;
}
@keyframes ripple-effect {
    to {
        transform: scale(1);
        opacity: 0;
    }
}
.heart {
    position: absolute;
    color: var(--accent-color);
    animation: heart-fly 1.2s ease-out forwards;
    opacity: 1;
    font-size: 16px;
}
@keyframes heart-fly {
    0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
    }
    100% {
        transform: translate(var(--tx), var(--ty)) scale(0);
        opacity: 0;
    }
}
/* --- 10. 侧边栏 --- */
#sidebar-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(5px);
    z-index: 2000;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s, visibility 0.3s;
}
#sidebar-overlay.visible {
    opacity: 1;
    visibility: visible;
}
#sidebar-content {
    position: absolute;
    top: 0;
    right: 0; /* 改为 right */
    left: auto; /* 新增 */
    width: 80%;
    max-width: 350px;
    height: 100%;
    background: var(--bg-main);
    box-shadow: var(--shadow-medium);
    transform: translateX(100%); /* 改为正值 */
    transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto;
}
#sidebar-overlay.visible #sidebar-content {
    transform: translateX(0);
}
#sidebar-content .form-group {
    margin-bottom: 20px;
}

        /* --- 10.1. 左侧滑出侧边栏 --- */
        #sidebar-content.sidebar-from-left {
            left: 0;
            right: auto;
            transform: translateX(-100%);
        }
        #sidebar-overlay.visible #sidebar-content.sidebar-from-left {
            transform: translateX(0);
        }

        /* --- 10.2. 侧边栏样式调整 --- */
        #sidebar-content .modal-header {
            font-size: 1.4rem; /* 缩小标题字体 */
            padding-bottom: 15px; /* 为分割线留出空间 */
            margin-bottom: 15px; /* 调整与下方内容的间距 */
            border-bottom: 1px solid var(--border-color); /* 添加分割线 */
            position: relative;
        }
        /* 优美的分割线装饰 */
        #sidebar-content .modal-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 50px;
            height: 2px;
            background: var(--accent-color);
            border-radius: 1px;
        }
        #sidebar-content .setting-item span {
            font-size: 1rem; /* 缩小侧边栏内按钮文字大小 */
        }
        

        /* 侧边栏内的特定样式 */
        #sidebar-content .details-card {
             background-color: rgba(255,255,255,0.6);
             margin: 0 0 15px 0;
             padding: 15px;
        }
        #sidebar-content .details-header .avatar {
            width: 50px;
            height: 50px;
        }
        #sidebar-content .details-info .name {
            font-size: 1.3rem;
        }
        #sidebar-content .details-actions {
            margin-top: 20px;
        }
        
        /* 群成员列表弹窗样式 */
        .member-list-modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding-right: 10px; /* 为滚动条留出空间 */
        }
        .member-list-modal-item {
            display: flex;
            align-items: center;
            padding: 10px 5px;
            border-bottom: 1px solid var(--border-color);
        }
        .member-list-modal-item:last-child {
            border-bottom: none;
        }
        .member-list-modal-item img {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            margin-right: 15px;
        }
        .member-list-modal-item .owner-tag {
            font-size: 0.7rem;
            background-color: #f1c40f;
            color: white;
            padding: 2px 6px;
            border-radius: 8px;
            margin-left: 10px;
        }

        /* --- 10.3. Neumorphic Sidebar Style --- */
        #sidebar-content.neumorphic {
            background: #F0F0F3;
            box-shadow: 
                -7px 0px 20px 0px #fff,
                7px 0px 20px 0px #d1d9e6;
            border-left: 1px solid rgba(255, 255, 255, 0.5); /* For right sidebar */
        }
        #sidebar-content.neumorphic.sidebar-from-left {
            box-shadow: 
                -7px 0px 20px 0px #d1d9e6,
                7px 0px 20px 0px #fff;
            border-left: none;
            border-right: 1px solid rgba(255, 255, 255, 0.5);
        }
        #sidebar-content.neumorphic .modal-header {
            color: #555;
            text-shadow: 1px 1px 1px #fff;
            border-bottom-color: #d1d9e6;
        }
        #sidebar-content.neumorphic .modal-header::after {
            background: #888;
            box-shadow: 1px 1px 1px #fff;
        }
        #sidebar-content.neumorphic .setting-item {
            background: transparent;
            box-shadow: 
                -5px -5px 9px rgba(255, 255, 255, 0.9), 
                5px 5px 9px rgba(174, 174, 192, 0.4);
            margin: 0 0 15px; /* Adjust margin */
        }
        #sidebar-content.neumorphic .setting-item:hover {
            box-shadow: 
                inset -5px -5px 9px rgba(255, 255, 255, 0.9), 
                inset 5px 5px 9px rgba(174, 174, 192, 0.4);
            transform: none; /* Override hover transform */
        }

        /* --- 11. 自定义提示词页面 --- */
        #prompts-page-content {
            padding: 15px;
        }
        #prompt-header-actions {
            gap: 10px; /* 减小图标间距 */
        }
        #prompt-header-actions .header-icon {
            font-size: 1.1rem; /* 减小图标大小 */
            padding: 0 5px; /* 减小图标的水平内边距，让其更紧凑 */
        }
        
        .prompt-folder {
            background-color: rgba(255, 255, 255, 0.7);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: var(--shadow-light);
            transition: all 0.3s;
        }
        .prompt-folder-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .prompt-folder-header h3 {
            font-size: 1.1rem;
            color: var(--text-color-dark);
            margin: 0;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-folder-header h3 .folder-toggle-icon {
        transition: transform 0.3s ease-in-out;
         }
        .prompt-folder-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .prompt-folder-controls .folder-action-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-light);
            transition: color 0.2s;
        }
        .prompt-folder-controls .folder-action-btn:hover {
            color: var(--accent-color);
        }
        .prompt-folder-content {
            padding: 15px;
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        }
        .prompt-folder-content.collapsed {
    max-height: 0;
    padding-top: 0;
    padding-bottom: 0;
    overflow: hidden;
    margin-top: -1px; /* 优化边框显示 */
    display: block; 
}
.prompt-folder-header.collapsed .folder-toggle-icon {
    transform: rotate(-90deg);
}
        .prompt-card {
            background-color: var(--text-color-white);
            border-radius: 10px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
            border-left: 5px solid var(--theme-color-4);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .prompt-card.inactive {
            border-left-color: #ccc;
            opacity: 0.7;
        }
        .prompt-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .prompt-card-name {
            font-weight: bold;
            font-size: 1rem;
            color: var(--text-color-dark);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prompt-card-name .prompt-index {
            font-size: 0.8rem;
            background: var(--theme-color-4);
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
        }
        .prompt-card.inactive .prompt-card-name .prompt-index {
            background: #ccc;
        }
        .prompt-card-tags {
            display: flex;
            gap: 6px;
        }
        .prompt-tag {
            font-size: 0.75rem;
            padding: 3px 8px;
            border-radius: 10px;
            color: white;
        }
        .tag-explicit { background-color: var(--accent-color); }
        .tag-implicit { background-color: var(--theme-color-4); }
        .tag-keywords {
            background-color: var(--theme-color-3);
            color: var(--text-color-dark);
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .prompt-card-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .prompt-card-actions .action-btn {
            background: rgba(0,0,0,0.05);
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .prompt-card-actions .action-btn:hover {
            background: var(--accent-color);
            color: white;
        }
        .font-delete-btn {
            padding: 8px 10px;
            font-size: 0.9rem;
            min-width: 40px;
        }
        
        /* --- 12. 绑定提示词弹窗样式 --- */
        .binding-modal-content {
            background: var(--bg-light) !important; /* 使用主页面的浅色背景 */
            backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
        }
        .binding-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .binding-modal-header h2 {
            margin: 0;
            font-size: 1.4rem;
            font-family: var(--font-title);
        }
        #open-folder-selection-btn {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        #open-folder-selection-btn:hover {
            transform: scale(1.1) rotate(90deg);
            background: var(--accent-color-deep);
        }
        #bound-folders-list {
            min-height: 100px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bound-folder-card {
            background: var(--text-color-white);
            padding: 15px;
            border-radius: 10px;
            box-shadow: var(--shadow-light);
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .bound-folder-card i {
            font-size: 1.5rem;
            color: var(--theme-color-4);
        }
        .bound-folder-card span {
            font-size: 1.1rem;
            flex-grow: 1;
        }

        .folder-selection-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .folder-selection-item {
            display: flex;
            align-items: center;
            padding: 12px;
            background-color: rgba(255,255,255,0.5);
            border-radius: 8px;
            cursor: pointer;
        }
        .folder-selection-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 15px;
            accent-color: var(--accent-color);
        }
        .folder-selection-item i {
            margin-right: 10px;
            color: var(--text-color-medium);
        }
        
        /* --- 开关样式 (可复用) --- */
        .switch { position: relative; display: inline-block; width: 52px; height: 30px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 30px; }
        .slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.2); }
        input:checked + .slider { background-color: var(--accent-color); }
        input:checked + .slider:before { transform: translateX(22px); }


        /* --- 13. 发现页面 --- */
        #page-discover .settings-list {
            padding-top: 10px;
        }
        #page-discover .setting-item {
            margin: 0 10px 1px; /* 紧凑列表 */
            border-radius: 0;
            padding: 18px 15px;
            background: var(--text-color-white);
        }
        #page-discover .setting-item:first-child {
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
            margin-top: 10px;
        }
        #page-discover .setting-item:last-child {
            border-bottom-left-radius: 12px;
            border-bottom-right-radius: 12px;
            margin-bottom: 10px;
        }
        #page-discover .setting-item:hover {
            transform: none;
            box-shadow: none;
            background-color: #f7f7f7;
        }

        /* --- 14. 朋友圈页面 --- */
        #page-moments {
            /* 关键1：让它成为一个剪裁和定位的容器 */
            overflow: hidden; 
            position: relative; /* 新增：为子元素的绝对定位提供基准 */
        }

        #moments-wrapper {
            /* 关键2：使用绝对定位来确保尺寸和位置的精确性 */
            position: absolute;
            top: 0;
            left: 0;
            width: 125%; /* 100% / 0.8 = 125% */
            height: 125%;
            transform: scale(0.8);
            transform-origin: top left;
            
            /* 内部布局保持不变，依然使用flex来排列header和content */
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 防止内部出现意外的滚动条 */
        }
        #page-moments .page-header {
            display: flex; /* 使用flex布局以适应按钮 */
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            position: absolute; /* 浮动在背景图上 */
            top: 0;
            left: 0;
            right: 0;
            background: transparent;
            border-bottom: none;
            z-index: 10;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
        }
        #moments-actions-group {
            display: flex;
            gap: 10px;
        }
        #page-moments .page-header .header-icon {
            color: var(--text-color-white);
            text-shadow: 1px 1px 3px rgba(0,0,0,0.5);
            font-size: 1.4rem;
            padding: 5px 8px; /* 调整内边距使按钮更紧凑 */
        }

        #page-moments .page-content {
            padding: 0; /* 移除内边距，让内容填满 */
            background-color: var(--theme-color-1);
        }

        .moments-header-container {
            position: relative;
        }
        #moments-bg {
            width: 100%;
            height: 250px;
            object-fit: cover;
            display: block;
        }
        .moments-profile-info {
            position: absolute;
            bottom: 0;
            right: 15px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .moments-profile-info .name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--text-color-white);
            text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
        }
        .moments-profile-info .avatar {
            width: 70px;
            height: 70px;
            border-radius: 10px;
            border: 3px solid white;
            box-shadow: var(--shadow-light);
        }

        #moments-list {
            list-style: none;
            padding: 0;
            background-color: var(--bg-light);
        }

        .moments-post {
            display: flex;
            gap: 15px;
            padding: 20px 15px;
            border-bottom: 1px solid var(--border-color);
        }
        .post-avatar {
            width: 45px;
            height: 45px;
            border-radius: 8px;
            object-fit: cover;
            flex-shrink: 0;
        }
        .post-main-content {
            flex-grow: 1;
            overflow: hidden;
        }
        .post-author-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: var(--accent-color-deep);
            margin-bottom: 8px;
        }
        .post-text {
            font-size: 1rem;
            line-height: 1.6;
            margin-bottom: 10px;
            white-space: pre-wrap;
        }
        .post-images-grid {
            display: grid;
            gap: 5px;
            margin-bottom: 10px;
        }
        .post-images-grid.grid-1 { grid-template-columns: minmax(0, 2fr); }
        .post-images-grid.grid-2, .post-images-grid.grid-4 { grid-template-columns: repeat(2, 1fr); }
        .post-images-grid.grid-3, .post-images-grid.grid-5, .post-images-grid.grid-6, .post-images-grid.grid-7, .post-images-grid.grid-8, .post-images-grid.grid-9 { grid-template-columns: repeat(3, 1fr); }

        .post-images-grid img {
            width: 100%;
            height: 100px;
            object-fit: cover;
            border-radius: 6px;
            background-color: var(--theme-color-1);
        }
        .post-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .post-timestamp {
            font-size: 0.8rem;
            color: var(--text-color-light);
        }
        .post-actions-btn {
            background: transparent; /* 去掉背景色 */
            border: none;
            width: 30px;
            height: 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
            transition: background-color 0.2s; /* 添加过渡效果 */
        }
        .post-actions-btn:hover, .post-action-icon-btn:hover {
            background-color: rgba(0, 0, 0, 0.05); /* 添加悬浮效果 */
        }

        .post-comments-section {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
        }
        .post-interactions {
            background-color: #f7f7f7;
            border-radius: 8px;
            padding: 5px;
            font-size: 0.9rem;
            margin-top: 10px;
        }
        .post-likes {
            padding: 8px 10px;
            line-height: 1.5;
            color: var(--accent-color-deep);
            font-weight: 500;
            border-bottom: 1px solid #ededed;
        }
        .post-likes .fa-heart {
            margin-right: 8px;
        }
        .post-likes:empty {
            display: none;
        }
        .post-likes:empty + .post-comments-list {
            border-top: none; /* 如果没有点赞，评论区就不要有上边框 */
        }
        .post-footer .action-buttons-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .post-action-icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            color: var(--text-color-medium);
        }
        .post-action-icon-btn.liked .fa-heart {
            color: var(--accent-color);
            font-weight: 900; /* 'fas' style */
        }
        .post-comment-item {
            padding: 8px 10px;
            line-height: 1.5;
        }
        .comment-author {
            color: var(--accent-color);
            font-weight: bold;
        }
        .comment-reply-to {
            color: var(--text-color-medium);
        }
        .post-comment-typing-indicator {
            padding: 8px 10px;
            color: var(--text-color-light);
            font-style: italic;
        }

        /* 评论输入框 */
        .comment-input-wrapper {
            display: none; /* 默认隐藏 */
            padding: 8px 10px;
            margin-top: 5px;
        }
        .comment-input-wrapper.active {
            display: flex; /* 点击评论按钮后显示 */
            gap: 8px;
        }
        .comment-input-wrapper input {
            flex-grow: 1;
            border: 1px solid var(--border-color);
            border-radius: 15px;
            padding: 8px 12px;
            font-size: 0.9rem;
            outline: none;
        }
        .comment-input-wrapper button {
            background: var(--accent-color);
            color: white;
            border: none;
            border-radius: 15px;
            padding: 0 15px;
            font-size: 0.9rem;
            cursor: pointer;
        }

        /* --- 15. 朋友圈转发卡片样式 --- */
        .bubble.forwarded-moment-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 250px;
        }
        .bubble.forwarded-moment-bubble:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        /* --- 核心修复：针对所有主题，强制重置特殊消息的气泡样式 --- */
        #app-container[class*="app-bubble-style-"] .bubble.transfer-or-red-packet-bubble,
        #app-container[class*="app-bubble-style-"] .bubble.card-bubble,
        #app-container[class*="app-bubble-style-"] .bubble.forwarded-moment-bubble {
            background: none !important;
            border: none !important;
            box-shadow: none !important;
            padding: 0 !important;
        }
        
        .forwarded-moment-card-content {
            background-color: var(--text-color-white);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .forwarded-moment-card-content .card-title {
            font-size: 0.9rem;
            font-weight: 500;
        }
        .forwarded-moment-card-content .card-preview {
            font-size: 0.8rem;
            color: var(--text-color-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .forwarded-moment-card-content .card-footer {
            font-size: 0.75rem;
            color: var(--text-color-light);
            border-top: 1px solid var(--border-color);
            padding-top: 8px;
            margin-top: 8px;
        }

        /* --- 朋友圈转发卡片详情弹窗样式 --- */
        .moment-detail-wrapper { padding: 20px 15px; }
        .moment-detail-wrapper .post-header { display: flex; align-items: center; gap: 15px; }
        .moment-detail-wrapper .post-avatar { width: 50px; height: 50px; border-radius: 8px; object-fit: cover; }
        .moment-detail-wrapper .post-author-info .name { font-size: 1.1rem; font-weight: 600; color: var(--accent-color-deep); }
        .moment-detail-wrapper .post-content-full { margin: 15px 0; font-size: 1rem; line-height: 1.7; white-space: pre-wrap; }
        .moment-detail-wrapper .post-image-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 5px; margin: 15px 0; }
        .moment-detail-wrapper .post-image-grid img { width: 100%; height: 80px; object-fit: cover; border-radius: 6px; }
        .moment-detail-wrapper .post-footer-full { display: flex; justify-content: space-between; align-items: center; color: var(--text-color-light); font-size: 0.8rem; margin-bottom: 10px; }
        .moment-detail-wrapper .interactions-section { background-color: rgba(0,0,0,0.03); border-radius: 8px; font-size: 0.9rem; }
        .moment-detail-wrapper .likes-list { padding: 10px 12px; line-height: 1.5; color: var(--accent-color-deep); font-weight: 500; word-break: break-all; }
        .moment-detail-wrapper .likes-list .fa-heart { margin-right: 8px; }
        .moment-detail-wrapper .likes-list:empty + .comments-list { border-top: none; }
        .moment-detail-wrapper .comments-list { padding: 5px 0; border-top: 1px solid var(--border-color); }
        .moment-detail-wrapper .comment-item { padding: 8px 12px; line-height: 1.5; }
        .moment-detail-wrapper .comment-author { color: var(--accent-color); font-weight: bold; }
        .moment-detail-wrapper .comment-reply-to { color: var(--text-color-medium); }

        /* 
        =============================
        消息气泡样式 (来自参考文件)
        =============================
        */

        /* --- 通用基础样式 --- */
        .bubble.transfer-or-red-packet-bubble,
        .bubble.card-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            max-width: 280px;
        }
        .bubble.transfer-or-red-packet-bubble:not(.claimed):hover,
        .bubble.card-bubble:hover .card-message-wrapper {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12);
        }
        .bubble.card-bubble {
            max-width: 280px; /* 调整为 max-width */
        }

        /* --- 卡片消息容器样式 --- */
        .card-message-wrapper {
            background-color: var(--text-color-white, white);
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            color: var(--text-color-dark, #333);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .card-message-wrapper h4,
        .card-message-wrapper p {
            margin: 0;
            padding: 0;
            line-height: 1.4;
        }
        .card-message-wrapper h4 {
            font-size: 1rem;
            font-weight: 600;
        }
        .card-message-wrapper p {
            font-size: 0.85rem;
            color: var(--text-color-light, #666);
        }

        /* --- 卡片详情展开样式 (修改后) --- */
        .bubble.card-bubble {
            position: relative; /* 新增：为绝对定位的子元素提供参考 */
            overflow: visible;  /* 新增：允许绝对定位的子元素溢出 */
            background: none; /* 卡片消息本身不需要背景 */
            padding: 0;       /* 移除内边距，由内部wrapper控制 */
            box-shadow: none; /* 移除阴影，由内部wrapper控制 */
        }
        .card-detail-content {
            position: absolute; /* 关键修改：脱离文档流 */
            top: 100%; /* 定位到可见卡片的正下方 */
            left: 0;
            width: 100%;
            z-index: 10; /* 确保在其他元素之上 */
            
            background-color: var(--text-color-white); /* 固定白色背景 */
            color: var(--text-color-dark); /* 固定深色字体 */
            border: 1px solid var(--border-color, #eee);
            border-radius: 12px; /* 给自己完整的圆角 */
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 独立的外阴影 */
            padding: 15px;

            max-height: 0; /* 默认隐藏 */
            opacity: 0;
            overflow: hidden;
            transition: max-height 0.4s ease, opacity 0.4s ease, padding-top 0.4s ease, padding-bottom 0.4s ease;
            box-sizing: border-box;
        }
        .card-detail-content.visible {
            max-height: 500px;
            opacity: 1;
        }
        /* 确保详情内的文字颜色不被外部气泡样式覆盖 */
        .card-detail-content h5, .card-detail-content p {
            color: var(--text-color-dark) !important;
        }

        /* --- 1. 新版转账样式 --- */
        .message-row.sent .transfer-content-v3 {
            background-color: #BEE3F8;
            color: #2A4365;
        }
        .message-row.received .transfer-content-v3 {
            background-color: #FFF0F5;
            color: var(--text-color-dark);
        }
        .transfer-content-v3 {
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%;
            min-width: 200px; /* 新增：设置最小宽度 */
            position: relative; /* 新增：为伪元素定位 */
            overflow: hidden; /* 新增：裁剪伪元素 */
            z-index: 1; /* 新增：确保内容在背景之上 */
        }
        /* 新增：确保内容在遮罩层之上 */
        .transfer-content-v3 > * {
            position: relative;
            z-index: 2;
        }
        /* 新增：半透明白色遮罩，降低背景图饱和度 */
        .transfer-content-v3::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.65);
            z-index: 1;
        }
        .transfer-header-v3 {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 5px;
        }
        .transfer-icon-v3 {
            font-size: 22px;
        }
        .message-row.sent .transfer-icon-v3 { color: #3182CE; }
        .message-row.received .transfer-icon-v3 { color: #FF69B4; }

        .transfer-info-v3 h4 { margin: 0; font-size: 1em; font-weight: 500; }
        .transfer-info-v3 p { margin: 0; font-size: 1.2em; font-weight: 700; }
        .transfer-footer-v3 {
            border-top: 1px solid rgba(0,0,0,0.08);
            padding-top: 5px;
            margin-top: 5px;
            font-size: 0.75em;
            color: #777;
        }
        .bubble.claimed .transfer-content-v3 {
            background-color: #e0e0e0;
            opacity: 0.8;
        }

        /* --- 2. 新版红包样式 --- */
        .red-packet-v3-wrapper {
            width: 120px;
            height: 160px;
            position: relative;
        }
        .rp-cover-v3 {
            width: 100%;
            height: 100%;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            background-image: url('https://z.wiki/u/IDzEvp'); /* 已更换为新的默认封面 */
            background-size: cover;
            background-position: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-end; /* 让内容从底部开始对齐，为隐藏标题做准备 */
            padding: 10px;
            box-sizing: border-box;
        }
        .rp-title-v3 {
            display: none; /* 已隐藏红包封面上的标题 */
        }
        .open-button-v3 {
            width: 45px;
            height: 45px;
            background-color: var(--red-packet-gold);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 22px;
            color: var(--red-packet-red);
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
            animation: paw-pulse 2s infinite ease-in-out;
            align-self: center; /* 确保在 flex 布局中居中 */
            margin-bottom: 5px; /* 调整与底部距离 */
        }
        .claimed-overlay-v3 {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.7);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--red-packet-red);
            font-weight: bold;
            font-size: 1rem;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .bubble.claimed .claimed-overlay-v3 {
            opacity: 1;
        }
        .bubble.claimed .open-button-v3 {
            display: none; /* 领取后隐藏按钮 */
        }
        
        /* --- 3. 左图右文卡片 (通用分享) --- */
        .card-type-2 { display: flex; align-items: center; }
        .card-type-2 .card-image { width: 80px; height: 80px; object-fit: cover; flex-shrink: 0; }
        .card-type-2 .card-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
            overflow: hidden;
        }
        .card-type-2 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* --- 4. 图标聚焦卡片 (位置分享) --- */
        .card-type-3 { display: flex; align-items: center; padding: 16px; gap: 15px; }
        .card-type-3 .card-icon-area {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--theme-color-1);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
        }
        .card-type-3 .card-icon-area i { font-size: 1.8rem; color: var(--text-color-white, white); }
        .card-type-3 .card-content { flex-grow: 1; }

        /* --- 5. 文件下载卡片 --- */
        .card-type-9 { display: flex; align-items: center; padding: 15px; gap: 15px; }
        .card-type-9 .file-icon { font-size: 3rem; color: var(--theme-color-4); }
        .card-type-9 .file-info { flex-grow: 1; overflow: hidden; }
        .card-type-9 h4 { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-type-9 .file-size { font-size: 0.8rem; color: var(--text-color-light); margin-top: 4px; }
        
        /* --- 6. 主动回复与时间戳样式 --- */

        .message-timestamp {
            font-size: 0.75rem;
            color: var(--text-color-light);
            margin-top: 5px;
            padding: 0 5px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .message-row.sent .message-timestamp {
            justify-content: flex-end;
        }
        .auto-reply-tag {
            font-size: 0.65rem;
            color: #1890FF;
            background-color: #E6F7FF;
            padding: 2px 6px;
            border-radius: 8px;
            border: 1px solid #91D5FF;
        }
        /* --- 16. 主题设置页面 (新) --- */
        #page-theme-settings .page-content {
            padding: 15px;
            background-color: rgba(0,0,0,0.02); /* 给页面一个淡淡的底色 */
        }

        .theme-setting-card {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            border: 1px solid var(--border-color);
            border-radius: 16px; /* 更大的圆角 */
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: var(--shadow-light);
        }
        .theme-setting-card h3 {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--text-color-dark);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .theme-setting-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .theme-page-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 12px; /* 按钮圆角 */
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            transition: all 0.2s;
            background-color: var(--text-color-white);
            color: var(--text-color-dark);
            border: 1px solid var(--border-color);
        }
        .theme-page-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* 颜色选择弹窗 */
        .color-palette-modal-body {
            display: flex;
            justify-content: space-around; /* 水平排列 */
            align-items: center;
            gap: 15px;
            padding: 20px 0;
        }
        .color-picker-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .color-picker-wrapper input[type="color"] {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-color: transparent;
            padding: 0;
        }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        .color-picker-wrapper input[type="color"]::-webkit-color-swatch { border: none; border-radius: 50%; }

        /* 上传组件 */
        .theme-upload-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }
        .theme-upload-preview-wrapper {
            position: relative;
            width: 120px;
            height: 80px;
            flex-shrink: 0;
        }
        .theme-upload-preview {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
            background-color: #e9e9e9;
            border: 1px solid var(--border-color);
        }
        /* 羽化效果 */
        .theme-upload-preview-wrapper::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 8px;
            box-shadow: inset 0 0 10px 5px rgba(255, 255, 255, 0.9);
            pointer-events: none;
        }
        /* --- 17. 教程页面 (新) --- */
        #page-tutorial {
            background-color: #fff !important;
            background-image: none !important;
        }
        .tutorial-watermark {
            position: absolute;
            bottom: 10px;
            right: 15px;
            font-size: 0.7rem;
            color: #d0d0d0;
            pointer-events: none;
            user-select: none;
            text-align: right; /* 新增：让文字右对齐 */
        }

        /* --- 18. 旁白消息样式 (新) --- */
        .narrator-notice {
            align-self: center;
            padding: 4px 10px;
            border-radius: 10px;
            margin: 5px 0;
            max-width: 90%;
            word-wrap: break-word;
            text-align: left;
            line-height: 1.5;
            white-space: pre-wrap; /* 新增：让换行符生效 */
        }
        .narrator-style-grey {
            background: rgba(0, 0, 0, 0.1);
            color: var(--text-color-white);
            font-size: 0.75rem;
        }
        .narrator-style-white {
            background: rgba(255, 255, 255, 0.9);
            color: var(--text-color-dark);
            font-size: 0.85rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
        }
        .narrator-style-black {
            background: rgba(0, 0, 0, 0.75);
            color: var(--text-color-white);
            font-size: 0.85rem;
        }

        /* --- 19. 番茄钟 (新) --- */
        #page-pomodoro .page-content {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 30px;
        }

        .pomodoro-timer-display {
            font-size: 5rem;
            font-weight: bold;
            color: var(--text-color-dark);
            font-family: 'Courier New', Courier, monospace;
            letter-spacing: 2px;
        }

        .pomodoro-goal-input {
            width: 100%;
            max-width: 300px;
            text-align: center;
            border: none;
            border-bottom: 2px solid var(--border-color);
            background: transparent;
            padding: 10px;
            font-size: 1.2rem;
            outline: none;
            transition: border-color 0.3s;
        }
        .pomodoro-goal-input:focus {
            border-bottom-color: var(--accent-color);
        }

        .pomodoro-controls {
            display: flex;
            gap: 20px;
        }

        .pomodoro-btn {
            padding: 12px 30px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 25px;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }
        .pomodoro-btn.start {
            background-color: var(--accent-color);
            color: white;
        }
        .pomodoro-btn.start:hover {
            background-color: var(--accent-color-deep);
            transform: translateY(-2px);
        }
        .pomodoro-btn.stop {
            background-color: #e74c3c;
            color: white;
        }
        .pomodoro-btn.stop:hover {
            background-color: #c0392b;
        }

        #pomodoro-float-ball {
            position: fixed;
            bottom: 150px; /* 向上移动了一点 */
            right: 20px;
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.7); /* 降低了一点不透明度 */
            backdrop-filter: blur(10px); /* 增强模糊效果 */
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            /* 增加了高光和更柔和的阴影，营造泡泡感 */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15), inset 0 2px 4px rgba(255, 255, 255, 0.5);
            cursor: grab; /* 提示可以抓取 */
            z-index: 1500;
            transition: opacity 0.3s, transform 0.3s;
            user-select: none; /* 防止长按选中文本 */
            -webkit-user-select: none; /* 兼容老浏览器 */
        }
        #pomodoro-float-ball.dragging {
            cursor: grabbing; /* 拖动时的手型 */
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2); /* 拖动时阴影变大，有悬浮感 */
            transform: scale(1.05);
        }
        #pomodoro-float-ball.hidden {
            opacity: 0;
            transform: scale(0.5);
            pointer-events: none;
        }
        #pomodoro-float-ball .progress-ring {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: conic-gradient(var(--accent-color) 0deg, #e0e0e0 0deg);
            z-index: -1;
        }
        #pomodoro-float-ball .time-left {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--text-color-dark);
        }

        .pomodoro-notification-banner {
            pointer-events: auto;
            position: relative;
            width: 48px;
            height: 48px;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
            color: #fff;
            border-radius: 50px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: width 0.5s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .pomodoro-notification-banner.is-playing {
            animation: expand-toast 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .icon-wrapper {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .pomodoro-notification-banner.is-playing .icon-wrapper {
             animation: move-icon 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }
        .pomodoro-notification-banner .text-content {
            opacity: 0;
            white-space: nowrap;
            padding-left: 52px; /* 给图标留出空间 */
        }
        .pomodoro-notification-banner.is-playing .text-content {
            animation: show-text 1s cubic-bezier(0.65, 0, 0.35, 1) forwards;
        }

        /* --- 旁白设置选项样式 --- */
        .narrator-style-selector {
            display: flex;
            justify-content: space-around;
            gap: 15px;
            padding: 10px 0;
        }
        .narrator-style-option {
            flex: 1;
            padding: 15px 10px;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            border: 2px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .narrator-style-option.selected {
            border-color: var(--accent-color);
            transform: scale(1.05);
            box-shadow: var(--shadow-light);
        }
        .narrator-style-option.grey-option { background: #ccc; color: white; }
        .narrator-style-option.white-option { background: white; color: #333; }
        .narrator-style-option.black-option { background: #333; color: white; }

        /* --- 20. 送礼物页面 (新) --- */
        #page-gifts .page-content {
            padding: 15px;
            /* 将背景色改为更灰的主背景色 */
            background-color: var(--bg-main); 
        }
        .gifts-search-container {
            /* 改为纵向排列 */
            display: flex;
            flex-direction: column; 
            gap: 15px; /* 增加行间距 */
            margin-bottom: 20px;
        }
        /* 新增：为搜索和按钮行创建包裹层 */
        .gifts-search-container .search-row,
        .gifts-search-container .action-row {
            display: flex;
            width: 100%;
            gap: 10px;
        }
        /* 新增：为长方形按钮设计样式 */
        .gifts-search-container .action-btn {
            flex: 1; /* 让按钮平分宽度 */
            width: auto; /* 覆盖 .gift-header-btn 的固定宽度 */
            height: auto; /* 覆盖 .gift-header-btn 的固定高度 */
            padding: 10px;
            border-radius: 12px; /* 增加圆角 */
            font-weight: 500;
            font-size: 0.9rem; /* 调整字体大小以适应按钮 */
            background-color: rgba(255, 255, 255, 0.85); /* 增加透明度 */
        }
        .gifts-search-container .search-bar-wrapper {
            flex-grow: 1;
            position: relative;
        }
        .gifts-search-container .search-bar-wrapper i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--text-color-light);
        }
        #gift-search-input {
            width: 100%;
            height: 45px;
            border-radius: 22.5px;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            padding: 0 20px 0 45px;
            font-size: 1rem;
            outline: none;
            transition: all 0.2s;
        }
        #gift-search-input:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(167, 199, 231, 0.2);
        }
        #gift-search-refresh-btn {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            font-size: 1rem;
            color: var(--text-color-medium);
            cursor: pointer;
        }
        #gift-search-refresh-btn:hover i {
            color: var(--accent-color);
        }
        .gift-header-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background-color: var(--text-color-white);
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            font-size: 1.2rem;
            color: var(--text-color-medium);
            transition: all 0.2s;
        }
        .gift-header-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: scale(1.1);
        }
        .gifts-section-title {
            font-size: 1.2rem;
            color: var(--text-color-dark);
            margin-bottom: 15px;
            padding-left: 5px;
        }
        .gifts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
        }
        .gift-card {
            background-color: var(--text-color-white);
            border-radius: 12px;
            box-shadow: var(--shadow-light);
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .gift-card:hover {
            transform: translateY(-5px);
            box-shadow: var(--shadow-medium);
        }
        .gift-card img {
            width: 100%;
            height: 120px;
            object-fit: cover;
            display: block;
            background-color: var(--theme-color-1);
        }
        .gift-card-info {
            padding: 10px;
        }
        .gift-card-info .name {
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 5px;
        }
        .gift-card-info .price {
            font-size: 0.9rem;
            font-weight: bold;
            color: var(--accent-color-deep);
        }
        .gift-loader {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 0;
            color: var(--text-color-medium);
        }
        .gift-loader .loader-spinner {
            margin-bottom: 15px;
        }

        /* 礼物消息气泡样式 */
        .bubble.gift-bubble {
            padding: 0;
            background: none;
            border: none;
            box-shadow: none;
            max-width: 250px;
            width: 250px;
        }
        #app-container[class*="app-bubble-style-"] .bubble.gift-bubble {
            padding: 0 !important;
            background: none !important;
            border: none !important;
            box-shadow: none !important;
        }
        .gift-message-content {
            background: linear-gradient(135deg, #FFF7E0 0%, #FFE9D1 100%);
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 4px 15px rgba(255, 220, 180, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.5);
            display: flex;
            gap: 12px;
            align-items: center;
        }
        .gift-message-content .gift-image {
            width: 60px;
            height: 60px;
            object-fit: cover;
            border-radius: 8px;
            flex-shrink: 0;
        }
        .gift-message-content .gift-info {
            flex-grow: 1;
            color: #8D6E63;
        }
        .gift-message-content .gift-info .gift-name {
            font-weight: bold;
            font-size: 1rem;
        }
        .gift-message-content .gift-info .gift-message {
            font-size: 0.85rem;
            margin-top: 4px;
            font-style: italic;
        }
        .gift-message-content .gift-info .gift-price {
            font-size: 0.8rem;
            margin-top: 6px;
            color: #D32F2F;
        }

    </style>
</head>
<body>
    <!-- 开屏动画 -->
    <div id="splash-screen">
        <div class="splash-logo">33聊天室</div>
        <div class="splash-loader"></div>
        <p style="position: absolute; bottom: 20px; font-size: 12px; color: #aaa; user-select: none;">此聊天室由33制作，xhs:@回风</p>
    </div>
    <div id="app-container">
        <!-- 顶部浮窗通知容器 -->
        <div id="top-notification-container"></div>
        <!-- 主内容区域 -->
        <main id="main-content">
            <!-- 消息列表页面 -->
            <div id="page-messages" class="page active">
                <div class="page-header">
                    <img id="my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="My Avatar">
                    <h1>消息</h1>
                    <a href="https://www.xiaohongshu.com/user/profile/5e65e0f00000000001002837?xsec_token=YBen3b8AVcwS9WjKSzS_xETWKfb3hsoxlS1uX8KTmQLSU%3D&xsec_source=app_share&xhsshare=CopyLink&appuid=5e65e0f00000000001002837&apptime=1751753800&share_id=a6aa049960ff46489ba8080e8cc476d0&share_channel=copy_link" target="_blank" id="header-link-btn">
                        <i class="fas fa-lightbulb"></i>
                    </a>
                </div>
                <div class="page-content">
                    <ul id="message-list-ul" class="message-list">
                        <!-- 消息项将由JS动态生成 -->
                    </ul>
                </div>
            </div>

            <!-- 通讯录页面 -->
            <div id="page-contacts" class="page">
                <div class="page-header">
                    <div class="header-icon" style="visibility: hidden;"></div> <!-- 占位符 -->
                    <h1>通讯录</h1>
                    <div class="header-icon-group">
                        <div id="batch-delete-btn" class="header-icon" title="批量删除"><i class="fas fa-minus-circle"></i></div>
                        <div id="add-menu-btn" class="header-icon" title="添加"><i class="fas fa-plus"></i></div>
                    </div>
                </div>
                <div class="tabs">
                    <button class="tab-btn active" data-tab="friends">好友</button>
                    <button class="tab-btn" data-tab="groups">群聊</button>
                    <button class="tab-btn" data-tab="friendFolders">分组</button>
                </div>
                <div class="page-content" style="padding: 0 15px;">
                    <div id="contacts-friends" class="contact-section active">
                        <div class="contact-list-header">
                            <span id="sort-friends-btn" class="sort-btn">排序 <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="friends-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-groups" class="contact-section">
                        <div class="contact-list-header">
                            <span id="sort-groups-btn" class="sort-btn">排序 <i class="fas fa-sort"></i></span>
                        </div>
                        <ul id="groups-list-ul" class="contact-list"></ul>
                    </div>
                    <div id="contacts-friend-folders" class="contact-section">
                        <!-- Content will be generated by JS -->
                    </div>
                </div>
                <div id="selection-action-bar" class="page-footer" style="display: none; justify-content: space-between; padding: 10px 15px; background: white; border-top: 1px solid var(--border-color);">
                    <button id="select-all-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">全选</button>
                    <button id="cancel-selection-btn" class="modal-btn btn-secondary" style="padding: 8px 20px;">取消</button>
                    <button id="delete-selected-btn" class="modal-btn btn-danger" style="padding: 8px 20px;">删除已选</button>
                </div>
            </div>

            <!-- 设置页面 -->
            <div id="page-settings" class="page">
                <div class="page-header">
                    <h1>设置</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="setting-tutorial">
                            <i class="fas fa-question-circle"></i>
                            <span>33食用指南</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <!-- 新增的聊天设置项 -->
                        <div class="setting-item" id="setting-chat">
                            <i class="fas fa-comments"></i>
                            <span>聊天设置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-api">
                            <i class="fas fa-server"></i>
                            <span>API 配置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-prompts">
                            <i class="fas fa-magic"></i>
                            <span>自定义提示词</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-theme">
                            <i class="fas fa-palette"></i>
                            <span>主题设置</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="setting-wish-pool">
                            <i class="fas fa-heart"></i>
                            <span>角色许愿池</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="setting-reset">
                            <i class="fas fa-trash-alt"></i>
                            <span>重置应用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- 聊天页面 -->
            <div id="page-chat" class="page">
                <div class="page-header">
                    <div id="chat-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <div class="header-title-wrapper">
                        <h1 class="header-title" id="chat-title"></h1>
                        <div class="typing-indicator-container" id="chat-typing-indicator">
                            <span>对方正在输入...</span>
                        </div>
                    </div>
                    <div id="chat-manage-btn" class="header-icon"><i class="fas fa-ellipsis-v"></i></div> 
                </div>
                <div class="chat-area" id="chat-area">
                    <div id="history-loader"><div class="loader-spinner"></div></div>
                    <!-- 消息气泡将由JS动态生成 -->
                </div>
                <div class="chat-input-area" id="chat-input-area">
                    <!-- 引用预览区域 -->
                    <div class="quote-preview-area" id="quote-preview-area">
                        <div class="quote-preview-content" id="quote-preview-content"></div>
                        <button class="cancel-quote-btn" id="cancel-quote-btn" title="取消引用">×</button>
                    </div>

                    <!-- 输入和发送行 -->
                    <div class="input-top-row">
                        <button id="ai-request-btn"><i class="fas fa-feather-alt"></i></button>
                        <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                        <button id="send-btn"><i class="fas fa-paper-plane"></i></button>
                    </div>

                    <!-- 功能按钮行 -->
                    <div class="input-feature-row-wrapper">
                        <div class="input-feature-row">
                            <button class="feature-btn" id="emoji-btn" title="发送表情"><i class="fas fa-smile"></i></button>
                            <button class="feature-btn" id="favorite-emoji-btn" title="收藏的表情"><i class="fas fa-star"></i></button>
                            <button class="feature-btn" id="voice-btn" title="发送语音"><i class="fas fa-microphone"></i></button>
                            <button class="feature-btn" id="transfer-btn" title="转账"><i class="fas fa-exchange-alt"></i></button>
                            <button class="feature-btn" id="red-packet-btn" title="发红包"><i class="fas fa-wallet"></i></button>
                            <button class="feature-btn" id="simulated-image-btn" title="图文消息"><i class="fas fa-image"></i></button>
                            <button class="feature-btn" id="gift-btn" title="送礼物"><i class="fas fa-gift"></i></button>
                            <button class="feature-btn" id="card-btn" title="发送卡片"><i class="fas fa-share-square"></i></button>
                        </div>
                    </div>
                    <!-- 表情包面板 (默认隐藏) -->
                    <div class="emoji-card" id="emoji-card">
                        <div class="emoji-grid" id="emoji-grid"></div>
                        <div class="emoji-nav">
                            <button id="emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="emoji-page-indicator"></span>
                            <button id="emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                    <!-- 收藏表情包面板 (默认隐藏) -->
                    <div class="emoji-card" id="favorite-emoji-card">
                        <div class="emoji-grid" id="favorite-emoji-grid"></div>
                        <div class="emoji-nav" style="display: none;">
                            <button id="favorite-emoji-prev-btn"><i class="fas fa-chevron-left"></i></button>
                            <span id="favorite-emoji-page-indicator"></span>
                            <button id="favorite-emoji-next-btn"><i class="fas fa-chevron-right"></i></button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 自定义提示词页面 -->
            <div id="page-prompts" class="page">
                <div class="page-header">
                    <div id="prompts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>自定义提示词</h1>
                    <div id="prompt-header-actions" style="display: flex; gap: 15px; justify-self: end; padding-right: 15px;">
                        <div id="import-prompts-btn" class="header-icon" title="导入"><i class="fas fa-download"></i></div>
                        <div id="export-prompts-btn" class="header-icon" title="导出"><i class="fas fa-upload"></i></div>
                        <div id="add-prompt-folder-btn" class="header-icon" title="新建文件夹"><i class="fas fa-folder-plus"></i></div>
                    </div>
                </div>
                <div class="page-content" id="prompts-page-content">
                    <!-- 文件夹和提示词将由JS动态生成 -->
                </div>
                <div class="page-footer" style="padding: 10px; text-align: center; border-top: 1px solid var(--border-color); background: rgba(255,255,255,0.5);">
                    <button id="add-new-prompt-btn" class="modal-btn btn-primary" style="width: 90%;"><i class="fas fa-plus-circle"></i> 新建提示词</button>
                </div>
            </div>

            <!-- 发现页面 -->
            <div id="page-discover" class="page">
                <div class="page-header">
                    <h1>发现</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="nav-to-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>朋友圈</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="nav-to-pomodoro">
                            <i class="fas fa-clock"></i>
                            <span>番茄钟</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 主题设置页面 (新) -->
            <div id="page-theme-settings" class="page">
                <div class="page-header">
                    <div id="theme-settings-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>主题设置</h1>
                </div>
                <div class="page-content" id="theme-settings-content">
                    <!-- 卡片内容将由JS动态生成 -->
                </div>
            </div>

            <!-- 朋友圈页面 -->
            <div id="page-moments" class="page">
                <!-- 新增的包裹层 -->
                <div id="moments-wrapper">
                    <div class="page-header">
                        <div id="moments-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                        <div id="moments-actions-group">
                             <div id="moments-refresh-btn" class="header-icon"><i class="fas fa-sync-alt"></i></div>
                             <div id="moments-new-post-btn" class="header-icon"><i class="fas fa-camera"></i></div>
                             <div id="moments-manage-btn" class="header-icon"><i class="fas fa-bars"></i></div>
                        </div>
                    </div>
                    <div class="page-content">
                        <div class="moments-header-container">
                            <img id="moments-bg" src="https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png" alt="朋友圈背景">
                            <div class="moments-profile-info">
                                <span id="moments-my-name" class="name">你的名字</span>
                                <img id="moments-my-avatar" src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=" alt="你的头像" class="avatar">
                            </div>
                        </div>
                        <ul id="moments-list">
                            <!-- 朋友圈动态将由JS动态生成 -->
                        </ul>
                    </div>
                </div> <!-- 新增的包裹层闭合标签 -->
            </div>
            <!-- 教程页面 (新) -->
            <div id="page-tutorial" class="page">
                <div class="page-header">
                    <div id="tutorial-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>教程</h1>
                </div>
                <div class="page-content">
                    <div class="settings-list">
                        <div class="setting-item" id="tutorial-api">
                            <i class="fas fa-key"></i>
                            <span>如何配置API</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-character">
                            <i class="fas fa-user-plus"></i>
                            <span>如何创建新角色</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-group">
                            <i class="fas fa-users"></i>
                            <span>如何创建群聊</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-chatting">
                            <i class="fas fa-comment-alt"></i>
                            <span>如何进行聊天</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-opening-scene">
                            <i class="fas fa-scroll"></i>
                            <span>开场白是什么？</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-prompts">
                            <i class="fas fa-magic"></i>
                            <span>提示词是什么？</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                         <div class="setting-item" id="tutorial-import-export">
                            <i class="fas fa-exchange-alt"></i>
                            <span>如何导入导出</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-emoji">
                            <i class="fas fa-smile-wink"></i>
                            <span>如何新增/删除表情包</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-persona">
                            <i class="fas fa-user-tag"></i>
                            <span>玩家人设及绑定</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-narrator">
                            <i class="fas fa-theater-masks"></i>
                            <span>旁白如何使用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-moments">
                            <i class="fas fa-camera-retro"></i>
                            <span>朋友圈如何使用</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                        <div class="setting-item" id="tutorial-theme">
                            <i class="fas fa-palette"></i>
                            <span>如何设置主题</span>
                            <i class="fas fa-chevron-right"></i>
                        </div>
                    </div>
                    <div class="tutorial-watermark">
                        <span>此聊天室由33制作，xhs:@回风。</span><br>
                        <span style="font-size: 0.9em; opacity: 0.8;">功能反馈与新功能需求可联系我噢⌯>ᴗo⌯ .ᐟ.ᐟ</span>
                    </div>
                </div>
            </div>
            
            <!-- 番茄钟页面 (新) -->
            <div id="page-pomodoro" class="page">
                <div class="page-header">
                    <div id="pomodoro-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>番茄钟</h1>
                </div>
                <div class="page-content">
                    <div id="pomodoro-timer-display" class="pomodoro-timer-display">25:00</div>
                    <input type="text" id="pomodoro-goal-input" class="pomodoro-goal-input" placeholder="输入本次专注的目标...">
                    <div class="pomodoro-controls">
                        <button id="pomodoro-start-btn" class="pomodoro-btn start">开始专注</button>
                        <button id="pomodoro-stop-btn" class="pomodoro-btn stop" style="display: none;">停止</button>
                    </div>
                </div>
            </div>

            <!-- 送礼物页面 (新) -->
            <div id="page-gifts" class="page">
                <div class="page-header">
                    <div id="gifts-back-btn" class="header-icon"><i class="fas fa-chevron-left"></i></div>
                    <h1>送礼物</h1>
                </div>
                <div class="page-content" id="gifts-page-content">
                    <div class="gifts-search-container">
                        <!-- 第一行：搜索框和刷新 -->
                        <div class="search-row">
                             <div class="search-bar-wrapper">
                                <i class="fas fa-search"></i>
                                <input type="text" id="gift-search-input" placeholder="搜索礼物送给TA...">
                                <button id="gift-search-refresh-btn" style="display: none;"><i class="fas fa-sync-alt"></i></button>
                            </div>
                        </div>
                        <!-- 第二行：功能按钮 -->
                        <div class="action-row">
                             <button id="gift-api-config-btn" class="gift-header-btn action-btn"><i class="fas fa-cog" style="margin-right: 5px;"></i> API配置</button>
                             <button id="custom-gift-btn" class="gift-header-btn action-btn"><i class="fas fa-magic" style="margin-right: 5px;"></i> 自定义</button>
                             <button id="gift-bind-prompt-btn" class="gift-header-btn action-btn"><i class="fas fa-link" style="margin-right: 5px;"></i> 绑定</button>
                             <button id="gift-help-btn" class="gift-header-btn action-btn"><i class="fas fa-question-circle" style="margin-right: 5px;"></i> 帮助</button>
                             <button id="gift-cancel-search-btn" class="gift-header-btn action-btn" style="display:none;"><i class="fas fa-times" style="margin-right: 5px;"></i> 取消搜索</button>
                        </div>
                    </div>
                    <h3 class="gifts-section-title" id="gifts-section-title">大家都在送</h3>
                    <div class="gifts-grid" id="gifts-grid">
                        <!-- 礼物卡片将由JS动态生成 -->
                        <div class="gift-loader" style="display: none;">
                            <div class="loader-spinner"></div>
                            <p>正在努力寻找礼物...</p>
                        </div>
                    </div>
                </div>
            </div>

        </main>

        <!-- 底部导航 -->
        <nav id="bottom-nav">
            <div class="nav-item active" data-page="messages">
                <i class="fas fa-comment-dots"></i>
                <span>消息</span>
            </div>
            <div class="nav-item" data-page="contacts">
                <i class="fas fa-address-book"></i>
                <span>通讯录</span>
            </div>
            <div class="nav-item" data-page="discover">
                <i class="fas fa-compass"></i>
                <span>发现</span>
            </div>
            <div class="nav-item" data-page="settings">
                <i class="fas fa-cog"></i>
                <span>设置</span>
            </div>
        </nav>
    </div>


    <!-- 模态框 -->
    <input type="file" id="font-file-input" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
    <input type="file" id="import-data-input" accept=".json" style="display: none;">
    <div id="modal-overlay">
        <div id="modal-content-wrapper" class="modal-content">
            <!-- 模态框内容将由JS动态生成 -->
        </div>
    </div>
    
    <!-- 点击特效层 -->
    <div id="click-effect-layer"></div>

    <!-- 番茄钟悬浮球 -->
    <div id="pomodoro-float-ball" class="hidden">
        <div class="progress-ring"></div>
        <span class="time-left">25:00</span>
    </div>
    
    <!-- 个人信息侧边栏 -->
    <div id="sidebar-overlay">
        <div id="sidebar-content">
            <!-- 侧边栏内容将由JS动态生成 -->
        </div>
    </div>

    <!-- 底部选择器 -->
    <div id="bottom-sheet-overlay">
        <div id="bottom-sheet-content-wrapper" class="bottom-sheet-content">
             <!-- 内容将由JS动态生成 -->
        </div>
    </div>

    <input type="file" id="moments-bg-input" accept="image/*" style="display: none;">
    <input type="file" id="import-prompts-input" accept=".json" style="display: none;">

<script>
    
    (function() {
        'use strict';

        
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        
        const appContainer = $('#app-container');
        const mainContent = $('#main-content');
        const bottomNav = $('#bottom-nav');
        const modalOverlay = $('#modal-overlay');
        const modalContentWrapper = $('#modal-content-wrapper');
        const clickEffectLayer = $('#click-effect-layer');
        
        
        const pages = {
            messages: $('#page-messages'),
            contacts: $('#page-contacts'),
            discover: $('#page-discover'),
            moments: $('#page-moments'),
            tutorial: $('#page-tutorial'),
            pomodoro: $('#page-pomodoro'),
            gifts: $('#page-gifts'),
            settings: $('#page-settings'),
            'theme-settings': $('#page-theme-settings'), 
            chat: $('#page-chat'),
            prompts: $('#page-prompts'),
        };

        
        const chatTitle = $('#chat-title');
        const chatTypingIndicator = $('#chat-typing-indicator');
        const chatArea = $('#chat-area');
        const aiRequestBtn = $('#ai-request-btn');
        const messageInput = $('#message-input');
        const sendBtn = $('#send-btn');
        const chatBackBtn = $('#chat-back-btn');
        
        const emojiBtn = $('#emoji-btn');
        const voiceBtn = $('#voice-btn');
        const emojiCard = $('#emoji-card');
        const emojiGrid = $('#emoji-grid');
        const quotePreviewArea = $('#quote-preview-area');
        const quotePreviewContent = $('#quote-preview-content');
        const cancelQuoteBtn = $('#cancel-quote-btn');
        const favoriteEmojiBtn = $('#favorite-emoji-btn');
        const favoriteEmojiCard = $('#favorite-emoji-card');
        const favoriteEmojiGrid = $('#favorite-emoji-grid');
        const chatInputArea = $('#chat-input-area');
        
        const BUILTIN_AI_EMOJIS = {
            'iazCCF': '谁在喊本大王','xPHzNC': '尊嘟假嘟','7kVeZJ': '我操','pCQgk2': '老子生气了','IUg8vO': '吃瓜群众','Il6dL9': '对不起','vjEl6R': '花花送你','werDxS': '抱抱我','Ms5AEa': '委屈(可爱)','QX7VnJ': '安慰','nHcfqI': '卖萌(可爱)','oztxES': '比心(可爱)','GOl2dp': '请和我约会','BuD0Gy': '你是狗','jcisbx': '我只是一只狗','Zo82H7': '每天都想你(卖萌)','CcIWXl': '假装无辜(可爱)','zSBHMm': '肯定(可爱)','CIWud3': '谁愿意收留我(可爱)','HOAcPN': '谄媚(可爱)','GP1VJ3': '家里交给我吧(可爱)','BISbnP': '泪了','asnj6B': '试探(可爱)','htNZls': '懂得都懂','2q5VbM': '就你小子是吧(嚣张)','sd0yQX': '放心交给我，我会搞砸的(沙雕)','E0PrxD': '皇帝驾到(沙雕)','7vgm7D': '皇帝驾崩(沙雕)','lPgzpQ': '诛你九族(龙图)','j2d9di': '骂朕，满门抄斩！','hKyKwP': '奴才谢主隆恩(龙图)','IkZP8N': '我饿了','osIpSG': '怎么不回我消息','IgfF9w': '快理我(委屈可爱)','wb63Ag': '等下讲你你又不高兴(吐槽)','8CCMsJ': '我靠，你爱不爱我','34LcOG': '指指点点','hDpVH8': '我吗？(懵逼)','1RcY8W': '注意你的态度','6cIfGp': '急得蹬腿','m1zzxd': '不想活了(沙雕)','YqlPWK': '你和我这个神经病计较什么','LokqQT': '你很牛吗？','qHSXVP': '妈的，被看扁了','CUOA6Y': '令人火大','3jc0XI': '不想活了(可爱)','qZxeWV': '你快哄我(可爱)','3iYdgX': '我被哄好了(可爱)','ZNzgpY': '你就是很好很好(可爱)','PCLA8G': '我好想你吖(委屈可爱)','i0UYTS': '你瞧不起我(委屈)','VWwt5c': '我想要这个(可爱)','SIWqFT': '得意','ff8JWS': '我萎了','oiMaM6': '你精神正常吗','LIQKcy': '想死','EhcgEa': '被看穿了','vnDXiy': '怎么你要打死我吗(犯贱)','71bINa': '你少看扁我(自嘲熊)','gcubY9': 'tui(吐口水)','r1lada': '你太粘人了_把你拿去粘老鼠','y6ldmK': '很不高兴为你服务','yrVneI': '真贱啊','dP6HDY': '你自首吧','jjyR6G': '你是猪','WfSWCe': '你他妈谁啊','B0S4LA': '蒙圈'
        };
        const BUILTIN_PLAYER_EMOJIS = {
            'iazCCF': '谁在喊本大王','xPHzNC': '尊嘟假嘟','7kVeZJ': '我操','pCQgk2': '老子生气了','IUg8vO': '吃瓜群众','Il6dL9': '对不起','vjEl6R': '花花送你','werDxS': '抱抱我','Ms5AEa': '委屈(可爱)','QX7VnJ': '安慰','nHcfqI': '卖萌(可爱)','oztxES': '比心(可爱)','GOl2dp': '请和我约会','BuD0Gy': '你是狗','jcisbx': '我只是一只狗','Zo82H7': '每天都想你(卖萌)','CcIWXl': '假装无辜(可爱)','zSBHMm': '肯定(可爱)','CIWud3': '谁愿意收留我(可爱)','HOAcPN': '谄媚(可爱)','GP1VJ3': '家里交给我吧(可爱)','BISbnP': '泪了','asnj6B': '试探(可爱)','htNZls': '懂得都懂','2q5VbM': '就你小子是吧(嚣张)','sd0yQX': '放心交给我，我会搞砸的(沙雕)','E0PrxD': '皇帝驾到(沙雕)','7vgm7D': '皇帝驾崩(沙雕)','lPgzpQ': '诛你九族(龙图)','j2d9di': '骂朕，满门抄斩！','hKyKwP': '奴才谢主隆恩(龙图)','IkZP8N': '我有点饿了','osIpSG': '怎么不回我消息','Lt1f9K': '特别特别饿','IgfF9w': '快理我(委屈)','wb63Ag': '等下讲你你又不高兴(吐槽)','s9xWmu': '你是个坏东西','8CCMsJ': '我靠，你爱不爱我','34LcOG': '指指点点','hDpVH8': '我吗？(懵逼)','1RcY8W': '注意你的态度','6cIfGp': '急得蹬腿','kRdQhe': '偷听','3jc0XI': '不想活了(可爱)','m1zzxd': '不想活了(沙雕)','YqlPWK': '你和我这个神经病计较什么','LokqQT': '你很牛吗？','4ZkXRx': '他们都欺负我','qZxeWV': '你快哄我','3iYdgX': '我被哄好了(可爱)','qHSXVP': '妈的，被看扁了','278MJW': '不努力就会成为女人的玩物','mzqDku': '我喜欢你(害羞)','dnzCAP': '什么都想和你说','ZNzgpY': '你就是很好很好(可爱)','PCLA8G': '我好想你吖(委屈)','sf7Egt': '我去洗澡啦(可爱)','i0UYTS': '你瞧不起我(委屈)','VWwt5c': '我想要这个','hMTJRH': '和你贴贴','CUOA6Y': '令人火大','Y06FYQ': '我是小孩，让我(可爱)','lFpXLU': '再叫剪了你的小鸡鸡','RaogpF': '没办法人家就是好色嘛','7a48eQ': '你怎么鸡8小小的，说话吊吊的','N3ZzUs': '拿来吧你','oGFqYZ': '出来亲嘴','Z3glHK': '停止思考','9RWtTB': '你人真好，都想和你谈恋爱了','KNRPfQ': '没人爱我(杰瑞猫表情)','bpyimG': '起了杀心','DOwyrR': '给你点了(赞同,抽象)','fd1o0q': '我是国家一级保护废物(猫咪葛优瘫)','0liCnk': '中(肯定的意思)','wTC4Ha': '完力(完了)','n0Ll5b': '无力','SIWqFT': '得意','2up6Um': '嘎嘎大笑','tLsCTf': '不许笑了','ff8JWS': '我萎了','oiMaM6': '你精神正常吗','LIQKcy': '想死','EhcgEa': '被看穿了','vnDXiy': '怎么你要打死我吗(犯贱)','71bINa': '你少看扁我(自嘲熊)','eDzCRs': '疑惑','gcubY9': 'tui(吐口水)','r1lada': '你太粘人了_把你拿去粘老鼠','y6ldmK': '很不高兴为你服务','yrVneI': '真贱啊','dP6HDY': '你自首吧','OFcKsy': '勾引我是吧','jjyR6G': '你是猪','WfSWCe': '你他妈谁啊','ZbqhUq': '已读不回','B0S4LA': '蒙圈','3sp60p': '不做评价(龙图)','VIbUBK': '你是少爷吗','RjmyAc': '下线了兄弟萌(们)','y2w7BR': '一边去(龙图)','fyYVhV': '糟糕的话无需再说(抽象)','PT4fq1': '在干嘛_呼吸也要和我说一声啊','wBBj7q': '老子惹你没','3Yb2hM': '资本你赢了','9K6IPq': '脑子有问题','jHsXmD': '我们不要学他','khoGur': '刚睡醒(自嘲熊)','0svPHM': '想哭(自嘲熊)','39cQOS': '嘻嘻(自嘲熊)','4wZWjY': '尴尬一笑(黄豆)','YaiPfJ': '我超_什么寄吧','mxDIwM': '欺负没力气的我你开心吗','HIRelu': '多找找你自己的原因','RNgGNY': '以后不会和你分享了(委屈)','GWn8O2': '嘬嘬嘬','SwNPaw': '你们好会装逼啊','tDB1Sp': '复婚好吗，孩子总哭','mWU2m4': '你活这么久，和我睡两天怎么了','YCRn9a': '我坏，她好，行了吧','t7vGt6': '当我意识到生活的缩写是SM，我的痛苦就全说得清了','5AaDlW': '本来挺想你的_后来玩手机忘了','a2gifR': '偷偷谈恋爱没事_别偷偷发财好吗','BI9YDr': '荒唐','ScbsVz': '我要报警','yVU6HV': '有趣，草了','WRy68R': '低声些_难道光彩吗','vHBtBv': '偏不睡(抽象表情)','IvfqD7': '装可怜(抽象)','E7e2MS': '够了(抽象)','OWcn1K': '假装懂了','pk06Iq': '你是坏狗(可爱)'
        };
        
        const appState = {
            currentPage: 'messages',
            currentChatId: null,
            currentCircleId: null, 
            momentsLastRefresh: 0, 
            theme: 'neumorphic',
            contactsSortOrder: 'asc',
            groupsSortOrder: 'asc',
            quotingMessage: null,
            longPressTimer: null,
            friendSelectionMode: false,
            groupSelectionMode: false,
            cardCoverLibrary: [
                'https://z.wiki/u/fHMKzJ',
                'https://z.wiki/u/hmSAIR',
                'https://z.wiki/u/YWUcea',
                'https://z.wiki/u/dDuLcP',
                'https://z.wiki/u/JQtgF6',
                'https://z.wiki/u/bVpr6w',
                'https://z.wiki/u/dVvZ7t'
            ],
            emojiCurrentPage: 0,
            emojisPerPage: 8,
            favoriteEmojis: [],
            favoriteEmojiCurrentPage: 0,
            aiEmojiMap: {}, // To be populated
            playerEmojiMap: {}, // To be populated
            customEmojis: {}, // To be populated
            currentChat: {
                allMessages: [],
                renderedCount: 0,
            },
            messagesPerLoad: 20,
            isSummarizing: {},
            isHistoryLoading: false,
            pomodoro: {
                isActive: false,
                goal: '',
                endTime: null,
                timerId: null,
                totalSeconds: 1500, // 25 minutes
            },
        };
        
        const DBHelper = {
            DB_NAME: 'AIChatRoomDB',
            DB_VERSION: 1,
            db: null,

            async init() {
                
                this.DB_VERSION = 18;

                return new Promise((resolve, reject) => {
                    if (this.db) {
                        return resolve(this.db);
                    }
                    const request = indexedDB.open(this.DB_NAME, this.DB_VERSION);

                    request.onerror = (event) => {
                        console.error("数据库打开失败", event);
                        reject("数据库打开失败");
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log("数据库打开成功");
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        console.log("数据库升级中... from version", event.oldVersion, "to", event.newVersion);
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        
                        if (event.oldVersion < 15) {
                            if (!db.objectStoreNames.contains('profile')) {
                                db.createObjectStore('profile', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('contacts')) {
                                const store = db.createObjectStore('contacts', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('groups')) {
                                 const store = db.createObjectStore('groups', { keyPath: 'id' });
                                 store.createIndex('createdAt', 'createdAt', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('chats')) {
                                db.createObjectStore('chats', { keyPath: 'chatId' });
                            }
                            if (!db.objectStoreNames.contains('apiConfig')) {
                                db.createObjectStore('apiConfig', { keyPath: 'id' });
                            }
                            if (!db.objectStoreNames.contains('openingScenes')) {
                                const store = db.createObjectStore('openingScenes', { keyPath: 'id' });
                                store.createIndex('groupId', 'groupId', { unique: false });
                                store.createIndex('contactId', 'contactId', { unique: false }); 
                            }
                            if (!db.objectStoreNames.contains('prompts')) {
                                 const store = db.createObjectStore('prompts', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: false });
                                 store.createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('promptFolders')) {
                                 const store = db.createObjectStore('promptFolders', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('circles')) {
                                 const store = db.createObjectStore('circles', { keyPath: 'id' });
                                 store.createIndex('name', 'name', { unique: true });
                            }
                            if (!db.objectStoreNames.contains('moments')) {
                                 const store = db.createObjectStore('moments', { keyPath: 'id' });
                                 store.createIndex('circleId', 'circleId', { unique: false });
                                 store.createIndex('timestamp', 'timestamp', { unique: false });
                            }
                            if (!db.objectStoreNames.contains('friendFolders')) {
                                const store = db.createObjectStore('friendFolders', { keyPath: 'id' });
                                store.createIndex('name', 'name', { unique: true });
                                store.createIndex('createdAt', 'createdAt', { unique: false });
                            }

                            if (db.objectStoreNames.contains('contacts') && !transaction.objectStore('contacts').indexNames.contains('folderId')) {
                                transaction.objectStore('contacts').createIndex('folderId', 'folderId', { unique: false });
                            }
                            if (db.objectStoreNames.contains('openingScenes') && !transaction.objectStore('openingScenes').indexNames.contains('contactId')) {
                                transaction.objectStore('openingScenes').createIndex('contactId', 'contactId', { unique: false });
                            }
                            
                            // --- 数据迁移的关键部分 ---
                            console.log("开始进行版本15的数据迁移：创建 chatMetadata...");
                            const chatMetadataStore = db.createObjectStore('chatMetadata', { keyPath: 'chatId' });
                            chatMetadataStore.createIndex('lastMessageTimestamp', 'lastMessageTimestamp', { unique: false });
                            // 为置顶功能新增索引
                            chatMetadataStore.createIndex('isPinned', 'isPinned', { unique: false });

                            const chatsStore = transaction.objectStore('chats');
                            chatsStore.openCursor().onsuccess = (e) => {
                                const cursor = e.target.result;
                                if (cursor) {
                                    const chat = cursor.value;
                                    if (chat.history && chat.history.length > 0) {
                                        const displayableHistory = chat.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                        if (displayableHistory.length > 0) {
                                            const lastMessage = displayableHistory[displayableHistory.length - 1];
                                            const unreadCount = chat.history.filter(m => m.isUnread).length;

                                            const metadata = {
                                                chatId: chat.chatId,
                                                lastMessage: lastMessage,
                                                unreadCount: unreadCount,
                                                lastMessageTimestamp: lastMessage.timestamp
                                            };
                                            transaction.objectStore('chatMetadata').put(metadata);
                                        }
                                    }
                                    cursor.continue();
                                } else {
                                    console.log("chatMetadata 迁移完成。");
                                }
                            };
                        }
                        
                        // --- 版本 16 升级：拆分聊天记录 ---
                        if (event.oldVersion < 16) {
                            console.log("数据库升级至版本 16：创建 messages 表...");

                            const messagesStore = db.createObjectStore('messages', { keyPath: 'messageId' });
                            messagesStore.createIndex('by_chat_and_time', ['chatId', 'timestamp'], { unique: false });
                            messagesStore.createIndex('by_chat_and_sender', ['chatId', 'senderId'], { unique: false });

                            // 数据迁移：从旧的 chats.history 迁移到新的 messages 表
                            if (db.objectStoreNames.contains('chats')) {
                                const chatsStore = transaction.objectStore('chats');
                                chatsStore.openCursor().onsuccess = (e) => {
                                    const cursor = e.target.result;
                                    if (cursor) {
                                        const chat = cursor.value;
                                        if (chat.history && chat.history.length > 0) {
                                            // --- 核心修复开始 ---
                                            // 为每个聊天会话重置偏移量，防止不同聊天之间互相影响
                                            let timestampOffset = 0; 
                                            for (const message of chat.history) {
                                                // 确保每条消息都有 chatId
                                                message.chatId = chat.chatId;

                                                // 为可能相同的旧时间戳增加一个微小的、有序的偏移量。
                                                // 这样可以确保即使原始时间戳相同，它们在数据库中的排序也是正确的。
                                                message.timestamp = message.timestamp + (timestampOffset++);

                                                // 写入新的 messages 表
                                                transaction.objectStore('messages').put(message);
                                            }
                                            // --- 核心修复结束 ---
                                        }
                                        cursor.continue();
                                    } else {
                                        console.log("聊天记录迁移到 messages 表完成。");
                                    }
                                };
                            }
                        }

                        // --- 版本 17 升级：新增礼物API配置表 ---
                        if (event.oldVersion < 17) {
                            console.log("数据库升级至版本 17：创建 giftApiConfig 表...");
                            if (!db.objectStoreNames.contains('giftApiConfig')) {
                                db.createObjectStore('giftApiConfig', { keyPath: 'id' });
                            }
                        }
                        
                        console.log("数据库升级完成");
                    };
                });
            },


            async get(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(key);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Get error from ${storeName}: ${e.target.error}`);
                });
            },

            async getAll(storeName, indexName, sortOrder = 'next') {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const index = indexName ? store.index(indexName) : store;
                    const request = index.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`GetAll error from ${storeName}: ${e.target.error}`);
                });
            },

            async put(storeName, item) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(item);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`Put error in ${storeName}: ${e.target.error}`);
                });
            },

            async delete(storeName, key) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(key);
                    request.onsuccess = () => resolve();
                    request.onerror = (e) => reject(`Delete error from ${storeName}: ${e.target.error}`);
                });
            },

            async getMessages(chatId, limit, beforeTimestamp = Date.now()) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, beforeTimestamp], false, true);
                    const messages = [];
                    
                    index.openCursor(range, 'prev').onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor && messages.length < limit) {
                            messages.push(cursor.value);
                            cursor.continue();
                        } else {
                            resolve(messages.reverse()); // 返回按时间正序排列的消息
                        }
                    };
                    transaction.onerror = (e) => reject(`getMessages error: ${e.target.error}`);
                });
            },
            
            async getMessagesBySender(chatId, senderId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_sender');
                    const range = IDBKeyRange.only([chatId, senderId]);
                    const request = index.getAll(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getMessagesBySender error: ${e.target.error}`);
                });
            },
            
            async getChatMessagesCount(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readonly');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);
                    const request = index.count(range);
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (e) => reject(`getChatMessagesCount error: ${e.target.error}`);
                });
            },

            async deleteMessagesForChat(chatId) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['messages'], 'readwrite');
                    const store = transaction.objectStore('messages');
                    const index = store.index('by_chat_and_time');
                    const range = IDBKeyRange.bound([chatId, 0], [chatId, Date.now()]);

                    const request = index.openCursor(range);
                    request.onsuccess = (e) => {
                        const cursor = e.target.result;
                        if (cursor) {
                            cursor.delete();
                            cursor.continue();
                        } else {
                            // Iteration complete
                        }
                    };
                    transaction.oncomplete = () => {
                        console.log(`All messages for chat ${chatId} deleted.`);
                        resolve();
                    };
                    transaction.onerror = (e) => {
                        console.error(`Error deleting messages for chat ${chatId}:`, e.target.error);
                        reject(e.target.error);
                    };
                });
            },
        };

        
        const Utils = {
            generateId(prefix) {
                return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
            },
            
            getRandomColor() {
                const colors = ['#F4E8DD', '#EDD4D8', '#CCD4CC', '#B5BFCF', '#E8A0BF'];
                return colors[Math.floor(Math.random() * colors.length)];
            },
            
            createAvatarDataUrl(color) {
                const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="50" height="50"><rect width="50" height="50" fill="${color}"/></svg>`;
                return `data:image/svg+xml;base64,${btoa(svg)}`;
            },

            formatTimestampSmartly(timestamp) {
                const date = new Date(timestamp);
                const now = new Date();

                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const yesterdayStart = new Date(todayStart);
                yesterdayStart.setDate(yesterdayStart.getDate() - 1);
                
                const formatTime = (d) => d.toLocaleTimeString('zh-CN', { hour: '2-digit', minute: '2-digit' });
                
                if (date >= todayStart) {
                    
                    return formatTime(date);
                } else if (date >= yesterdayStart) {
                    
                    return `昨天 ${formatTime(date)}`;
                } else {
                    
                    return date.toLocaleDateString('zh-CN', { month: '2-digit', day: '2-digit' }) + ' ' + formatTime(date);
                }
            },

            formatTimestampForPrompt(timestamp) {
                const d = new Date(timestamp);
                return `${d.getMonth() + 1}月${d.getDate()}日 ${d.getHours()}:${String(d.getMinutes()).padStart(2, '0')}`;
            },

            compressImage(file, maxWidth = 800, maxHeight = 800, quality = 0.7) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');

                            let width = img.width;
                            let height = img.height;

                            if (width > height) {
                                if (width > maxWidth) {
                                    height = Math.round(height * (maxWidth / width));
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width = Math.round(width * (maxHeight / height));
                                    height = maxHeight;
                                }
                            }

                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);

                            resolve(canvas.toDataURL(file.type, quality));
                        };
                        img.onerror = reject;
                    };
                    reader.onerror = reject;
                });
            },

            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            parseMomentTimestamp(timeStr) { 
                if (!timeStr) return Date.now();
                const now = new Date();
                const year = now.getFullYear();
                const [datePart, timePart] = timeStr.split(' ');
                if (!datePart || !timePart) return Date.now();

                const [month, day] = datePart.split('/');
                const [hour, minute] = timePart.split(':');
                
                
                const parsedDate = new Date(year, parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute));
                
                
                if (parsedDate > now) {
                    parsedDate.setFullYear(year - 1);
                }
                
                return parsedDate.getTime();
            }
        };

        
        const UIManager = {
            notificationQueue: [],
            isDisplayingNotification: false,
       async navigateTo(pageId, fromPage = null) {
            if (!pages[pageId]) return;

            
            if (['chat', 'prompts', 'moments', 'tutorial', 'pomodoro', 'gifts'].includes(pageId)) { 
                bottomNav.style.display = 'none';
            } else {
                bottomNav.style.display = 'flex';
            }

            EventManager.updateFloatingBallVisibility();

            
            $$('#bottom-nav .nav-item').forEach(item => {
                item.classList.toggle('active', item.dataset.page === pageId);
            });

            
            Object.values(pages).forEach(page => page.classList.remove('active'));
            pages[pageId].classList.add('active');
            appState.currentPage = pageId;
            appState.fromPage = fromPage; 
            
            
            switch(pageId) {
                case 'messages': await this.renderMessagesListPage(); break;
                case 'contacts': await this.renderContactsPage(); break;
                case 'discover':  break;
                case 'moments': await this.renderMomentsPage(); break;
                case 'settings': break; 
                case 'gifts': await UIManager.renderGiftsPage(); break;
                case 'theme-settings': await EventManager.renderThemeSettingsPage(); break;
                case 'prompts': await EventManager.renderPromptsPage(); break;
            }
        },

            async renderMessagesListPage() {
                const messageListUl = $('#message-list-ul');
                messageListUl.innerHTML = '';
                
                const allMetadata = await DBHelper.getAll('chatMetadata');
                if (allMetadata.length === 0) {
                    messageListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">还没有消息，快去通讯录找好友聊天吧~</li>`;
                    return;
                }
                
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');
                const contactsMap = contacts.reduce((map, c) => (map[c.id] = c, map), {});
                const groupsMap = groups.reduce((map, g) => (map[g.id] = g, map), {});

                const pinnedChats = [];
                const unpinnedChats = [];

                for (const metadata of allMetadata) {
                    if (!metadata) continue; // 核心修复：如果 metadata 为空，则跳过本次循环
                    
                    const { chatId, lastMessage, unreadCount, isPinned, pinnedTimestamp } = metadata;
                    if (!lastMessage) continue;

                    let chatInfo = {
                        id: chatId,
                        lastMessageContent: lastMessage.content,
                        lastMessageTimestamp: lastMessage.timestamp,
                        unreadCount: unreadCount,
                        isPinned: isPinned || false,
                        pinnedTimestamp: pinnedTimestamp || 0
                    };
                    
                    let entity;
                    let isGroupChat = chatId.startsWith('group-');

                    if (isGroupChat) {
                        entity = groupsMap[chatId];
                    } else {
                        entity = contactsMap[chatId];
                    }

                    if (!entity) continue; 

                    chatInfo.name = entity.remark || entity.name;
                    chatInfo.avatar = entity.avatar;

                    switch (lastMessage.segmentType) {
                        case 'emoji-image':
                            const emojiDesc = appState.playerEmojiMap[lastMessage.content] || appState.aiEmojiMap[lastMessage.content];
                            chatInfo.lastMessageContent = emojiDesc ? `[表情] ${emojiDesc}` : '[未知表情]';
                            break;
                        case 'image_simulated': chatInfo.lastMessageContent = '[图片]'; break;
                        case 'card': chatInfo.lastMessageContent = `[${lastMessage.cardData.shareType || '分享'} ${lastMessage.cardData.title}]`; break;
                        case 'voice': chatInfo.lastMessageContent = '[语音]'; break;
                        case 'transfer': chatInfo.lastMessageContent = '[转账]'; break;
                        case 'transfer-return': chatInfo.lastMessageContent = '[转账已退回]'; break;
                        case 'transfer-receipt': chatInfo.lastMessageContent = '[已收款]'; break;
                        case 'red-packet': chatInfo.lastMessageContent = '[红包]'; break;
                        case 'moment_forward': chatInfo.lastMessageContent = '[转发动态]'; break;
                    }

                    if (lastMessage.isRetracted) {
                        chatInfo.lastMessageContent = '[一条消息被撤回]';
                    }
                    
                    if (isGroupChat && lastMessage.type === 'received' && lastMessage.senderId) {
                        const sender = contactsMap[lastMessage.senderId];
                        if (sender) {
                            chatInfo.lastMessageContent = `${sender.remark || sender.name}: ${chatInfo.lastMessageContent}`;
                        }
                    }
                    
                    if (chatInfo.isPinned) {
                        pinnedChats.push(chatInfo);
                    } else {
                        unpinnedChats.push(chatInfo);
                    }
                }
                
                // 排序：置顶的按置顶时间倒序，其他的按最新消息时间倒序
                pinnedChats.sort((a, b) => b.pinnedTimestamp - a.pinnedTimestamp);
                unpinnedChats.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);
                
                const combinedChats = [...pinnedChats, ...unpinnedChats];

                combinedChats.forEach(chat => {
                    const li = document.createElement('li');
                    li.className = 'message-item';
                    li.dataset.chatId = chat.id;
                    li.innerHTML = `
                        <img src="${chat.avatar}" alt="avatar" class="item-avatar">
                        <div class="item-content">
                            <div class="item-name">
                                ${chat.isPinned ? '<i class="fas fa-thumbtack item-pin-icon"></i>' : ''}
                                ${chat.name}
                            </div>
                            <div class="item-last-msg">${chat.lastMessageContent}</div>
                        </div>
                        <div class="item-info">
                            <div class="item-time">${Utils.formatTimestampSmartly(chat.lastMessageTimestamp)}</div>
                            ${chat.unreadCount > 0 ? `<div class="unread-badge">${chat.unreadCount}</div>` : ''}
                        </div>
                    `;
                    li.addEventListener('click', () => this.openChat(chat.id));
                    messageListUl.appendChild(li);
                });
            },

            showMessageListOptions(itemElement) {
                const existingPopover = $('.message-list-popover');
                if (existingPopover) {
                    existingPopover.remove();
                }

                const chatId = itemElement.dataset.chatId;
                if (!chatId) return;

                const popover = document.createElement('div');
                popover.className = 'message-list-popover';

                (async () => {
                    const metadata = await DBHelper.get('chatMetadata', chatId);
                    const isPinned = metadata?.isPinned || false;
                    const pinButtonText = isPinned ? '取消置顶' : '置顶';
                    const pinIcon = isPinned ? 'fa-arrow-down' : 'fa-thumbtack';

                    popover.innerHTML = `
                        <button class="message-list-popover-btn" data-action="pin"><i class="fas ${pinIcon}"></i> ${pinButtonText}</button>
                        <button class="message-list-popover-btn" data-action="delete"><i class="fas fa-trash-alt"></i> 删除</button>
                    `;

                    
                    const rect = itemElement.getBoundingClientRect();
                    const containerRect = $('#page-messages .page-content').getBoundingClientRect();
                    
                    popover.style.top = `${rect.top - containerRect.top + (rect.height / 2)}px`;
                    popover.style.left = `${rect.left - containerRect.left + (rect.width / 2)}px`;
                    popover.style.transformOrigin = 'center center';
                    popover.style.transform = 'translate(-50%, -50%) scale(0.9)'; 

                    $('#page-messages .page-content').appendChild(popover);

                    // 确保它不会被遮挡
                    requestAnimationFrame(() => {
                        const popoverRect = popover.getBoundingClientRect();
                        if (popoverRect.bottom > containerRect.bottom - 10) {
                            popover.style.top = `${rect.top - containerRect.top - popoverRect.height - 5}px`;
                            popover.style.transformOrigin = 'bottom center';
                        }
                        if (popoverRect.top < containerRect.top + 10) {
                            popover.style.top = `${rect.bottom - containerRect.top + 5}px`;
                            popover.style.transformOrigin = 'top center';
                        }
                    });
                })();

                
                popover.addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;
                    e.stopPropagation();

                    const action = button.dataset.action;
                    popover.remove(); 

                    if (action === 'pin') {
                        const allMetadata = await DBHelper.getAll('chatMetadata');
                        const pinnedCount = allMetadata.filter(m => m.isPinned).length;
                        const metadata = await DBHelper.get('chatMetadata', chatId);
                        
                        if (!metadata.isPinned && pinnedCount >= 5) {
                            UIManager.showToast("最多只能置顶5个聊天");
                            return;
                        }

                        metadata.isPinned = !metadata.isPinned;
                        metadata.pinnedTimestamp = metadata.isPinned ? Date.now() : 0;
                        await DBHelper.put('chatMetadata', metadata);
                        await this.renderMessagesListPage();

                    } else if (action === 'delete') {
                        this.showModal({
                            title: '删除此会话',
                            body: '<p>请选择删除方式：</p>',
                            actions: [
                                { text: '取消', class: 'btn-secondary', handler: () => this.hideModal() },
                                { text: '仅移除列表', class: 'btn-primary', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }},
                                { text: '删除聊天记录', class: 'btn-danger', handler: async () => {
                                    await DBHelper.delete('chatMetadata', chatId);
                                    await DBHelper.deleteMessagesForChat(chatId);

                                    // --- BUG修复：同时清除自动总结 ---
                                    const isGroup = chatId.startsWith('group-');
                                    const storeName = isGroup ? 'groups' : 'contacts';
                                    const entity = await DBHelper.get(storeName, chatId);
                                    if (entity) {
                                        entity.autoSummary = ''; // 清空总结
                                        if (entity.totalPlayerTurns) { // 如果有回合数也重置
                                            entity.totalPlayerTurns = 0;
                                        }
                                        await DBHelper.put(storeName, entity);
                                    }
                                    // --- 修复结束 ---

                                    this.hideModal();
                                    await this.renderMessagesListPage();
                                }}
                            ]
                        });
                    }
                });

                
                const hideOnClickOutside = (event) => {
                    if (!popover.contains(event.target)) {
                        popover.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                setTimeout(() => document.addEventListener('click', hideOnClickOutside, true), 0);
            },

            async renderContactsPage(tab = 'friends') {
                $$('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.tab === tab));
                $$('.contact-section').forEach(sec => {
                    sec.classList.remove('active');
                });

                if (tab === 'friends') {
                    $('#contacts-friends').classList.add('active');
                    const friends = await DBHelper.getAll('contacts');
                    friends.sort((a, b) => {
                        return appState.contactsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#friends-list-ul'), friends, 'contact');
                } else if (tab === 'groups') {
                    $('#contacts-groups').classList.add('active');
                    const groups = await DBHelper.getAll('groups');
                     groups.sort((a, b) => {
                        return appState.groupsSortOrder === 'asc' 
                            ? a.createdAt - b.createdAt 
                            : b.createdAt - a.createdAt;
                    });
                    this.renderContactList($('#groups-list-ul'), groups, 'group');
                } else if (tab === 'friendFolders') {
                    $('#contacts-friend-folders').classList.add('active');
                    await this.renderFriendFoldersPage();
                }
            },

            async updateChatMetadata(chatId, newLastMessage = null, unreadChange = 0) {
                const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
                
                if (newLastMessage) {
                    metadata.lastMessage = newLastMessage;
                    metadata.lastMessageTimestamp = newLastMessage.timestamp;
                }
                
                if (unreadChange > 0) {
                    metadata.unreadCount = (metadata.unreadCount || 0) + unreadChange;
                } else if (unreadChange < 0) { // < 0 means reset to 0
                    metadata.unreadCount = 0;
                }
                
                if (metadata.lastMessage) { // Only save if there's at least one message
                    await DBHelper.put('chatMetadata', metadata);
                }
            },

            
            renderContactList(ulElement, items, type) {
                const isSelectionMode = (type === 'contact' && appState.friendSelectionMode) || (type === 'group' && appState.groupSelectionMode);

                ulElement.classList.toggle('selection-mode', isSelectionMode);
                ulElement.innerHTML = '';

                if (items.length === 0) {
                    ulElement.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">空空如也~</li>`;
                    return;
                }
                items.forEach(item => {
                    const li = document.createElement('li');
                    li.className = 'contact-item';
                    li.dataset.id = item.id;
                    li.innerHTML = `
                        ${isSelectionMode ? '<input type="checkbox" class="contact-select-checkbox">' : ''}
                        <img src="${item.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${type === 'contact' ? (item.remark || item.name) : item.name}</span>
                        ${type === 'contact' 
                            ? `<i class="fas fa-info-circle contact-info-btn" data-id="${item.id}"></i>` 
                            : `<i class="fas fa-ellipsis-h contact-info-btn" data-id="${item.id}"></i>`
                        }
                    `;
                    
                    li.addEventListener('click', (e) => {
                        if (isSelectionMode) {
                            if (e.target.type !== 'checkbox') {
                                const checkbox = li.querySelector('.contact-select-checkbox');
                                if (checkbox) checkbox.checked = !checkbox.checked;
                            }
                            return;
                        }
                        if (e.target.classList.contains('contact-info-btn')) return;
                        this.openChat(item.id);
                    });
                    
                    const infoBtn = li.querySelector('.contact-info-btn');
                    if (infoBtn) {
                        infoBtn.addEventListener('click', (e) => {
                           e.stopPropagation();
                           if (type === 'contact') this.showContactInfo(item.id);
                           else this.showGroupInfo(item.id);
                        });
                    }

                    ulElement.appendChild(li);
                });
            },

        async openChat(chatId) {
            appState.currentChatId = chatId;
            const isGroup = chatId.startsWith('group-');
            let target;
            if (isGroup) {
                target = await DBHelper.get('groups', chatId);
            } else {
                target = await DBHelper.get('contacts', chatId);
            }

            if (!target) {
                this.showModal({
                    title: "错误",
                    body: `<p>找不到该聊天对象，可能已被删除。</p>`,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => this.hideModal() }]
                });
                return;
            }

            chatTitle.textContent = isGroup ? target.name : (target.remark || target.name);

            // --- 优化：标记已读 ---
            const chatData = await DBHelper.get('chats', chatId) || { chatId, history: [], lastAiReplyTimestamp: 0 };
            const metadata = await DBHelper.get('chatMetadata', chatId) || { chatId, unreadCount: 0 };
            
            if (metadata.unreadCount > 0) {
                let madeChanges = false;
                chatData.history.forEach(msg => {
                    if (msg.isUnread) {
                        msg.isUnread = false;
                        madeChanges = true;
                    }
                });
                if (madeChanges) {
                    await DBHelper.put('chats', chatData);
                }
                await this.updateChatMetadata(chatId, null, -1); // -1 signifies reset
            }
            
            if (isGroup) {
                for (const memberId of target.members) {
                    const privateChat = await DBHelper.get('chats', memberId);
                    if (privateChat && privateChat.history) {
                        let privateChatMadeChanges = false;
                        privateChat.history.forEach(msg => {
                            if (msg.isUnread && msg.isPrivateInGroup) {
                                msg.isUnread = false;
                                privateChatMadeChanges = true;
                            }
                        });
                        if (privateChatMadeChanges) {
                            await DBHelper.put('chats', privateChat);
                        }
                    }
                }
            }

            await this.refreshChatView();
            this.navigateTo('chat');
            await UIManager.applyChatBackground(chatId);
            
            // AI主动回复逻辑保持不变
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const intervalHours = (typeof chatSettings.activeReplyInterval === 'number') ? chatSettings.activeReplyInterval : 0;
            const lastAiTimestamp = metadata.lastAiReplyTimestamp || 0;
            const now = Date.now();
            const elapsedHours = (now - lastAiTimestamp) / (1000 * 60 * 60);

            if (intervalHours > 0 && lastAiTimestamp > 0 && elapsedHours >= intervalHours) {
                console.log(`距离上次AI回复已过去 ${elapsedHours.toFixed(2)} 小时，已达到设定的 ${intervalHours} 小时，触发主动回复。`);
                setTimeout(() => AIHandler.handleActiveReplyRequest(lastAiTimestamp), 500);
            }
        },

        async refreshChatView() {
            if (!appState.currentChatId) return;
            
            const totalMessages = await DBHelper.getChatMessagesCount(appState.currentChatId);
            
            appState.currentChat = {
                totalMessages: totalMessages,
                renderedCount: 0,
                oldestMessageTimestamp: Date.now() // 重置时间戳
            };
            
            chatArea.innerHTML = ''; 
            if (totalMessages > 0) {
                const loaderHTML = '<div id="history-loader"><div class="loader-spinner"></div></div>';
                chatArea.insertAdjacentHTML('beforeend', loaderHTML);
            }

            await this.loadMoreMessages(true);
        },

        async loadMoreMessages(isInitialLoad = false) {
            if (appState.isHistoryLoading) return;

            const { totalMessages, renderedCount, oldestMessageTimestamp } = appState.currentChat;
            const loader = $('#history-loader');

            if (renderedCount >= totalMessages) {
                if(loader) loader.remove();
                return;
            }

            appState.isHistoryLoading = true;
            if (loader) loader.classList.add('visible');
            
            const messagesToLoad = await DBHelper.getMessages(appState.currentChatId, appState.messagesPerLoad, oldestMessageTimestamp);
            
            if (messagesToLoad.length === 0) {
                if (loader) loader.remove();
                appState.isHistoryLoading = false;
                return;
            }

            appState.currentChat.oldestMessageTimestamp = messagesToLoad[0].timestamp;
            
            const fragment = document.createDocumentFragment();
            const profile = await EventManager.getPlayerProfileForContext(appState.currentChatId);
            const contacts = await DBHelper.getAll('contacts');

            // 关键修改：获取本批次消息之后的第一条消息时间，用于时间戳比较
            const nextMessageArr = (chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice')?.id) 
                ? [await DBHelper.get('messages', chatArea.querySelector('.message-row, .system-notice, .narrator-notice, .retracted-notice').id)] 
                : [];
            let nextMessageTimestamp = nextMessageArr.length > 0 ? nextMessageArr[0].timestamp : Date.now() + 1000;

            for (let i = messagesToLoad.length - 1; i >= 0; i--) {
                const msg = messagesToLoad[i];
                
                // 时间戳分隔符逻辑 (修复：首次加载时不显示顶部的多余时间)
                if (nextMessageTimestamp - msg.timestamp > 5 * 60 * 1000 && !isInitialLoad) {
                    const timeDiv = this.createTimeDividerElement(nextMessageTimestamp);
                    fragment.prepend(timeDiv); // 注意是 prepend
                }
                
                if (!(['inner_voice', 'essay'].includes(msg.segmentType) || msg.isHidden)) {
                    let senderInfo = (msg.type === 'sent') ? profile : contacts.find(c => c.id === msg.senderId) || { name: '未知成员', avatar: Utils.createAvatarDataUrl('#ccc') };
                    
                    // --- 新增逻辑开始 ---
                    // 检查表情包设置
                    if (msg.segmentType === 'emoji-image' && msg.type === 'received') {
                        const emojiSetting = senderInfo.allowEmoji;
                        if (emojiSetting === 'off') {
                            nextMessageTimestamp = msg.timestamp; // 即使不显示，也要更新时间戳以正确显示时间分隔符
                            continue; // 跳过此表情消息
                        } else if (emojiSetting === 'prob') {
                            if (Math.random() < 0.5) {
                                nextMessageTimestamp = msg.timestamp;
                                continue; // 50%概率跳过
                            }
                        }
                    }

                    // 检查撤回设置
                    if (msg.isRetracted && msg.type === 'received' && senderInfo.allowRetraction === false) {
                        msg.isRetracted = false; // 强制显示为普通消息
                    }
                    // --- 新增逻辑结束 ---

                    let messageElement;

                    if (msg.isRetracted) {
                        messageElement = this.createRetractionNotice(msg, senderInfo);
                    } else if (msg.segmentType === 'system') {
                        messageElement = document.createElement('div');
                        messageElement.className = 'system-notice';
                        messageElement.id = msg.messageId; // 确保有ID
                        messageElement.textContent = msg.content;
                    } else if (msg.segmentType === 'narrator') {
                        messageElement = await this.createNarratorNoticeElement(msg);
                    } else {
                        messageElement = await this.createMessageElement(msg, senderInfo);
                    }
                    fragment.prepend(messageElement); // 注意是 prepend
                }

                nextMessageTimestamp = msg.timestamp; // 更新时间戳为当前消息的时间
            }

            const oldScrollHeight = chatArea.scrollHeight;
            if (loader) loader.after(fragment);
            else chatArea.prepend(fragment);
            
            if (isInitialLoad) {
                setTimeout(() => chatArea.scrollTop = chatArea.scrollHeight, 10);
            } else {
                chatArea.scrollTop = chatArea.scrollHeight - oldScrollHeight;
            }

            appState.currentChat.renderedCount += messagesToLoad.length;
            if (loader) loader.classList.remove('visible');
            appState.isHistoryLoading = false;
            
            if (appState.currentChat.renderedCount >= totalMessages) {
                if (loader) loader.remove();
            }
        },

        async createMessageElement(msg, senderInfo, isTyping = false, isAnimating = false) {
            const messageRow = document.createElement('div');
            messageRow.className = `message-row ${msg.type}`;
            
            if (!isTyping) {
                messageRow.id = msg.messageId;
                messageRow.dataset.messageId = msg.messageId;
            }

            let bubbleContent = '';
            let bubbleClass = 'bubble';
            let detailContent = ''; 
            
            
            if (msg.isAutoReply) {
                bubbleClass += ' auto-reply-bubble';
            }

            if (isTyping) {
                bubbleClass += ` bubble-typing`;
                bubbleContent = `<div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div>`;
            } else {
                 switch(msg.segmentType) {
                    case 'emoji-image':
                        bubbleClass += ` bubble-emoji`;
                        let emojiSrc;
                        if (msg.content.startsWith('custom-')) {
                            emojiSrc = appState.customEmojis[msg.content]?.url || '';
                        } else {
                            emojiSrc = `https://z.wiki/u/${msg.content}`;
                        }
                        bubbleContent = `<img src="${emojiSrc}" alt="${appState.playerEmojiMap[msg.content] || '表情'}">`;
                        break;
                    case 'image_simulated':
                        bubbleClass += ' image-with-desc-bubble';
                        bubbleContent = `
                            ${msg.cardData.imageSrc ? `<img src="${msg.cardData.imageSrc}" alt="图片">` : ''}
                            <div class="description-text">${msg.cardData.description}</div>
                        `;
                        break;
                    case 'voice':
                        bubbleClass += ' voice-message-bubble';
                        bubbleContent = `<span class="voice-duration">${msg.cardData.duration}</span><div class="voice-wave"><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div><div class="voice-wave-bar"></div></div>`;
                        detailContent = `<div class="voice-transcript">${msg.cardData.content}</div>`;
                        break;
                    case 'quote':
                        bubbleClass += ' quote-message-bubble';
                        bubbleContent = `<div class="quote-block"><span class="quoted-name">${msg.cardData.quotedName}:</span><span>${msg.cardData.quotedContent}</span></div><div>${msg.cardData.newContent}</div>`;
                        break;
                    case 'transfer':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimed) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-exchange-alt transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>转账给 ${msg.cardData.recipientName}</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    ${msg.cardData.note ? `<div class="transfer-footer-v3">${msg.cardData.note}</div>` : ''}
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-return':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const transferCoverStyle = themeSettings.transferCover ? `background-image: url(${themeSettings.transferCover}); background-size: cover; background-position: center;` : '';
                            const recipientIsPlayer = msg.cardData.recipientName === (await EventManager.getPlayerProfileForContext(appState.currentChatId))?.name;
                            const footerText = recipientIsPlayer ? `已退还给 ${msg.cardData.recipientName}` : `${msg.cardData.senderName} 退还了转账`;
                            
                            bubbleContent = `
                                <div class="transfer-content-v3" style="${transferCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-undo transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>转账已退回</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'transfer-receipt':
                        bubbleClass += ' transfer-or-red-packet-bubble claimed'; 
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const receiptCoverStyle = themeSettings.receiptCover ? `background-image: url(${themeSettings.receiptCover}); background-size: cover; background-position: center;` : '';
                            const footerText = msg.type === 'sent' ? `来自 ${msg.cardData.senderName} 的转账` : `${msg.cardData.recipientName} 已收款`;

                            bubbleContent = `
                                 <div class="transfer-content-v3" style="${receiptCoverStyle}">
                                    <div class="transfer-header-v3">
                                        <i class="fas fa-check-circle transfer-icon-v3"></i>
                                        <div class="transfer-info-v3">
                                            <h4>已收款</h4>
                                            <p>${msg.cardData.amount}</p>
                                        </div>
                                    </div>
                                    <div class="transfer-footer-v3">${footerText}</div>
                                </div>
                            `;
                        }
                        break;
                    case 'red-packet':
                        bubbleClass += ' transfer-or-red-packet-bubble';
                        if (msg.cardData.isClaimedByPlayer) bubbleClass += ' claimed';
                        {
                            const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            const defaultCover = 'https://z.wiki/u/IDzEvp';
                            const rpCover = themeSettings.redPacketCover || defaultCover;
                            
                            bubbleContent = `
                                <div class="red-packet-v3-wrapper">
                                    <div class="rp-cover-v3" style="background-image: url('${rpCover}');">
                                        <h4 class="rp-title-v3">${msg.cardData.title}</h4>
                                        <div class="open-button-v3">
                                            <i class="fas fa-paw"></i>
                                        </div>
                                    </div>
                                    <div class="claimed-overlay-v3">已领取</div>
                                </div>
                            `;
                        }
                        break;
                    case 'card':
                        bubbleClass += ' card-bubble';
                        const cardId = `card-detail-${msg.messageId}`;
                        let cardInnerHtml = '';
                        
                        if (msg.type === 'sent') {
                            const cardData = msg.cardData;
                            switch(cardData.shareType) {
                                case '地点分享': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`; break;
                                case '文件分享': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${cardData.title}</h4><div class="file-size">${cardData.summary}</div></div></div>`; break;
                                default:
                                    const imageToUse = cardData.imageSrc || appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${imageToUse}" class="card-image" alt="Card image"><div class="card-content"><h4>${cardData.title}</h4><p>${cardData.summary}</p></div></div>`;
                                    break;
                            }
                        } else {
                             switch(msg.cardData.shareType) {
                                case '地点分享': cardInnerHtml = `<div class="card-message-wrapper card-type-3" data-card-id="${cardId}"><div class="card-icon-area" style="background-color: var(--theme-color-1);"><i class="fas fa-map-marker-alt"></i></div><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`; break;
                                case '文件分享': cardInnerHtml = `<div class="card-message-wrapper card-type-9" data-card-id="${cardId}"><i class="fas fa-file-archive file-icon" style="color: var(--theme-color-4);"></i><div class="file-info"><h4>${msg.cardData.title}</h4><div class="file-size">${msg.cardData.summary}</div></div></div>`; break;
                                default:
                                    const randomCover = appState.cardCoverLibrary[Math.floor(Math.random() * appState.cardCoverLibrary.length)];
                                    cardInnerHtml = `<div class="card-message-wrapper card-type-2" data-card-id="${cardId}"><img src="${randomCover}" class="card-image" alt="Card image"><div class="card-content"><h4>${msg.cardData.title}</h4><p>${msg.cardData.summary}</p></div></div>`;
                                    break;
                            }
                        }
                        
                        const cardDetailHtml = `<div class="card-detail-content" id="${cardId}"><h5>${msg.cardData.title}</h5><p>${msg.cardData.details}</p></div>`;
                        
                        bubbleContent = cardInnerHtml + cardDetailHtml;
                        detailContent = ''; 
                        break;
                    case 'moment_forward':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-moment-id="${msg.cardData.momentId}">
                                <h4 class="card-title">[朋友圈动态]</h4>
                                <p class="card-preview">${msg.cardData.authorName}：${msg.cardData.preview}</p>
                                <div class="card-footer">朋友圈</div>
                            </div>
                        `;
                        break;
                    case 'forward_custom':
                        bubbleClass += ' forwarded-moment-bubble';
                        bubbleContent = `
                            <div class="forwarded-moment-card-content" data-type="custom-forward">
                                <h4 class="card-title">[转发] ${msg.cardData.title}</h4>
                                <p class="card-preview">${msg.cardData.content}</p>
                                <div class="card-footer">转发</div>
                            </div>
                        `;
                        break;
                    case 'gift':
                        bubbleClass += ' gift-bubble';
                        bubbleContent = `
                            <div class="gift-message-content">
                                <img src="${msg.cardData.image}" class="gift-image" alt="礼物">
                                <div class="gift-info">
                                    <div class="gift-name">${msg.cardData.name}</div>
                                    <p class="gift-message">${msg.cardData.message}</p>
                                    <div class="gift-price">￥${msg.cardData.price}</div>
                                </div>
                            </div>
                        `;
                        break;
                    case 'text':
                    default:
                        bubbleContent = msg.content;
                        break;
                }
            }
            
            bubbleClass += ` ${msg.type}`;
            const avatarSrc = (isTyping && msg.isGroupTyping) ? senderInfo.avatar : (senderInfo.avatar || Utils.createAvatarDataUrl('#ccc'));
            const avatarClass = `message-avatar ${isTyping && msg.isGroupTyping ? 'group-avatar-style' : ''}`;
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            const isGroup = appState.currentChatId.startsWith('group-');
            const isMyMessage = msg.type === 'sent';
            let displayNameHtml = '';
            
            
            let timestampHtml = '';
            if (msg.isAutoReply && msg.displayTimestamp) {
                timestampHtml = `<div class="message-timestamp">${msg.displayTimestamp}<span class="auto-reply-tag">未读</span></div>`;
            }

            if (!isTyping && !['transfer-receipt'].includes(msg.segmentType)) {
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
                const nameColorStyle = chatEntity?.nameColor ? `style="color: ${chatEntity.nameColor};"` : '';

                if (isGroup) {
                    if (!isMyMessage) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.remark || senderInfo.name}</div>`;
                    else if (chatSettings.showMyNameInGroup) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${senderInfo.name}</div>`;
                } else {
                    if (chatSettings.showNamesInPrivate) displayNameHtml = `<div class="message-name" ${nameColorStyle}>${isMyMessage ? senderInfo.name : (senderInfo.remark || senderInfo.name)}</div>`;
                }
            }
            
            messageRow.innerHTML = `<img src="${avatarSrc}" alt="avatar" class="${avatarClass}"><div class="message-content">${displayNameHtml}<div class="bubble-and-tag-wrapper"><div class="${bubbleClass}">${bubbleContent}</div>${detailContent}${timestampHtml}</div></div>`;

            const avatarEl = messageRow.querySelector('.message-avatar');
            if (!isTyping) {
                avatarEl.style.cursor = 'pointer';
                if (msg.type === 'received') {
                    avatarEl.addEventListener('click', () => this.showPersonaModal(msg.senderId));
                } else if (msg.type === 'sent') {
                    avatarEl.addEventListener('click', () => AIHandler.handleRegenerateRequest(msg.messageId));
                }
            }
            return messageRow;
        },

        async addMessageToDOM(msg, senderInfo, isTyping = false, isAnimating = false) {
            if (msg.isHidden) return;
            
            let messageElement;
            if (msg.segmentType === 'system') {
                messageElement = document.createElement('div');
                messageElement.className = 'system-notice';
                messageElement.id = msg.messageId;
                messageElement.textContent = msg.content;
            } else if (msg.segmentType === 'narrator') {
                messageElement = await this.createNarratorNoticeElement(msg);
            } else {
                messageElement = await this.createMessageElement(msg, senderInfo, isTyping, isAnimating);
            }
            
            if (isTyping && msg.messageId) {
                messageElement.id = msg.messageId;
            }

            chatArea.appendChild(messageElement);
            
            if(!isTyping) {
                appState.currentChat.totalMessages++;
                appState.currentChat.renderedCount++;
            }
            chatArea.scrollTop = chatArea.scrollHeight;
        },
        
        createTimeDividerElement(timestamp) {
            const timeDiv = document.createElement('div');
            timeDiv.className = 'time-divider';
            timeDiv.textContent = Utils.formatTimestampSmartly(timestamp);
            return timeDiv;
        },

        async createNarratorNoticeElement(msg) {
            const notice = document.createElement('div');
            notice.id = msg.messageId;

            const isGroup = appState.currentChatId.startsWith('group-');
            const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
            const narratorStyle = entity?.narratorStyle || 'grey'; // 默认使用灰色样式

            notice.className = `narrator-notice narrator-style-${narratorStyle}`;
            notice.textContent = msg.content;
            return notice;
        },
        
            createRetractionNotice(msg, senderInfo) {
                const notice = document.createElement('div');
                notice.className = 'retracted-notice';
                notice.id = msg.messageId; // 关键修复：为撤回提示添加ID
                const isGroup = appState.currentChatId.startsWith('group-');
                const senderName = msg.type === 'sent' ? '你' : (senderInfo.remark || senderInfo.name);
                notice.textContent = `${senderName} 撤回了一条消息`;
                
                notice.addEventListener('click', () => {
                    let retractedContentHtml = '';
                    if (msg.segmentType === 'emoji-image') {
                        retractedContentHtml = `<img src="https://z.wiki/u/${msg.content}" style="max-width: 150px; display: block; margin: 10px auto;">`;
                    } else {
                        retractedContentHtml = `<p style="line-height: 1.6;">${msg.content}</p>`;
                    }
                    this.showModal({
                        title: "被撤回的消息",
                        body: retractedContentHtml,
                        actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });
                return notice;
            },

            async renderGiftsPage() {
                const giftsGrid = $('#gifts-grid');
                $('#gifts-section-title').textContent = '大家都在送';
                giftsGrid.innerHTML = ''; // 清空

                const PREDEFINED_GIFTS = [
                    { name: '玫瑰花束', price: 128.00, image: 'https://z.wiki/u/OZbNtm', message: '送你一束玫瑰，愿你天天开心。' },
                    { name: '巧克力礼盒', price: 88.00, image: 'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png', message: '甜甜的巧克力，给甜甜的你。' },
                    { name: '游戏机', price: 2199.00, image: 'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png', message: '一起玩游戏吧！' },
                    { name: '手作蛋糕', price: 68.00, image: 'https://z.wiki/u/18hMdP', message: '亲手为你做的，尝尝看？' },
                    { name: '可爱猫咪', price: 0, image: 'https://z.wiki/u/RSvBmf', message: '路边捡的，给你养了。' },
                    { name: '奶茶一杯', price: 18.00, image: 'https://z.wiki/u/XIexsP', message: '天冷了，喝杯热奶茶吧。' }
                ];
                
                PREDEFINED_GIFTS.forEach(gift => {
                    const card = EventManager.createGiftCard(gift);
                    card.onclick = () => EventManager.showSendGiftModal(gift);
                    giftsGrid.appendChild(card);
                });
            },

            async showPersonaModal(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const personaMessages = await DBHelper.getMessagesBySender(appState.currentChatId, contactId);
                const relevantMessages = personaMessages.filter(m => m.segmentType === 'inner_voice' || m.segmentType === 'essay');
                
                const lastInnerVoice = relevantMessages.filter(m => m.segmentType === 'inner_voice').pop();
                const lastEssay = relevantMessages.filter(m => m.segmentType === 'essay').pop();

                let bodyHtml = `
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 20px;">
                        <img src="${contact.avatar}" style="width: 70px; height: 70px; border-radius: 12px; object-fit: cover;">
                        <div>
                            <h3 style="font-size: 1.4rem; margin-bottom: 5px;">${contact.remark || contact.name}</h3>
                            <p style="color: #888;">ID: ${contact.name}</p>
                        </div>
                    </div>
                `;

                if (lastInnerVoice) {
                    bodyHtml += `<div class="persona-modal-card"><h4>心声</h4><p>${lastInnerVoice.content}</p></div>`;
                }

                if (lastEssay) {
                     bodyHtml += `<div class="persona-modal-card note-paper"><h4>随笔</h4><p>${lastEssay.content}</p></div>`;
                }

                this.showModal({
                    title: "角色洞察",
                    body: bodyHtml,
                    actions: [
                        { text: '进入聊天', class: 'btn-primary', handler: () => {
                            this.hideModal();
                            this.openChat(contactId); 
                        }}
                    ]
                });
            },

            async showModal(config) {
                
                if (appState.theme === 'neumorphic' && !config.customClass) {
                    modalContentWrapper.classList.add('modal-neumorphic');
                } else if (config.customClass) {
                    modalContentWrapper.classList.add(config.customClass);
                }

                
                if (config.isPersistent) {
                    modalOverlay.classList.add('no-overlay-close');
                } else {
                    modalOverlay.classList.remove('no-overlay-close');
                }
                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }

                modalContentWrapper.innerHTML = `
                    <h2 class="modal-header">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                if (config.actions) {
                    
                    $$('#modal-content-wrapper .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                modalOverlay.classList.add('visible');
            },

            hideModal() {
                modalOverlay.classList.remove('visible');
                
                modalContentWrapper.className = 'modal-content';
                modalContentWrapper.innerHTML = '';
            },
            
            showBottomSheet(config) {
                const sheetOverlay = $('#bottom-sheet-overlay');
                const sheetContent = $('#bottom-sheet-content-wrapper');

                sheetContent.className = 'bottom-sheet-content';

                sheetContent.innerHTML = `
                    <div class="bottom-sheet-header">${config.title}</div>
                    <div class="bottom-sheet-body">
                        ${config.items.map(item => `<div class="bottom-sheet-item" data-value="${item.value}">${item.text}</div>`).join('')}
                    </div>
                `;

                if (appState.theme === 'neumorphic') sheetContent.classList.add('neumorphic');
                if (config.customClass) sheetContent.classList.add(...config.customClass.split(' '));
                
                $$('.bottom-sheet-item').forEach(item => {
                    item.addEventListener('click', () => {
                        config.onSelect(item.dataset.value, item.textContent);
                        this.hideBottomSheet();
                    });
                });

                
                sheetOverlay.style.visibility = 'visible';
                requestAnimationFrame(() => {
                    sheetOverlay.classList.add('visible');
                });
            },

            hideBottomSheet() {
                const sheetOverlay = $('#bottom-sheet-overlay');
                sheetOverlay.classList.remove('visible');
                
                setTimeout(() => {
                    sheetOverlay.style.visibility = 'hidden';
                }, 300); 
            },

            showSidebar(config) {
                const sidebarContent = $('#sidebar-content');
                const sidebarOverlay = $('#sidebar-overlay');

                
                sidebarContent.className = 'sidebar-content';

                
                if (appState.theme === 'neumorphic') {
                    sidebarContent.classList.add('neumorphic');
                }

                
                if (config.position === 'left') {
                    sidebarContent.classList.add('sidebar-from-left');
                } else {
                    sidebarContent.classList.remove('sidebar-from-left');
                }

                
                let actionsHtml = '';
                if (config.actions) {
                    actionsHtml = `<div class="modal-actions" style="margin-top: 30px;">` + config.actions.map((action, index) =>
                        `<button class="modal-btn ${action.class}" data-action-index="${index}">${action.text}</button>`
                    ).join('') + `</div>`;
                }
                sidebarContent.innerHTML = `
                    <h2 class="modal-header" style="text-align: left; padding-left: 0;">${config.title}</h2>
                    <div class="modal-body">${config.body}</div>
                    ${actionsHtml}
                `;

                
                if (config.actions) {
                    $$('#sidebar-content .modal-actions .modal-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const index = parseInt(btn.dataset.actionIndex, 10);
                            if (config.actions[index] && typeof config.actions[index].handler === 'function') {
                                config.actions[index].handler();
                            }
                        });
                    });
                }
                
                
                sidebarOverlay.classList.add('visible');
            },

            hideSidebar() {
                const sidebarOverlay = $('#sidebar-overlay');
                const sidebarContent = $('#sidebar-content');
                
                sidebarOverlay.classList.remove('visible');
                
                
                setTimeout(() => {
                    sidebarContent.classList.remove('sidebar-from-left');
                }, 400); 
            },

            showToast(message, duration = 1000) {
                
                const existingToast = $('#toast-notification');
                if (existingToast) {
                    existingToast.remove();
                }

                const toast = document.createElement('div');
                toast.id = 'toast-notification';
                toast.className = 'toast-notification';
                toast.textContent = message;

                
                document.body.appendChild(toast);

                
                setTimeout(() => {
                    
                    toast.classList.add('hiding');
                    
                    setTimeout(() => {
                        if (toast.parentNode) {
                            toast.parentNode.removeChild(toast);
                        }
                    }, 300); 
                }, duration);
            },

            showTopNotification(msg) {
                this.notificationQueue.push(msg);
                this.processNotificationQueue();
            },

            showEssayNotification(authorName, contactId) {
                
                if ($('.essay-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'essay-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-heart"></i>
                    </div>
                    <span class="text-content">${authorName} 更新了随笔</span>
                `;

                
                banner.addEventListener('click', () => {
                    this.showPersonaModal(contactId);
                    hideAndRemove();
                });

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                
                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                
                setTimeout(hideAndRemove, 4000);
            },

            showPomodoroEndNotification(goal) {
                if ($('.pomodoro-notification-banner')) return;

                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'pomodoro-notification-banner';
                banner.innerHTML = `
                    <div class="icon-wrapper">
                        <i class="fas fa-clock"></i>
                    </div>
                    <span class="text-content">${goal} 已结束</span>
                `;

                const hideAndRemove = () => {
                    if (container.contains(banner)) {
                         banner.style.animation = 'notification-exit 0.5s forwards';
                         setTimeout(() => {
                            if (container.contains(banner)) container.removeChild(banner);
                         }, 500);
                    }
                };
                
                container.appendChild(banner);

                setTimeout(() => {
                    banner.classList.add('is-playing');
                }, 10);

                setTimeout(hideAndRemove, 4000);
            },

            renderPomodoroPage() {
                const { isActive, goal } = appState.pomodoro;
                const timerDisplay = $('#pomodoro-timer-display');
                const goalInput = $('#pomodoro-goal-input');
                const startBtn = $('#pomodoro-start-btn');
                const stopBtn = $('#pomodoro-stop-btn');

                if (isActive) {
                    goalInput.value = goal;
                    goalInput.disabled = true;
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'inline-block';
                } else {
                    timerDisplay.textContent = '25:00';
                    goalInput.value = '';
                    goalInput.disabled = false;
                    startBtn.style.display = 'inline-block';
                    stopBtn.style.display = 'none';
                }
            },

            async processNotificationQueue() {
                if (this.isDisplayingNotification || this.notificationQueue.length === 0) {
                    return;
                }
                this.isDisplayingNotification = true;

                const msg = this.notificationQueue.shift();
                const container = $('#top-notification-container');
                const banner = document.createElement('div');
                banner.className = 'notification-banner';

                let messageContent = msg.content;
                if (msg.segmentType === 'emoji-image') messageContent = '[表情包]';
                else if (msg.segmentType === 'voice') messageContent = msg.cardData.content;
                else if (msg.isRetracted) messageContent = '撤回了一条消息';
                
                let notificationAvatar, notificationName, clickTargetId;
                const isGroup = msg.chatId && msg.chatId.startsWith('group-');
                clickTargetId = msg.chatId;

                if (isGroup) {
                    const group = await DBHelper.get('groups', msg.chatId);
                    if (group) {
                        notificationAvatar = group.avatar;
                        notificationName = group.name;
                        const senderName = msg.senderInfo.remark || msg.senderInfo.name;
                        messageContent = `${senderName}：${messageContent}`;
                    } else { // Fallback if group not found
                        notificationAvatar = msg.senderInfo.avatar;
                        notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                    }
                } else {
                    notificationAvatar = msg.senderInfo.avatar;
                    notificationName = msg.senderInfo.remark || msg.senderInfo.name;
                }

                banner.innerHTML = `
                    <img src="${notificationAvatar}" alt="avatar" class="notification-avatar">
                    <div class="notification-content">
                        <div class="notification-header">
                            <span class="notification-name">${notificationName}</span>
                            <span class="notification-time">${Utils.formatTimestampSmartly(msg.timestamp)}</span>
                        </div>
                        <p class="notification-message">${messageContent}</p>
                    </div>
                `;

                const hideAndProcessNext = () => {
                    if (!container.contains(banner)) return;
                    clearTimeout(autoHideTimeout);
                    banner.style.animation = 'notification-exit 0.5s forwards';
                    setTimeout(() => {
                        if (container.contains(banner)) container.removeChild(banner);
                        this.isDisplayingNotification = false;
                        setTimeout(() => this.processNotificationQueue(), 200);
                    }, 500);
                };
                
                const displayDuration = this.notificationQueue.length > 0 ? 1000 : 5000;
                const autoHideTimeout = setTimeout(hideAndProcessNext, displayDuration);

                banner.addEventListener('click', () => {
                    this.openChat(clickTargetId);
                    hideAndProcessNext();
                });

                container.appendChild(banner);
            },

            async showContactInfo(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${contact.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${contact.remark || contact.name}</div>
                                <div class="id">ID: ${contact.name}</div>
                            </div>
                        </div>
                         <div class="details-field"><span class="label">性别</span><span class="value">${contact.gender}</span></div>
                    </div>
                    <div class="details-card">
                       ${contact.likes ? `<div class="details-field"><span class="label">喜好</span><span class="value">${contact.likes}</span></div>` : ''}
                       ${contact.dislikes ? `<div class="details-field"><span class="label">厌恶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                       ${contact.habits ? `<div class="details-field"><span class="label">习惯</span><span class="value">${contact.habits}</span></div>` : ''}
                       ${contact.background ? `<div class="details-section">
                            <div class="details-section-title">背景资料</div>
                            <p>${contact.background}</p>
                        </div>` : ''}
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">发消息</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">导出角色</button>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                             <button class="details-btn" data-action="edit" style="flex: 1;">编辑</button>
                             <button class="details-btn btn-details-danger" data-action="delete" style="flex: 1;">删除好友</button>
                        </div>
                    </div>
                `;

                this.showModal({
                    
                    title: `
                        <span style="flex-grow: 1;">详细资料</span>
                        ${contact.author ? `<div class="details-header-attribution" data-action="show-attribution" title="查看作者信息" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: [] 
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';
                
                
                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(contactId);
                });
                modalContentWrapper.querySelector('[data-action="edit"]').addEventListener('click', () => {
                    this.hideModal();
                    
                    EventManager.showEditFriendModal(contactId, async () => {
                        await UIManager.renderContactsPage('friends');
                    });
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contactId));
                    this.confirmDeleteContact(contactId, isInGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportContact(contactId));
                
                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(contact));
                }
            },
            
            async showGroupInfo(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (!group) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                let creatorName = '未知';
                if (group.creatorId === myProfile.id) {
                    creatorName = `我 (${myProfile.name})`;
                } else {
                    const creatorContact = allContacts.find(c => c.id === group.creatorId);
                    if (creatorContact) creatorName = creatorContact.remark || creatorContact.name;
                }
                
                const membersDetails = group.members
                    .map(memberId => allContacts.find(c => c.id === memberId))
                    .filter(Boolean);

                const membersHtml = membersDetails.map(member => `
                    <div class="member-item">
                        <img src="${member.avatar}" class="avatar" alt="${member.name}">
                        <span class="name">${member.remark || member.name}</span>
                    </div>
                `).join('');

                const isMyGroup = group.creatorId === myProfile.id;

                const bodyHtml = `
                    <div class="details-card">
                        <div class="details-header">
                            <img src="${group.avatar}" class="avatar">
                            <div class="details-info">
                                <div class="name">${group.name}</div>
                                <div class="id">群主: ${creatorName}</div>
                            </div>
                        </div>
                    </div>
                    <div class="details-card">
                        <div class="details-section-title">群成员 (${group.members.length})</div>
                        <div class="member-grid">${membersHtml}</div>
                    </div>
                    <div class="details-actions">
                        <button class="details-btn btn-details-primary" data-action="chat">发消息</button>
                        <button class="details-btn" data-action="export" style="border-color: var(--theme-color-4); color: var(--text-color-dark);">导出群聊</button>
                        <button class="details-btn btn-details-danger" data-action="delete">${isMyGroup ? '解散群聊' : '退出群聊'}</button>
                    </div>
                `;

                this.showModal({
                    title: `
                        <span style="flex-grow: 1;">群聊资料</span>
                        ${group.author ? `<div class="details-header-attribution" data-action="show-attribution" title="查看作者信息" style="position: static; transform: none;">?</div>` : ''}
                    `,
                    body: bodyHtml,
                    actions: []
                });

                
                modalContentWrapper.querySelector('.modal-header').style.display = 'flex';
                modalContentWrapper.querySelector('.modal-header').style.alignItems = 'center';

                modalContentWrapper.querySelector('[data-action="chat"]').addEventListener('click', () => {
                    this.hideModal();
                    this.openChat(groupId);
                });
                modalContentWrapper.querySelector('[data-action="delete"]').addEventListener('click', () => {
                    this.confirmDeleteGroup(groupId, isMyGroup);
                });
                modalContentWrapper.querySelector('[data-action="export"]').addEventListener('click', () => EventManager.handleExportGroup(groupId));

                const attributionBtn = modalContentWrapper.querySelector('[data-action="show-attribution"]');
                if (attributionBtn) {
                    attributionBtn.addEventListener('click', () => EventManager.showAttributionModal(group));
                }
            },
            
            confirmDeleteGroup(groupId, isCreator, onCancel) { 
                const actionText = isCreator ? '解散' : '退出';
                this.showModal({
                    title: `确认${actionText}`,
                    body: `<p>你确定要${actionText}此群聊吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            this.hideModal();
                            if (onCancel) {
                                onCancel();
                            } else {
                                this.showGroupInfo(groupId);
                            }
                        }},
                        { text: `确认${actionText}`, class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('groups', groupId);
                            await DBHelper.delete('chats', groupId);
                            await DBHelper.delete('chatMetadata', groupId); // 新增：删除聊天元数据
                            this.hideModal();
                            this.hideSidebar();
                            
                            await this.navigateTo('contacts');
                            await this.renderContactsPage('groups');
                            await this.renderMessagesListPage(); // 新增：刷新消息列表
                        }}
                    ]
                });
            },
            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('、');
                    this.showModal({
                        title: "无法删除",
                        body: `<p>无法删除好友，因为对方仍在群聊：<strong>${groupNames}</strong> 中。请先将其移出群聊或解散群聊。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => this.showContactInfo(contactId) }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除该好友吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => this.showContactInfo(contactId) },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chats', contactId);
                            await DBHelper.delete('chatMetadata', contactId); // 新增：删除聊天元数据
                            this.hideModal();
                            await this.renderContactsPage();
                            await this.renderMessagesListPage(); // 新增：刷新消息列表
                        }}
                    ]
                });
            },
            async showGroupManagementSidebar(group) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const isMyGroup = group.creatorId === myProfile.id;
                
                
                this.showSidebar({
                    position: 'right', 
                    title: "群聊管理",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-edit-group">
                                <i class="fas fa-edit"></i>
                                <span>修改群聊信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-members">
                                <i class="fas fa-users"></i>
                                <span>查看群成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-invite-members">
                                <i class="fas fa-user-plus"></i>
                                <span>邀请新成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ${isMyGroup ? `
                            <div class="setting-item" id="sidebar-remove-members">
                                <i class="fas fa-user-minus"></i>
                                <span>移除群成员</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            ` : ''}
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>绑定提示词</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona">
                                <i class="fas fa-user-tag"></i>
                                <span>绑定玩家人设</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene">
                                <i class="fas fa-scroll"></i>
                                <span>开场白设定</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>专属聊天背景</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
<div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>自动总结</span>
    <i class="fas fa-chevron-right"></i>
</div>
                            <div class="setting-item" id="sidebar-leave-group">
                                <i class="fas ${isMyGroup ? 'fa-dumpster-fire' : 'fa-door-open'}"></i>
                                <span>${isMyGroup ? '解散群聊' : '退出群聊'}</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                
                $('#sidebar-edit-group').addEventListener('click', () => {
                    this.showModal({
                        title: "修改群聊信息",
                        body: `
                            <div class="form-group">
                                <label>群头像</label>
                                <div class="avatar-uploader">
                                    <img src="${group.avatar}" id="group-manage-avatar-preview" class="avatar-preview">
                                    <input type="file" id="group-manage-avatar-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('group-manage-avatar-input').click()">上传新头像</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="group-manage-name">群名称</label>
                                <input type="text" id="group-manage-name" value="${group.name}">
                            </div>
                        `,
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => this.hideModal() },
                            { text: '保存', class: 'btn-primary', handler: async () => {
                                const newName = $('#group-manage-name').value.trim();
                                if (!newName) return;
                                const oldName = group.name;
                                const updatedGroup = { ...group, name: newName, avatar: $('#group-manage-avatar-preview').src };
                                await DBHelper.put('groups', updatedGroup);
                                chatTitle.textContent = newName;

                                if (oldName !== newName) {
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const systemMessage = {
                                        messageId: Utils.generateId('msg'),
                                        content: `${myProfile.name} 修改群名为 “${newName}”`,
                                        timestamp: Date.now(),
                                        type: 'received',
                                        segmentType: 'system',
                                        forAi: true,
                                    };
                                    const chatData = await DBHelper.get('chats', group.id) || { chatId: group.id, history: [] };
                                    chatData.history.push(systemMessage);
                                    await DBHelper.put('chats', chatData);
                                    if (appState.currentChatId === group.id) {
                                        await UIManager.refreshChatView();
                                    }
                                }
                                this.hideModal();
                            }}
                        ]
                    });
                     $('#group-manage-avatar-input').addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) $('#group-manage-avatar-preview').src = await Utils.fileToBase64(file);
                    });
                });
                
                $('#sidebar-view-members').addEventListener('click', () => this.showGroupMemberListModal(group.id));
                $('#sidebar-invite-members').addEventListener('click', () => EventManager.handleInviteMembers(group.id));
                if (isMyGroup) {
                    $('#sidebar-remove-members').addEventListener('click', () => EventManager.handleRemoveMembers(group.id));
                }
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(group.id)); 
                $('#sidebar-bind-persona').addEventListener('click', () => EventManager.showPersonaBindingModal(group.id, true));
                $('#sidebar-opening-scene').addEventListener('click', () => EventManager.handleOpeningSceneSettings(group.id, true));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(group.id, true));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(group.id, true));
                $('#sidebar-leave-group').addEventListener('click', () => {
                    this.confirmDeleteGroup(group.id, isMyGroup, () => this.showGroupManagementSidebar(group));
                });
            },

            async showGroupMemberListModal(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');

                
                const aiMembers = group.members
                    .map(id => allContacts.find(c => c.id === id))
                    .filter(Boolean);

                
                const playerAsMember = {
                    id: myProfile.id,
                    avatar: myProfile.avatar,
                    name: myProfile.name,
                    isPlayer: true
                };

                
                const allParticipants = [...aiMembers, playerAsMember];

                
                let owner;
                const otherMembers = [];
                allParticipants.forEach(p => {
                    if (p.id === group.creatorId) {
                        owner = p;
                    } else {
                        otherMembers.push(p);
                    }
                });
                
                
                const finalOrderedList = owner ? [owner, ...otherMembers] : otherMembers;

                
                const membersHtml = finalOrderedList.map(member => `
                    <div class="member-list-modal-item">
                        <img src="${member.avatar}" alt="${member.name}">
                        <span>${member.remark || member.name}</span>
                        ${member.id === group.creatorId ? '<span class="owner-tag">群主</span>' : ''}
                        ${member.isPlayer ? '<span class="owner-tag" style="background-color: var(--accent-color);">你</span>' : ''}
                    </div>
                `).join('');

                this.showModal({
                    title: `群成员 (${finalOrderedList.length})`,
                    body: `<div class="member-list-modal-body"><ul>${membersHtml}</ul></div>`,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                });
            },

            async showFriendManagementSidebar(contact) {
                 this.showSidebar({
                    position: 'right', 
                    title: "好友管理",
                     body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-view-friend">
                                <i class="fas fa-info-circle"></i>
                                <span>查看详细资料</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-friend">
                                <i class="fas fa-user-edit"></i>
                                <span>修改好友信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-persona-friend">
                                <i class="fas fa-user-tag"></i>
                                <span>绑定玩家人设</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-bind-prompts">
                                <i class="fas fa-link"></i>
                                <span>绑定提示词</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-opening-scene-friend">
                                <i class="fas fa-scroll"></i>
                                <span>开场白设定</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-chat-background">
                                <i class="fas fa-image"></i>
                                <span>专属聊天背景</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-auto-summary">
    <i class="fas fa-file-alt"></i>
    <span>自动总结</span>
    <i class="fas fa-chevron-right"></i>
</div>
                            <div class="setting-item" id="sidebar-delete-friend">
                                <i class="fas fa-user-times"></i>
                                <span>删除好友</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });

                $('#sidebar-view-friend').addEventListener('click', () => {
                     this.showModal({
                        title: "详细资料",
                        body: `
                            <div class="details-card">
                                <div class="details-header"><img src="${contact.avatar}" class="avatar"><div class="details-info"><div class="name">${contact.remark || contact.name}</div><div class="id">ID: ${contact.name}</div></div></div>
                                <div class="details-field"><span class="label">性别</span><span class="value">${contact.gender}</span></div>
                            </div>
                            <div class="details-card">
                               ${contact.likes ? `<div class="details-field"><span class="label">喜好</span><span class="value">${contact.likes}</span></div>` : ''}
                               ${contact.dislikes ? `<div class="details-field"><span class="label">厌恶</span><span class="value">${contact.dislikes}</span></div>` : ''}
                               ${contact.habits ? `<div class="details-field"><span class="label">习惯</span><span class="value">${contact.habits}</span></div>` : ''}
                               ${contact.background ? `<div class="details-section"><div class="details-section-title">背景资料</div><p>${contact.background}</p></div>` : ''}
                            </div>
                        `,
                        actions: [{ text: '关闭', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                });

                $('#sidebar-edit-friend').addEventListener('click', () => {
                    EventManager.showEditFriendModal(contact.id);
                });
                
                $('#sidebar-bind-persona-friend').addEventListener('click', () => EventManager.showPersonaBindingModal(contact.id, false));
                
                $('#sidebar-bind-prompts').addEventListener('click', () => EventManager.showBindingModal(contact.id)); 
                $('#sidebar-opening-scene-friend').addEventListener('click', () => EventManager.handleOpeningSceneSettings(contact.id, false));
                $('#sidebar-chat-background').addEventListener('click', () => EventManager.handleChatBackgroundSettings(contact.id, false));
                $('#sidebar-auto-summary').addEventListener('click', () => EventManager.handleAutoSummarySettings(contact.id, false));
                $('#sidebar-delete-friend').addEventListener('click', async () => {
                    const groups = await DBHelper.getAll('groups');
                    const isInGroup = groups.some(g => g.members.includes(contact.id));
                    this.confirmDeleteContact(contact.id, isInGroup);
                });
            },


            async confirmDeleteContact(contactId, isInGroup) {
                if (isInGroup) {
                    const groups = (await DBHelper.getAll('groups')).filter(g => g.members.includes(contactId));
                    const groupNames = groups.map(g => g.name).join('、');
                    this.showModal({
                        title: "无法删除",
                        body: `<p>无法删除好友，因为对方仍在群聊：<strong>${groupNames}</strong> 中。请先将其移出或解散相关群聊。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => this.hideModal() }]
                    });
                    return;
                }
                
                this.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除该好友吗？所有聊天记录将被清空且无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => this.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('contacts', contactId);
                            await DBHelper.delete('chats', contactId);
                            this.hideModal();
                            this.hideSidebar();
                            await this.navigateTo('messages'); 
                        }}
                    ]
                });
            },

async showAutoSummaryModal(entityId, isGroup) {
    const storeName = isGroup ? 'groups' : 'contacts';
    const entity = await DBHelper.get(storeName, entityId);
    if (!entity) return;

    const summaryEnabled = entity.autoSummaryEnabled || false;
    const summaryText = entity.autoSummary || '';
    const isSummarizing = appState.isSummarizing[entityId] || false;

    const summaryStatusHtml = isSummarizing ? `
        <div style="display: flex; align-items: center; gap: 8px; font-size: 0.9rem; color: var(--accent-color); margin-top: 10px;">
            <div class="loader-spinner" style="width: 16px; height: 16px; border-width: 2px;"></div>
            <span>AI正在总结中，请稍后...</span>
        </div>
    ` : '';

    UIManager.showModal({
        title: "自动总结设置",
        body: `
            <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                <label style="margin: 0;">启用自动总结</label>
                <label class="switch">
                    <input type="checkbox" id="auto-summary-switch" ${summaryEnabled ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: -10px; margin-bottom: 20px;">
                开启后，每隔30个玩家回合，AI会自动总结一次聊天内容。
            </p>
            <button id="immediate-summary-btn" class="modal-btn btn-secondary" style="width: 100%; margin-bottom: 20px;" ${isSummarizing ? 'disabled' : ''}>
                <i class="fas fa-magic"></i> 立即总结
            </button>
            <div class="form-group">
                <label for="auto-summary-content">当前总结内容 (可编辑)</label>
                <textarea id="auto-summary-content" rows="8" placeholder="暂无总结内容..." ${isSummarizing ? 'readonly' : ''}>${summaryText}</textarea>
                ${summaryStatusHtml}
            </div>
        `,
        actions: [
            { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
            { text: '保存', class: 'btn-primary', handler: async () => {
                if (isSummarizing) {
                    return UIManager.showToast("正在总结中，请稍后再保存。");
                }
                const updatedEntity = await DBHelper.get(storeName, entityId);
                updatedEntity.autoSummaryEnabled = $('#auto-summary-switch').checked;
                updatedEntity.autoSummary = $('#auto-summary-content').value.trim();
                await DBHelper.put(storeName, updatedEntity);
                UIManager.hideModal();
                UIManager.showToast("设置已保存！");
            }}
        ]
    });

    $('#immediate-summary-btn').addEventListener('click', () => {
        EventManager.handleImmediateSummary(entityId, isGroup);
    });
},

            async showOpeningSceneModal(entityId, isGroup) {
                const scenes = (await DBHelper.getAll('openingScenes')).filter(s => {
                    return isGroup ? s.groupId === entityId : s.contactId === entityId;
                });

                let scenesHtml = scenes.map(scene => `
                    <div class="details-card" style="padding: 15px; margin-bottom: 15px;">
                        <h4 style="margin-bottom: 10px; font-size: 1.1rem;">${scene.name}</h4>
                        <p style="font-size: 0.9rem; color: var(--text-color-medium); white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                            ${scene.content}
                        </p>
                        <div class="modal-actions" style="margin-top: 15px; justify-content: flex-end; gap: 8px;">
                            <button class="modal-btn btn-danger" data-action="delete" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">删除</button>
                            <button class="modal-btn btn-secondary" data-action="edit" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">编辑</button>
                            <button class="modal-btn btn-primary" data-action="apply" data-scene-id="${scene.id}" style="padding: 6px 12px; font-size: 0.8rem;">应用</button>
                        </div>
                    </div>
                `).join('');

                if (scenes.length === 0) {
                    scenesHtml = `<p style="text-align: center; color: #aaa; padding: 20px 0;">还没有开场白，快来创建一个吧！</p>`;
                }

                this.showModal({
                    title: "开场白设定",
                    body: `
                        <div id="opening-scene-list">${scenesHtml}</div>
                    `,
                    actions: [
                        { text: '新建开场白', class: 'btn-primary', handler: () => EventManager.handleNewOpeningScene(entityId, isGroup) }
                    ]
                });

                
                $('#opening-scene-list').addEventListener('click', async (e) => {
                    const button = e.target.closest('button');
                    if (!button) return;

                    const action = button.dataset.action;
                    const sceneId = button.dataset.sceneId;

                    if (action === 'delete') {
                        EventManager.handleDeleteOpeningScene(sceneId, entityId, isGroup);
                    } else if (action === 'edit') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleEditOpeningScene(scene, isGroup);
                    } else if (action === 'apply') {
                        const scene = await DBHelper.get('openingScenes', sceneId);
                        EventManager.handleApplyOpeningScene(scene);
                    }
                });
            },


            async renderMomentsPage(circleId = null) {
                
                if (circleId) {
                    appState.currentCircleId = circleId;
                } else if (!appState.currentCircleId) {
                    const circles = await DBHelper.getAll('circles');
                    if (circles.length > 0) {
                        appState.currentCircleId = circles[0].id; 
                    } else {
                        
                        $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">还没有创建任何圈子，<br>点击右上角菜单去创建一个吧！</li>`;
                        return;
                    }
                }

                
                const currentCircle = await DBHelper.get('circles', appState.currentCircleId);
                const myProfile = await EventManager.getPlayerProfileForContext(appState.currentCircleId);

                if (!currentCircle) {
                     $('#moments-list').innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">圈子不存在或已被删除。</li>`;
                     appState.currentCircleId = null; 
                     
                     $('#moments-my-name').textContent = myProfile.name;
                     $('#moments-my-avatar').src = myProfile.avatar;
                     return;
                }

                const moments = (await DBHelper.getAll('moments')).filter(m => m.circleId === appState.currentCircleId).sort((a, b) => b.timestamp - a.timestamp);
                const allContacts = await DBHelper.getAll('contacts');

                
                $('#moments-bg').src = currentCircle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png';
                $('#moments-my-name').textContent = myProfile.name;
                $('#moments-my-avatar').src = myProfile.avatar;

                
                const momentsListUl = $('#moments-list');
                momentsListUl.innerHTML = '';
                if (moments.length === 0) {
                    momentsListUl.innerHTML = `<li style="text-align:center; color: #aaa; padding: 40px 0;">这个圈子还没有动态，<br>点击右上角刷新一下试试？</li>`;
                } else {
                    for (const moment of moments) {
                        const momentElement = this.createMomentElement(moment, myProfile, allContacts, currentCircle.extraMembers);
                        momentsListUl.appendChild(momentElement);
                    }
                }
            },

            createMomentElement(moment, myProfile, allContacts, extraMembersStr) {
                const li = document.createElement('li');
                li.className = 'moments-post';
                li.dataset.momentId = moment.id;

                
                let author;
                if (moment.authorId === myProfile.id) {
                    author = myProfile;
                } else {
                    const contactAuthor = allContacts.find(c => c.id === moment.authorId);
                    if (contactAuthor) {
                        author = contactAuthor;
                    } else if (extraMembersStr && extraMembersStr.includes(moment.authorId)) {
                        author = { id: moment.authorId, name: moment.authorId, avatar: Utils.createAvatarDataUrl(Utils.getRandomColor()) };
                    } else {
                        author = { id: moment.authorId, name: '未知用户', avatar: Utils.createAvatarDataUrl('#ccc') };
                    }
                }
                
                
                let imagesHtml = '';
                if (moment.images && moment.images.length > 0) {
                    const gridClass = `grid-${moment.images.length > 9 ? 9 : moment.images.length}`;
                    imagesHtml = `
                        <div class="post-images-grid ${gridClass}">
                            ${moment.images.map(src => `<img src="${src}" alt="动态图片">`).join('')}
                        </div>`;
                }
                
                
                const hasLikes = moment.likes && moment.likes.length > 0;
                const hasComments = moment.comments && moment.comments.length > 0;
                const playerHasLiked = moment.likes && moment.likes.includes(myProfile.name);

                let likesHtml = '';
                if (hasLikes) {
                    likesHtml = `<div class="post-likes"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (hasComments) {
                    commentsHtml = moment.comments.map(comment => {
                         let commentAuthor = { name: '未知', id: null };
                         if (comment.authorId === myProfile.id) {
                            commentAuthor = myProfile;
                         } else {
                            const contactCommenter = allContacts.find(c => c.id === comment.authorId);
                            if (contactCommenter) {
                                commentAuthor = contactCommenter;
                            } else if (extraMembersStr && extraMembersStr.includes(comment.authorId)) {
                                 commentAuthor = { name: comment.authorId, id: comment.authorId };
                            }
                         }
                         
                         const authorStyle = commentAuthor.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                         const replyHtml = comment.replyTo ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${comment.replyTo}:</span>` : ':';

                         return `<div class="post-comment-item" data-author-name="${commentAuthor.name}" data-author-id="${commentAuthor.id}">
                                    <span class="comment-author" ${authorStyle}>${commentAuthor.name}</span>${replyHtml} ${comment.content}
                                </div>`;
                    }).join('');
                }
                
                const authorStyle = author.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';

                const isMyPost = author.id === myProfile.id;

                li.innerHTML = `
                    <img src="${author.avatar}" alt="作者头像" class="post-avatar">
                    <div class="post-main-content">
                        <div class="post-author-name" ${authorStyle}>${author.name}</div>
                        <div class="post-text">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer">
                            <span class="post-timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        <div class="action-buttons-wrapper">
                            ${isMyPost ? `
                            <button class="post-action-icon-btn" data-action="delete-moment" title="删除">
                                <i class="fas fa-trash-alt"></i>
                            </button>
                            ` : ''}
                            <button class="post-action-icon-btn" data-action="forward" title="转发">
                                <i class="fas fa-share"></i>
                            </button>
                            <button class="post-action-icon-btn ${playerHasLiked ? 'liked' : ''}" data-action="like" title="点赞">
                                <i class="far fa-heart"></i>
                            </button>
                            <button class="post-actions-btn" data-action="toggle-comment" title="评论">
                                <i class="fas fa-comment-dots"></i>
                            </button>
                        </div>
                      </div>
                        ${(hasLikes || hasComments) ? `
                        <div class="post-interactions">
                            ${likesHtml}
                            <div class="post-comments-list">${commentsHtml}</div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="评论...">
                                <button data-action="submit-comment">发送</button>
                            </div>
                        </div>
                        ` : `
                        <div class="post-interactions" style="display:none;">
                            <div class="post-likes"></div>
                            <div class="post-comments-list"></div>
                            <div class="comment-input-wrapper">
                                <input type="text" placeholder="评论...">
                                <button data-action="submit-comment">发送</button>
                            </div>
                        </div>
                        `}
                    </div>
                `;
                return li;
            },

            async showCircleManagementSidebar() {
                this.showSidebar({
                    position: 'right',
                    title: "朋友圈管理",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="sidebar-switch-circle">
                                <i class="fas fa-sync-alt"></i>
                                <span>切换圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-view-circle">
                                <i class="fas fa-info-circle"></i>
                                <span>查看圈子信息</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-add-circle">
                                <i class="fas fa-plus-circle"></i>
                                <span>新增圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-edit-circle">
                                <i class="fas fa-edit"></i>
                                <span>修改当前圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-delete-circle">
                                <i class="fas fa-trash-alt"></i>
                                <span>删除圈子</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="sidebar-clear-circle-history">
                                <i class="fas fa-eraser"></i>
                                <span>清空朋友圈记录</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: []
                });
                
                $('#sidebar-clear-circle-history').onclick = () => EventManager.handleClearCircleHistory();
                $('#sidebar-switch-circle').onclick = () => EventManager.handleSwitchCircle();
                $('#sidebar-view-circle').onclick = () => EventManager.handleViewCircleInfo();
                $('#sidebar-add-circle').onclick = () => EventManager.handleAddCircle();
                $('#sidebar-edit-circle').onclick = () => EventManager.handleEditCircle(appState.currentCircleId);
                $('#sidebar-delete-circle').onclick = () => EventManager.handleDeleteCircle();
            },

            async applyChatBackground(chatId) {
                const isGroup = chatId.startsWith('group-');
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const themeSettings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const chatAreaEl = $('#chat-area');
                
                
                const defaultChatBgColor = 'var(--bg-main)';

                
                if (entity && entity.chatBackground) {
                    chatAreaEl.style.backgroundImage = `url(${entity.chatBackground})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                if (themeSettings.globalChatBg) {
                    chatAreaEl.style.backgroundImage = `url(${themeSettings.globalChatBg})`;
                    chatAreaEl.style.backgroundSize = 'cover';
                    chatAreaEl.style.backgroundPosition = 'center';
                    chatAreaEl.style.backgroundColor = ''; 
                    return;
                }

                
                chatAreaEl.style.backgroundImage = ''; 
                chatAreaEl.style.backgroundColor = defaultChatBgColor; 
            },
            async renderFriendFoldersPage() {
                const contentArea = $('#contacts-friend-folders');
                contentArea.innerHTML = ''; // Clear previous content
                const friendFolders = await DBHelper.getAll('friendFolders');
                const allContacts = await DBHelper.getAll('contacts');

                const folderMap = friendFolders.reduce((acc, folder) => {
                    acc[folder.id] = folder;
                    return acc;
                }, {});

                const sortedFolders = friendFolders.sort((a, b) => a.createdAt - b.createdAt);

                for (const folder of sortedFolders) {
                    const folderContacts = allContacts.filter(c => c.folderId === folder.id);
                    const folderElement = this.createFriendFolderElement(folder, folderContacts);
                    contentArea.appendChild(folderElement);
                }

                const ungroupedContacts = allContacts.filter(c => !c.folderId || !folderMap[c.folderId]);
                if (ungroupedContacts.length > 0) {
                    const ungroupedFolder = { id: 'unclassified', name: '未分组好友', isUnclassified: true };
                    const ungroupedElement = this.createFriendFolderElement(ungroupedFolder, ungroupedContacts);
                    contentArea.appendChild(ungroupedElement);
                }
                
                this.bindFriendFolderEvents();
            },

            createFriendFolderElement(folder, contacts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder'; 
                folderDiv.dataset.folderId = folder.id;

                let contactsHtml = contacts.map(contact => `
                    <div class="contact-item" data-id="${contact.id}" style="cursor: pointer; padding: 10px 5px;">
                        <img src="${contact.avatar}" alt="avatar" class="contact-item-avatar">
                        <span class="contact-item-name">${contact.remark || contact.name}</span>
                    </div>
                `).join('');
                if (contacts.length === 0 && !folder.isUnclassified) {
                    contactsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此分组为空</p>`;
                }

                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            ${folder.name} (${contacts.length})
                        </h3>
                        ${!folder.isUnclassified ? `
                        <div class="prompt-folder-controls">
                            <button class="folder-action-btn" data-action="bind-persona" title="绑定玩家人设"><i class="fas fa-user-tag"></i></button>
                            <button class="folder-action-btn" data-action="edit-folder" title="编辑分组"><i class="fas fa-edit"></i></button>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除分组"><i class="fas fa-trash-alt"></i></button>
                        </div>
                        ` : ''}
                    </div>
                    <div class="prompt-folder-content collapsed" style="display: block; grid-template-columns: 1fr;">${contactsHtml}</div>
                `;
                return folderDiv;
            },

            bindFriendFolderEvents() {
                $('#contacts-friend-folders').onclick = (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const actionBtn = target.closest('.folder-action-btn');
                    const contactItem = target.closest('.contact-item');

                    if (actionBtn) {
                        e.stopPropagation();
                        const folderId = actionBtn.closest('.prompt-folder').dataset.folderId;
                        const action = actionBtn.dataset.action;
                        if (action === 'edit-folder') {
                            EventManager.showAddEditFriendFolderModal(folderId);
                        } else if (action === 'delete-folder') {
                            EventManager.confirmDeleteFriendFolder(folderId);
                        } else if (action === 'bind-persona') {
                            EventManager.showPersonaBindingModal(folderId, false);
                        }
                    } else if (folderHeader) {
                        const content = folderHeader.nextElementSibling;
                        folderHeader.classList.toggle('collapsed');
                        content.classList.toggle('collapsed');
                    } else if (contactItem) {
                        const contactId = contactItem.dataset.id;
                        this.openChat(contactId);
                    }
                };
            },
        };
            

        
        const AIHandler = {
            groupChatRules: `\n---
群聊专属规则：
1.  **多角色发言**：你可以让多个角色发言，每个角色的发言都是独立的单元，你可以根据人设安排部分群友不发言(例如有的角色是早睡设定,时间太晚就不会回复)，但至少需要构造一名群友的发言。
2.  **私聊消息**: 如果想对玩家说一些不想让其他人知道的话，请使用 <私聊></私聊> 标签包裹。标签内的消息格式依然遵循所有基础规则（如 <私聊>[方鹤安|你在群里说的那句话是什么意思]</私聊>）。
3.  **修改群名**: 你可以根据剧情发展，主动修改群名。格式为：<系统>角色名 修改群名为"新群名"</系统>。例如：<系统>商时序 修改群名为"F4"</系统>。注意：此行为必须符合你的角色设定，不能随意或无理由地修改。
4.**群友回复顺序不固定，可以交叉回复，例如群友A、群友B、群友B、群友A、群友C这样的交叉顺序。不一定要一个人全部说完了才轮到下一个人。群友之间也可以有互动对话，例如使用@提及其他群友。**
---`,
            formatPromptTpl: `\n---
回复规则（非常重要！请严格遵守！）：
1.  你的所有回复都必须严格遵循以下格式，使用**角色名**，而不是其他昵称/称呼，每一句话都是一个独立的单元。
2.  **普通文本消息**：请将你的普通回复拆分成多个通畅的短句，并使用格式：[角色名|消息内容]。例如：[陈奚楷|你好啊]。
3.  **表情包消息**：<角色名|表情包ID>，**禁止在<>外面包裹[]**。你必须在< >中使用冒号左边的ID，而不是文字描述。可用表情包ID及其含义：\n{EMOJI_LIST}。一次回复内一般最多使用2个表情包。
4.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心发出来的话，请将该短句用英文大括号包裹，格式为：{角色名|已经发送然后立刻撤回的原始消息内容}。例如：例如：{孟祁年|装货，你以为老子不知道你什么心思吗}。不要发送一条正常消息再发送一条“撤回”的指令。
5.  **语音消息**：[角色名|语音|语音时长|语音内容]。语音时长最长不超过60s。例如：[三三|语音|13s|太好了！那我们下午三点在公司会议室详细讨论]。
6.  **引用消息**: [角色名|引用|被引用人ID|被引用的消息内容|你的新消息内容]。不要滥用。例如: [陈奚楷|引用|楚寻|你哪里不会?|关于最后一题我还有点疑问。]。禁止引用转账/红包消息
7.  **转账消息**: [角色名|转账|被转账角色名|金额|备注]。金额格式为 "￥XX.XX"。例如: [孟祁年|转账|商时序|￥520.00|给你的惊喜]。
8.  **红包消息**: [角色名|红包|红包名称|金额|红包个数]。私聊时红包个数必须为1。例如: [孟祁年|红包|请大家喝奶茶|￥88.88|4]。
9. **卡片消息**: 当你想分享一类卡片消息（如：地点分享、文件分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，使用这种格式：『角色名|分享类型|分享标题|简介15字以内|详细内容30-60字』，举例：『角色名|图片分享|夏日海滩|一张记录美好瞬间的照片|照片里是蔚蓝的大海和金色的沙滩，充满了夏日的活力与惬意。』
10. **礼物消息**: 当某个角色基于人物设定/聊天记录内容想赠送礼物时，使用以下格式，并确保每个字段都填写完整：
<礼物>
发送方：角色名
接收方：玩家名或另一角色名
礼物名称：xxx
礼物价格：xxx
礼物介绍：xxx（不超过50字）
寄语：xxx（简单一句话）
</礼物>
11. **心声 (强制要求)**: 在你本次所有消息内容之后，你必须以【心声|角色名|你的心声内容】的格式来结束你的整个回复。**字数不超过30字。**
12. **随笔 (概率出现)**: 你有一定概率会在【心声】之后，额外写一段「随笔|角色名|你的随笔内容」。这段随笔是角色在当前情境下，有感而发的一些思考或经历，可以与当前对话内容相关，也可以是独立的小故事或心情记录。字数请控制在50到250字之间。
13. **严禁事项(1)**：绝不允许你代入玩家（“{PLAYER_NAME}”）的角色发言或为其生成心声。
14. **严禁事项(2)**：你的回复内容中，不要使用括号 ()、星号 ** 或其他任何符号来描述角色的动作、表情或内心活动。
---
现在，请根据以上信息，对玩家的最新消息进行回应。`,

            activeReplyPromptTpl: `\n---
主动回复规则（非常重要！请严格遵守！）：
1.  你现在需要主动发送一些消息。你的所有回复都必须严格遵循以下格式，在每条消息的末尾附带消息时间，使用 | 分隔。
2.  **普通文本消息**：请将你的普通回复拆分成多个通畅的短句，并使用格式：[角色名|消息内容|消息时间]。例如：[陈奚楷|下午去看电影吗|14:50]。
3.  **表情包消息**：<角色名|表情包ID|消息时间>，**禁止在<>外面包裹[]**。你必须在< >中使用冒号左边的ID，而不是文字描述。可用表情包ID及其含义：{EMOJI_LIST}。
4.  **撤回消息**：如果你想表达某种情绪或者说出一些角色会后悔的话或者不小心发出来的话，请将该短句用英文大括号包裹，格式为：{角色名|消息内容|消息时间}
5.  **语音消息**：[角色名|语音|语音时长|语音内容|消息时间]。语音时长最长不超过60s。例如：[三三|语音|13s|太好了！那我们下午三点在公司会议室详细讨论|13:43]。
6.  **引用消息**: [角色名|引用|被引用人ID|被引用的消息内容|你的新消息内容|消息时间]。不要滥用。例如: [陈奚楷|引用|楚寻|你哪里不会?|关于最后一题我还有点疑问。|9:46]。禁止引用转账/红包消息
7.  **转账消息**: [角色名|转账|收款人角色名|金额|备注]。金额格式为 "￥XX.XX"。例如: [孟祁年|转账|商时序|￥520.00|给你的惊喜]。
8.  **红包消息**: [角色名|红包|红包名称|金额|红包个数]。金额必须大于等于“红包个数 * 0.01”。私聊时红包个数必须为1。例如: [孟祁年|红包|请大家喝奶茶|￥88.88|4]。
9. **卡片消息**: 当你想分享一类卡片消息（如：地点分享、文件分享、歌曲分享、或者其他有趣的可以用卡片发出来的分享内容）时，使用这种格式：『角色名|分享类型|分享标题|简介15字以内|详细内容30-60字|消息时间』，举例：『角色名|图片分享|夏日海滩|一张记录美好瞬间的照片|照片里是蔚蓝的大海和金色的沙滩，充满了夏日的活力与惬意。|7/2 12:36』
10. **礼物消息**: 当你想主动赠送礼物时，使用以下格式：
<礼物>
发送方：角色名
接收方：玩家名或另一角色名
礼物名称：xxx
礼物价格：xxx
礼物介绍：xxx（不超过50字）
寄语：xxx（简单一句话）
</礼物>
11. **心声 (强制要求)**: 在你本次所有消息内容之后，你必须以【心声|角色名|你的心声内容】的格式来结束你的整个回复。字数不超过30字。
12. **随笔 (概率出现)**: 你有一定概率会在【心声】之后，额外写一段「随笔|角色名|你的随笔内容」。这段随笔是角色在当前情境下，有感而发的一些思考或经历，可以与当前对话内容相关，也可以是独立的小故事或心情记录。字数请控制在50到250字之间。
13. **严禁事项(1)**：绝不允许你代入玩家（“{PLAYER_NAME}”）的角色发言或为其生成心声。
14. **严禁事项(2)**：你的回复内容中，不要使用括号 ()、星号 ** 或其他任何符号来描述角色的动作、表情或内心活动。
---
现在，请根据以上信息，开始你的主动发言。`,

            buildTurnsFromHistory(history, allContacts, myProfile) {
                if (!history || history.length === 0) return [];
                
                const formatMessageContent = (msg, senderName, myName) => {
                    const recipientName = msg.cardData?.recipientName || '对方';
                    if (msg.isRetracted) {
                        const retracter = (msg.type === 'sent') ? myName : senderName;
                        return `{${retracter}|${msg.content}}`;
                    }
                    if (msg.segmentType === 'inner_voice') {
                         return `【心声|${senderName}|${msg.content}】`;
                    }
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|语音|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|引用|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer': return `[${senderName}|转账|${recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'transfer-receipt': 
                            const receiptSender = allContacts.find(c => c.name === msg.cardData.senderName) || myProfile;
                            const receiptRecipient = allContacts.find(c => c.name === msg.cardData.recipientName) || myProfile;
                            return `[${receiptRecipient.name}|领取转账|${receiptSender.name}|${msg.cardData.amount}]`;
                        case 'transfer-return': return `[${senderName}|退还转账|${recipientName}|${msg.cardData.amount}]`;
                        case 'red-packet': return `[${senderName}|红包|${msg.cardData.title}|￥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|图片描述|${msg.cardData.description}]`; 
                        case 'gift': return `<礼物>\n发送方：${senderName}\n接收方：${recipientName}\n礼物名称：${msg.cardData.name}\n礼物价格：${msg.cardData.price}\n礼物介绍：${msg.cardData.description || '无'}\n寄语：${msg.cardData.message}\n</礼物>`;
                        case 'forward_custom': return msg.content;
                        case 'system': return msg.forAi ? `<系统>${msg.content}</系统>`: '';
                        case 'narrator': return `<旁白>${msg.content}</旁白>`;
                        case 'card':
                            if (msg.type === 'sent') {
                                return `『${myName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}』`;
                            } else {
                                return `『${senderName}|${msg.cardData.shareType}|${msg.cardData.title}|${msg.cardData.summary}|${msg.cardData.details}』`;
                            }
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };

                const relevantHistory = history.filter(m => m.segmentType !== 'essay' && !m.isHidden);
                if (relevantHistory.length === 0) return [];

                let turns = [];
                let currentTurn = null;

                for (const msg of relevantHistory) {
                    const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                    if (!sender && msg.segmentType !== 'system') continue;
                    
                    const senderName = sender ? (msg.type === 'sent' ? myProfile.name : sender.name) : '系统';
                    const formattedContent = formatMessageContent(msg, senderName, myProfile.name);
                    if (!formattedContent) continue;

                    const role = msg.type === 'sent' ? 'player' : 'ai';

                    if (currentTurn && currentTurn.role === role) {
                        currentTurn.content += formattedContent;
                    } else {
                        if (currentTurn) {
                            turns.push(currentTurn);
                        }
                        currentTurn = {
                            role: role,
                            time: Utils.formatTimestampForPrompt(msg.timestamp),
                            content: formattedContent
                        };
                    }
                }
                if (currentTurn) {
                    turns.push(currentTurn);
                }
                return turns;
            },

            apiConfig: {}, 
            isAwaitingResponse: false,
            abortController: null,

            async loadApiConfig() {
                let config = await DBHelper.get('apiConfig', 'mainConfig');
                if (!config) {
                    config = {
                        id: 'mainConfig',
                        provider: 'gemini',
                        url: 'https://generativelanguage.googleapis.com/v1beta/models/',
                        key: '',
                        model: 'gemini-2.5-flash', 
                        temperature: 0.7
                    };
                    await DBHelper.put('apiConfig', config);
                }
                this.apiConfig = config;
            },

            async saveApiConfig(newConfig) {
                this.apiConfig = { ...this.apiConfig, ...newConfig, id: 'mainConfig' };
                await DBHelper.put('apiConfig', this.apiConfig);
            },

            async getPendingTransfersPrompt(chatId, aiCharactersInChat) {
                const history = await DBHelper.getMessages(chatId, 30); // 检查最近30条消息
                if (history.length === 0) return '';
                
                const aiCharacterIds = aiCharactersInChat.map(c => c.id);

                const pendingTransfers = history.filter(msg => 
                    msg.segmentType === 'transfer' &&
                    msg.cardData && !msg.cardData.isClaimed &&
                    aiCharactersInChat.some(ai => ai.name === msg.cardData.recipientName)
                );
                
                if (pendingTransfers.length === 0) return '';

                const promptLines = pendingTransfers.map(t => {
                    const senderName = (t.type === 'sent') ? '玩家' : t.senderInfo.name;
                    return `- 来自 ${senderName} 的转账 ${t.cardData.amount}，备注：${t.cardData.note || '无'}`;
                });
                
                return `\n---
转账待办事项：
有以下未处理的转账，请在本次回复中，根据被转账人的人设和聊天记录决定【领取转账】或【退还转账】，并使用对应的格式进行回复。
${promptLines.join('\n')}
---\n
**收款回复格式**：[收款人角色名|领取转账|转账人名字|转账金额]
**退还回复格式**：[退款人角色名|退还转账|转账人名字|转账金额]
例如：[孟祁年|领取转账|商时序|￥0.01]
---`;
            },

            async buildPrompt() {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                
                const defaults = { memoryInterconnection: false, historyCharLimit: 5000, promptTurnFrequency: 1 };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const chatSettings = { ...defaults, ...savedSettings };
                const isGroup = chatId.startsWith('group-');
                
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId, turnCountSinceLastPrompt: 0 };
                
                const recentMessages = await DBHelper.getMessages(chatId, 5);
                let extraEmojiHintPrompt = '';
                if (recentMessages.length > 0) {
                    const lastPlayerTurnMessages = [];
                    for (let i = recentMessages.length - 1; i >= 0; i--) {
                        if (recentMessages[i].type === 'sent') lastPlayerTurnMessages.unshift(recentMessages[i]);
                        else break;
                    }

                    if (lastPlayerTurnMessages.length > 0) {
                        const extraEmojiIds = new Set(
                            lastPlayerTurnMessages
                                .filter(msg => msg.segmentType === 'emoji-image' && !appState.aiEmojiMap.hasOwnProperty(msg.content))
                                .map(msg => msg.content)
                        );
                        if (extraEmojiIds.size > 0) {
                            const hintContent = Array.from(extraEmojiIds)
                                .map(id => appState.playerEmojiMap[id] ? `${id}：${appState.playerEmojiMap[id]}` : null)
                                .filter(Boolean).join('\n');
                            if (hintContent) {
                                extraEmojiHintPrompt = `\n--- 补充信息：玩家最新发送的表情包含义如下 ---\n${hintContent}\n---`;
                            }
                        }
                    }
                }
                
                const turnFrequency = chatSettings.promptTurnFrequency;
                // 如果频率设置为1或0（我们视作“每一次”），则总是发送完整prompt。
                // 否则，才根据玩家的回合计数器来判断。
                const shouldSendFullPrompt = turnFrequency <= 1 ? true : (chatMetadata.turnCountSinceLastPrompt || 0) >= turnFrequency;
                
                // 内部辅助函数，现在可以限制回合数
                const buildHistoryBlock = async (targetChatId, title, charLimit, turnLimit = null) => {
                    // 获取足够多的消息来构建所需的回合数，例如200条
                    const messages = await DBHelper.getMessages(targetChatId, 200); 
                    if (messages.length === 0) return '';

                    let turns = AIHandler.buildTurnsFromHistory(messages, allContacts, myProfile);
                    if (turns.length === 0) return '';

                    // 如果有回合数限制，先应用
                    if (turnLimit !== null && turns.length > turnLimit) {
                        turns = turns.slice(-turnLimit);
                    }
                    
                    // 然后再应用字数限制
                    let finalTurns = [];
                    let currentCharCount = 0;
                    for (let i = turns.length - 1; i >= 0; i--) {
                        const turn = turns[i];
                        const turnString = JSON.stringify(turn);
                        if (currentCharCount + turnString.length > charLimit) {
                            break; 
                        }
                        finalTurns.unshift(turn);
                        currentCharCount += turnString.length;
                    }

                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };

                const now = new Date();
                const systemTime = `当前系统时间是：${Utils.formatTimestampForPrompt(now)}，${['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'][now.getDay()]}。`;
                
                let taskPrompt = '', characterInfoPrompt = '', chatEntity, pendingTransfersPrompt = '';
                
                if (isGroup) {
                    chatEntity = await DBHelper.get('groups', chatId);
                    const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `你现在正在一个名为“${chatEntity.name}”的群聊中，需要同时扮演以下几位角色：${members.map(m => m.name).join('、')}。你的任务是根据每个角色的性格设定，与群里的“${myProfile.name}”（也就是玩家）进行互动。`;
                    characterInfoPrompt = `群聊成员资料如下：\n` + members.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                } else {
                    chatEntity = await DBHelper.get('contacts', chatId);
                    taskPrompt = `你现在正在扮演“${chatEntity.name}”，与“${myProfile.name}”（也就是玩家）进行一对一私聊。`;
                    characterInfoPrompt = `你的角色资料如下：\n角色名: ${chatEntity.name}\n性别: ${chatEntity.gender}\n喜好: ${chatEntity.likes || '无'}\n厌恶: ${chatEntity.dislikes || '无'}\n习惯: ${chatEntity.habits || '无'}\n背景: ${chatEntity.background || '无'}`;
                }

                let aiCharactersInChat = isGroup ? chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean) : [chatEntity];
                pendingTransfersPrompt = await this.getPendingTransfersPrompt(chatId, aiCharactersInChat);

                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                let pomodoroPromptSection = '';
                if (appState.pomodoro && appState.pomodoro.isActive && appState.pomodoro.endTime) {
                    const remainingSeconds = Math.max(0, Math.round((appState.pomodoro.endTime - Date.now()) / 1000));
                    const remainingMinutes = Math.ceil(remainingSeconds / 60);
                    const startTime = new Date(appState.pomodoro.endTime - appState.pomodoro.totalSeconds * 1000);
                    pomodoroPromptSection = `\n---
番茄钟状态：玩家当前正在进行一个为期25分钟的番茄钟专注时段。
- 专注目标：${appState.pomodoro.goal}
- 开始时间：${Utils.formatTimestampForPrompt(startTime)}
- 剩余时间：约 ${remainingMinutes} 分钟
请注意，玩家此时给你发消息属于“分心”行为，你可以结合你的角色设定，对此作出回应。
---`;
                }

                // --- 修复开始 ---
                // 1. 先构建自定义提示词部分
                let customPromptsSection = '';
                if (shouldSendFullPrompt && chatEntity && chatEntity.boundPromptFolderIds?.length > 0) {
                    const allFolders = await DBHelper.getAll('promptFolders');
                    const allPrompts = await DBHelper.getAll('prompts');
                    const playerLastMessage = (await DBHelper.getMessages(chatId, 1)).pop()?.content || '';

                    const activeBoundFolders = allFolders.filter(f => chatEntity.boundPromptFolderIds.includes(f.id) && f.isActive);
                    if (activeBoundFolders.length > 0) {
                        const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                        const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);
                        const promptsToInject = relevantPrompts
                            .filter(p => p.type === 'explicit' || (p.type === 'implicit' && JSON.parse(p.keywords).some(kw => playerLastMessage.includes(kw))))
                            .map(p => p.content);
                        if (promptsToInject.length > 0) {
                            customPromptsSection = `\n--- 其他资料 ---\n${promptsToInject.join('\n\n')}\n---`;
                        }
                    }
                }

                // 2. 然后构建历史记录部分
                let historyPrompt = "以下是聊天记录，请结合上下文进行回复（每行是一个JSON对象，代表一个回合）：\n";
                const historyCharLimit = chatSettings.historyCharLimit || 5000;

                if (chatSettings.memoryInterconnection) {
                    if (isGroup) {
                        const members = chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                        let privateContext = '--- 以下是各角色的私聊记忆 (仅角色自己可见, 最多10回合) ---\n';
                        for (const member of members) {
                            privateContext += await buildHistoryBlock(member.id, `与 ${member.name} 的私聊记录`, 2000, 10);
                        }
                        historyPrompt += privateContext;
                        historyPrompt += await buildHistoryBlock(chatId, '当前群聊记录', historyCharLimit);
                    } else { // 私聊
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- 以下是相关的群聊记忆 (最多8回合) ---\n';
                        for (const group of relatedGroups) {
                            groupContext += await buildHistoryBlock(group.id, `群聊“${group.name}”的记录`, 1500, 8);
                        }
                        historyPrompt += groupContext;
                        historyPrompt += await buildHistoryBlock(chatId, '当前私聊记录', historyCharLimit);
                    }
                } else { // 记忆互通关闭
                    historyPrompt += await buildHistoryBlock(chatId, '当前聊天记录', historyCharLimit);
                }

                // 3. 构建其他部分
                const emojiListString = Object.entries(appState.aiEmojiMap).map(([id, desc]) => `${id}：${desc}`).join('\n');
                const formatPrompt = AIHandler.formatPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name);
                let summaryPromptSection = '';
                if (chatEntity && chatEntity.autoSummary) {
                    summaryPromptSection = `--- 会话概要---\n${chatEntity.autoSummary}\n---`;
                }

                // 4. 最后组装所有部分
                const promptParts = [
                    systemTime, 
                    taskPrompt, 
                    characterInfoPrompt, 
                    playerInfoPrompt, 
                    pendingTransfersPrompt, 
                    pomodoroPromptSection, 
                    summaryPromptSection, 
                    customPromptsSection, // 现在这里包含了正确的内容
                    historyPrompt, 
                    extraEmojiHintPrompt, 
                    formatPrompt
                ];

                if (shouldSendFullPrompt) {
                    chatMetadata.turnCountSinceLastPrompt = 0;
                    await DBHelper.put('chatMetadata', chatMetadata);
                }
                
                let finalPrompt = promptParts.filter(Boolean).join('\n\n');
                if (isGroup) finalPrompt += AIHandler.groupChatRules;
                // --- 修复结束 ---
                
                console.log(`--- PROMPT SENT TO AI (Full: ${shouldSendFullPrompt}) ---\n`, finalPrompt);
                return finalPrompt;
            },

            async getApiResponse(prompt, signal) {
                const { provider, url, key, model, temperature } = this.apiConfig;
                if (!key || !url || !model) {
                    throw new Error('API配置不完整，请在设置中检查。');
                }

                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                const messagesForApi = [{ role: 'user', content: prompt }];

                if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    headers['Authorization'] = `Bearer ${key}`;
                    if (!apiUrl.endsWith('/chat/completions')) {
                        apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                    }
                    body = { model: model, messages: messagesForApi, temperature: temperature };
                } else if (provider === 'gemini') {
                    apiUrl += `${model}:generateContent?key=${key}`;
                    body = {
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        generationConfig: { temperature: temperature }
                    };
                } else {
                    throw new Error('不支持的API提供商。');
                }

                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(body),
                        signal: signal
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        console.error("API Error Response:", errorData);
                        throw new Error(`API请求失败: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                    }

                    const data = await response.json();
                    console.log("API Response Data:", JSON.stringify(data, null, 2));
                    console.log("API Response Data:", JSON.stringify(data, null, 2));

                    if (provider === 'gemini') {
                        if (data.candidates && data.candidates.length > 0 && data.candidates[0].content && data.candidates[0].content.parts && data.candidates[0].content.parts.length > 0) {
                            return data.candidates[0].content.parts[0].text;
                        } else {
                            let reason = "未知原因。";
                            if (data.promptFeedback && data.promptFeedback.blockReason) {
                                reason = `内容被阻止，原因：${data.promptFeedback.blockReason}。请检查您的Prompt或调整API的安全设置。`;
                            } else {
                                reason = "API返回了空的或无效的候选内容。";
                            }
                            throw new Error(`Gemini API未返回有效回复：${reason}`);
                        }
                    } else { // For OpenAI-compatible APIs
                        if (data.choices && data.choices.length > 0 && data.choices[0].message && data.choices[0].message.content) {
                            return data.choices[0].message.content;
                        } else {
                            let reason = "API返回了空的或无效的选项。";
                            if (data.choices && data.choices.length > 0 && data.choices[0].finish_reason) {
                                reason = `内容被阻止，原因：${data.choices[0].finish_reason}。`;
                            }
                            throw new Error(`API未返回有效回复：${reason}`);
                        }
                    }
                } catch (error) {
                    if (error instanceof TypeError && error.message === 'Failed to fetch') {
                        throw new Error('API请求失败。原因：Failed to fetch。<br>请尝试检查你的API配置是否正确，网络服务是否通畅<br>详情可前往【设置-食用指南】查看教程。');
                    }
                    // Re-throw other errors (like AbortError or JSON parsing errors)
                    throw error;
                }
            },
            
            async handleAiReplyRequest() {
                if (this.isAwaitingResponse) return; 

                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController(); 
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false; 

                const prompt = await this.buildPrompt();
                if (!prompt) {
                     this.showError("无法构建prompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI 原始回复 ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AI请求已被用户取消。");
                    } else {
                        console.error("AI回复失败:", error);
                        this.showError(`AI回复失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },
            cancelAiRequest() {
                if (this.abortController) {
                    this.abortController.abort();
                    console.log("正在取消AI请求...");
                }
            },
            async handleActiveReplyRequest(lastAiTimestamp) {
                if (this.isAwaitingResponse) return;
                
                const requestedChatId = appState.currentChatId;
                if (!requestedChatId) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();

                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const prompt = await this.buildActiveReplyPrompt(lastAiTimestamp);
                if (!prompt) {
                     this.showError("无法构建主动回复prompt");
                     this.isAwaitingResponse = false;
                     aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                     return;
                }
                
                const isGroup = requestedChatId.startsWith('group-');
                let typingBubbleId = Utils.generateId('typing');
                let typingTarget;
                
                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', requestedChatId);
                    if(typingTarget) {
                         UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', requestedChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI 主动回复 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayActiveAIResponse(aiRawResponse, requestedChatId);
                } catch (error) {
                    if (error.name === 'AbortError') {
                        console.log("AI主动回复请求已被用户取消。");
                    } else {
                        console.error("AI主动回复失败:", error);
                        this.showError(`AI主动回复失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    if (typingBubbleId) {
                        const typingBubble = $(`#${typingBubbleId}`);
                        if (typingBubble) typingBubble.remove();
                    }
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },
            
            async buildActiveReplyPrompt(lastAiTimestamp) {
                const chatId = appState.currentChatId;
                if (!chatId) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');
                const allGroups = await DBHelper.getAll('groups');
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const fullHistory = await DBHelper.getMessages(chatId, 100); // 修复：从正确的 'messages' 表获取历史记录
                const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                const historyLength = 10; // 定义历史记录的轮数

                const now = Date.now();
                const lastDate = new Date(lastAiTimestamp);
                const elapsedMillis = now - lastAiTimestamp;
                const elapsedHours = Math.floor(elapsedMillis / (1000 * 60 * 60));
                const elapsedMinutes = Math.floor((elapsedMillis % (1000 * 60 * 60)) / (1000 * 60));
                const lastTimeFormatted = `${lastDate.getMonth() + 1}月${lastDate.getDate()}日 ${String(lastDate.getHours()).padStart(2, '0')}:${String(lastDate.getMinutes()).padStart(2, '0')}`;
                const durationString = `${elapsedHours > 0 ? `${elapsedHours}小时` : ''}${elapsedMinutes}分钟`;

                let situationPrompt = '';
                if (isGroup) {
                    situationPrompt = `你们上次聊天是${lastTimeFormatted}，距离现在过去${durationString}了，在这段时间内，玩家“${myProfile.name}”并不在线，你们可以自由交流，交流内容可以与玩家有关，也可以与玩家无关。`;
                } else {
                    situationPrompt = `“${myProfile.name}”上次和你聊天时间是${lastTimeFormatted}，距离现在已经过去了${durationString}。请你根据你的人设，说一些在这段时间里你可能会对“${myProfile.name}”说的话，也可能是这段时间内你遇到的新鲜的事，想和TA分享。这些话不一定是同一时间发的，有时候只隔了一两分钟，有可能你可能隔了十几二十分钟才发下一条，所以注意消息的口吻。禁止超出这个时间范围，禁止出现比现在时间还要晚的时间，如果对方离开的时间只有几个小时或者只是晚上到白天(睡觉)，可以不用发很多条消息。`;
                }

                const formatMessageContent = (msg, senderName, myName) => { 
                    const recipientName = msg.cardData?.recipientName || '对方'; // 修复：定义 recipientName
                    if (msg.isRetracted) return `{${(msg.type === 'sent') ? myName : senderName}|${msg.content}}`;
                    if (msg.segmentType === 'inner_voice') return `【心声|${senderName}|${msg.content}】`;
                    switch (msg.segmentType) {
                        case 'text': return `[${senderName}|${msg.content}]`;
                        case 'emoji-image': return `<${senderName}|${msg.content}>`;
                        case 'voice': return `[${senderName}|语音|${msg.cardData.duration}|${msg.cardData.content}]`;
                        case 'quote': return `[${senderName}|引用|${msg.cardData.quotedName}|${msg.cardData.quotedContent}|${msg.cardData.newContent}]`;
                        case 'transfer-return': return `[${senderName}|退还转账|${msg.cardData.recipientName}|${msg.cardData.amount}]`;
                        case 'transfer': return `[${senderName}|转账|${msg.cardData.recipientName}|${msg.cardData.amount}|${msg.cardData.note || ''}]`;
                        case 'red-packet': return `[${senderName}|红包|${msg.cardData.title}|￥${msg.cardData.amount.toFixed(2)}|${msg.cardData.count}]`;
                        case 'image_simulated': return `[${senderName}|图片描述|${msg.cardData.description}]`;
                        case 'gift': return `<礼物>\n发送方：${senderName}\n接收方：${recipientName}\n礼物名称：${msg.cardData.name}\n礼物价格：${msg.cardData.price}\n礼物介绍：${msg.cardData.description || '无'}\n寄语：${msg.cardData.message}\n</礼物>`;
                        case 'system': return msg.forAi ? `<系统>${msg.content}</系统>`: '';
                        case 'narrator': return `<旁白>${msg.content}</旁白>`;
                        case 'moment_forward': return msg.content; 
                        default: return '';
                    }
                };
                const buildHistoryBlock = (history, title, turnLimit) => { 
                    if (!history || history.length === 0) return '';
                    let promptHistoryTurns = [];
                    for (const msg of history.filter(m => m.segmentType !== 'essay')) {
                        const sender = (msg.type === 'sent') ? myProfile : allContacts.find(c => c.id === msg.senderId);
                        if (!sender && msg.segmentType !== 'system') continue;
                        const formattedContent = formatMessageContent(msg, sender ? sender.name : '系统', myProfile.name);
                        if (!formattedContent) continue;
                        const role = msg.type === 'sent' ? 'player' : 'ai';
                        if (promptHistoryTurns.length > 0 && promptHistoryTurns[promptHistoryTurns.length - 1].role === role) {
                            promptHistoryTurns[promptHistoryTurns.length - 1].content += formattedContent;
                        } else {
                            promptHistoryTurns.push({ role: role, time: Utils.formatTimestampForPrompt(msg.timestamp), content: formattedContent });
                        }
                    }
                    const finalTurns = turnLimit ? promptHistoryTurns.slice(-turnLimit) : promptHistoryTurns;
                    if (finalTurns.length === 0) return '';
                    return `--- ${title} ---\n${finalTurns.map(turn => JSON.stringify(turn)).join('\n')}\n`;
                };
                
                let historyPrompt = "作为参考，以下是你们之前的聊天记录：\n";

                if (chatSettings.memoryInterconnection) {
                     if (isGroup) {
                        historyPrompt += buildHistoryBlock(fullHistory, '当前群聊记录', historyLength); // 修复：使用 fullHistory
                        let privateContext = '--- 以下是各角色的私聊记忆 (仅角色自己可见) ---\n';
                        for (const member of chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean)) {
                            const privateChatHistory = await DBHelper.getMessages(member.id, 20);
                            if (privateChatHistory.length > 0) privateContext += buildHistoryBlock(privateChatHistory, `与 ${member.name} 的私聊记录`, 10);
                        }
                        historyPrompt += privateContext;
                    } else {
                        historyPrompt += buildHistoryBlock(fullHistory, '当前私聊记录', historyLength); // 修复：使用 fullHistory
                        const relatedGroups = allGroups.filter(g => g.members.includes(chatEntity.id));
                        let groupContext = '--- 以下是相关的群聊记忆 ---\n';
                        for (const group of relatedGroups) {
                            const groupChatHistory = await DBHelper.getMessages(group.id, 20);
                            if (groupChatHistory.length > 0) groupContext += buildHistoryBlock(groupChatHistory, `群聊“${group.name}”的记录`, 8);
                        }
                        historyPrompt += groupContext;
                    }
                } else {
                    historyPrompt += buildHistoryBlock(fullHistory, '当前聊天记录', historyLength); // 修复：使用 fullHistory
                }

                const taskPrompt = isGroup ? 
                    `你现在正在一个名为“${chatEntity.name}”的群聊中，需要同时扮演以下几位角色：${chatEntity.members.map(id => allContacts.find(c => c.id === id)?.name).filter(Boolean).join('、')}。` :
                    `你现在正在扮演“${chatEntity.name}”，与“${myProfile.name}”进行一对一私聊。`;

                const characterInfoPrompt = isGroup ?
                    `群聊成员资料如下：\n` + chatEntity.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean).map(m => `角色名: ${m.name}\n性别: ${m.gender}\n背景: ${m.background || '无'}`).join('\n---\n') :
                    `你的角色资料如下：\n角色名: ${chatEntity.name}\n性别: ${chatEntity.gender}\n背景: ${chatEntity.background || '无'}`;
                
                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                const emojiListString = Object.entries(appState.aiEmojiMap).map(([id, desc]) => `${id}：${desc}`).join('\n');
                const finalPrompt = [
                    situationPrompt,
                    taskPrompt,
                    characterInfoPrompt,
                    playerInfoPrompt, 
                    historyPrompt,
                    AIHandler.activeReplyPromptTpl.replace('{EMOJI_LIST}', emojiListString).replace('{PLAYER_NAME}', myProfile.name)
                ].join('\n\n');

                console.log(`--- ACTIVE REPLY PROMPT SENT TO AI ---\n`, finalPrompt);
                return finalPrompt;
            },
            async handleRegenerateRequest(messageId) {
                const confirmation = await new Promise(resolve => {
                    UIManager.showModal({
                        title: "重新生成回复",
                        body: "<p>你确定要让AI重新生成上一条回复吗？这会删除AI的最新几条消息。</p>",
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => { UIManager.hideModal(); resolve(false); } },
                            { text: '确定', class: 'btn-primary', handler: () => { UIManager.hideModal(); resolve(true); } }
                        ]
                    });
                });

                if (!confirmation) return;

                const chatId = appState.currentChatId;
                const allMessages = await DBHelper.getMessages(chatId, 1000, Date.now()); 
                if (!allMessages || allMessages.length === 0) return;

                const playerMessageIndex = allMessages.findIndex(m => m.messageId === messageId);
                if (playerMessageIndex === -1) return;

                const messagesToDelete = [];
                for (let i = playerMessageIndex + 1; i < allMessages.length; i++) {
                    if (allMessages[i].type === 'received') {
                        messagesToDelete.push(allMessages[i].messageId);
                    }
                }

                for (const id of messagesToDelete) {
                    await DBHelper.delete('messages', id);
                }
                
                if (messagesToDelete.length > 0) {
                     const remainingMessages = allMessages.filter(m => !messagesToDelete.includes(m.messageId));
                     if (remainingMessages.length > 0) {
                        const lastMessage = remainingMessages[remainingMessages.length - 1];
                        await UIManager.updateChatMetadata(chatId, lastMessage);
                     } else {
                        await DBHelper.delete('chatMetadata', chatId);
                     }
                }

                for (const id of messagesToDelete) {
                    const elementToDelete = $(`#${id}`);
                    if (elementToDelete) {
                        elementToDelete.remove();
                    }
                }

                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const regenerationInstruction = `\n---
紧急指令：玩家（“${myProfile.name}”）要求你重新生成刚才的回复，因为你之前的回复可能“不符合角色性格(OOC)”或“未使用正确的格式”。请你仔细复核你的角色设定和所有回复规则，然后给出一个更优质的回复。
---`;
                
                const basePrompt = await this.buildPrompt();
                const newPrompt = basePrompt + regenerationInstruction;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = chatId.startsWith('group-');
                let typingTarget;
                const typingBubbleId = Utils.generateId('typing');

                if (isGroup) {
                    typingTarget = await DBHelper.get('groups', chatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    }
                } else {
                    chatTypingIndicator.style.display = 'block';
                    typingTarget = await DBHelper.get('contacts', appState.currentChatId);
                    if (typingTarget) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(newPrompt, this.abortController.signal);
                    console.log("--- AI 原始回复 ---\n", aiRawResponse);

                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AI回复失败: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },

async buildSummaryPrompt(chatId) {
    const isGroup = chatId.startsWith('group-');
    const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
    if (!entity) return null;

    const myProfile = await EventManager.getPlayerProfileForContext(chatId);
    const allContacts = await DBHelper.getAll('contacts');
    
    // 获取最近60条消息以确保能组成约30个回合
    const history = await DBHelper.getMessages(chatId, 60); 
    const turns = this.buildTurnsFromHistory(history, allContacts, myProfile);
    const last30turns = turns.slice(-30);
    if (last30turns.length === 0) return null; // 如果没有聊天记录，不进行总结

    const previousSummary = entity.autoSummary || '';

    let prompt = `你是一个聊天记录总结助手。请根据“过往总结”（如果有）和“最新聊天记录”，为我生成一段不超过350个字的新总结。新的总结需要融合旧总结的核心内容和新聊天记录的要点，保持故事的连贯性。请重点关注时间的发生时间、人物关系的变化、关键事件的进展、以及重要信息的交换。内容应客观、信息丰富且凝练。\n\n`;
    
    if (previousSummary) {
        prompt += `--- 过往总结 ---\n${previousSummary}\n\n`;
    }
    
    prompt += `--- 最新聊天记录 (最近30轮) ---\n${last30turns.map(turn => `${turn.role}: ${turn.content}`).join('\n')}\n\n`;
    prompt += `--- 旧的总结 ---\n`;

    return prompt;
},

async handleAutoSummaryRequest(chatId) {
    if (appState.isSummarizing[chatId]) {
        console.log("已在总结中，跳过此次请求。");
        return;
    }

    try {
        appState.isSummarizing[chatId] = true;
        // 如果模态框正好打开，刷新它以显示加载状态
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }

        const prompt = await this.buildSummaryPrompt(chatId);
        if (!prompt) {
            console.log("构建总结Prompt失败或无需总结。");
            return;
        }

        console.log("--- SUMMARY PROMPT SENT TO AI ---\n", prompt);
        const summaryResponse = await this.getApiResponse(prompt, new AbortController().signal);

        if (summaryResponse) {
            const isGroup = chatId.startsWith('group-');
            const storeName = isGroup ? 'groups' : 'contacts';
            const entity = await DBHelper.get(storeName, chatId);
            
            // 确保不超过350字
            entity.autoSummary = summaryResponse.trim().slice(0, 350);
            
            await DBHelper.put(storeName, entity);
            console.log("新总结已保存:", entity.autoSummary);
        }

    } catch (error) {
        console.error("自动总结失败:", error);
    } finally {
        appState.isSummarizing[chatId] = false;
        // 如果模态框仍然打开，刷新它以移除加载状态
        if ($('#auto-summary-content')) {
            const isGroup = chatId.startsWith('group-');
            UIManager.showAutoSummaryModal(chatId, isGroup);
        }
    }
},

            async handleOpeningSceneRequest(scene) {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                
                aiRequestBtn.innerHTML = '<i class="fas fa-stop-circle"></i>';
                aiRequestBtn.disabled = false;

                const isGroup = !!scene.groupId;
                const chatId = isGroup ? scene.groupId : scene.contactId;
                const myProfile = await EventManager.getPlayerProfileForContext(chatId);
                const allContacts = await DBHelper.getAll('contacts');

                let taskPrompt, characterInfoPrompt, finalPrompt;

                if (isGroup) {
                    const group = await DBHelper.get('groups', scene.groupId);
                    const members = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                    taskPrompt = `你现在正在一个名为“${group.name}”的群聊中，需要同时扮演以下几位角色：${members.map(m => m.name).join('、')}。`;
                    characterInfoPrompt = `群聊成员资料如下：\n` + members.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                } else {
                    const contact = await DBHelper.get('contacts', scene.contactId);
                    taskPrompt = `你现在正在扮演“${contact.name}”，与“${myProfile.name}”（也就是玩家）进行一对一私聊。`;
                    characterInfoPrompt = `你的角色资料如下：\n角色名: ${contact.name}\n性别: ${contact.gender}\n喜好: ${contact.likes || '无'}\n厌恶: ${contact.dislikes || '无'}\n习惯: ${contact.habits || '无'}\n背景: ${contact.background || '无'}`;
                }
                
                const playerInfoPrompt = `玩家（“${myProfile.name}”）的信息如下：\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;
                const openingInstruction = `\n---
紧急指令：这是一个全新的开场。请根据以下“开场白”内容，让角色开始对话，营造出开场氛围。不要提及“开场白”这三个字，直接开始表演。
开场白内容：
“${scene.content}”
---`;
                const formatPrompt = AIHandler.formatPromptTpl.replace('{PLAYER_NAME}', myProfile.name);

                if (isGroup) {
                    finalPrompt = [taskPrompt, characterInfoPrompt, playerInfoPrompt, openingInstruction, formatPrompt, AIHandler.groupChatRules].join('\n\n');
                } else {
                    finalPrompt = [taskPrompt, characterInfoPrompt, playerInfoPrompt, openingInstruction, formatPrompt].join('\n\n');
                }
                
                console.log("--- OPENING SCENE PROMPT SENT TO AI ---\n", finalPrompt);
                
                const typingTarget = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const typingBubbleId = Utils.generateId('typing');
                if (typingTarget) {
                     if (isGroup) {
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId, isGroupTyping: true }, typingTarget, true);
                    } else {
                        chatTypingIndicator.style.display = 'block';
                        UIManager.addMessageToDOM({ type: 'received', messageId: typingBubbleId }, typingTarget, true);
                    }
                }

                try {
                    const aiRawResponse = await this.getApiResponse(finalPrompt, this.abortController.signal);
                    console.log("--- AI 原始回复 ---\n", aiRawResponse);
                    await this.parseAndDisplayAIResponse(aiRawResponse, chatId);
                } catch (error) {
                    if (error.name !== 'AbortError') this.showError(`AI回复失败: ${error.message}`);
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    const typingBubble = $(`#${typingBubbleId}`);
                    if (typingBubble) typingBubble.remove();
                    if (!isGroup) chatTypingIndicator.style.display = 'none';
                    aiRequestBtn.innerHTML = '<i class="fas fa-feather-alt"></i>';
                }
            },

            async findAndClaimTransfer(senderName, recipientName, amount, chatId) {
                const history = await DBHelper.getMessages(chatId, 30);
                const targetTransfer = history.reverse().find(msg => 
                    msg.segmentType === 'transfer' &&
                    !msg.cardData.isClaimed &&
                    msg.cardData.recipientName === recipientName &&
                    msg.cardData.amount === `￥${amount.toFixed(2)}` 
                );

                if (targetTransfer) {
                    targetTransfer.cardData.isClaimed = true;
                    await DBHelper.put('messages', targetTransfer);
                    const bubble = $(`#${targetTransfer.messageId} .bubble`);
                    if (bubble) bubble.classList.add('claimed');
                    console.log(`Transfer ${targetTransfer.messageId} has been claimed.`);
                } else {
                    console.warn(`Could not find matching unclaimed transfer for ${recipientName} from ${senderName}.`);
                }
            },
            async parseAndDisplayAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];
                let newGroupNameFromAI = null;
                const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId };

                const createBaseMessage = (senderName) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`未在通讯录中找到名为 "${senderName}" 的角色，跳过此消息。`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId,
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId,
                        senderInfo: sender,
                    };
                };

                const allMessageRegex = /<旁白>([\s\S]*?)<\/旁白>|<系统>([\s\S]*?)<\/系统>|<私聊>([\s\S]*?)<\/私聊>|<礼物>([\s\S]*?)<\/礼物>|『([^』]+?)』|【([^】]+?)】|「([^」]+?)」|{([^{}]+?)}|\[([^\[\]]+?)\]|<((?!系统|私聊)[^>]+?)>/g;

                const messagesToSave = [];

                text.replace(allMessageRegex, (match, narratorContent, systemContent, privateContent, giftContent, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    if (narratorContent !== undefined) {
                        const message = { 
                            messageId: Utils.generateId('msg'), 
                            chatId: chatId,
                            timestamp: baseTimestamp + timestampOffset++,
                            type: 'received',
                            content: narratorContent.trim(), 
                            segmentType: 'narrator' 
                        };
                        messagesToSave.push(message);
                        displayableMessages.push(message);
                    } else if (systemContent !== undefined) {
                        const content = systemContent.trim();
                        const nameChangeParts = content.match(/(.+?)\s*修改群名为\s*(.*)$/);
                        if (nameChangeParts && nameChangeParts.length === 3) {
                            const rawNewName = nameChangeParts[2].trim();
                            const parsedNewName = rawNewName.replace(/^["“]|["”]$/g, '');
                            newGroupNameFromAI = parsedNewName;

                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                chatId: chatId,
                                timestamp: baseTimestamp + timestampOffset++,
                                type: 'received',
                                content: `${nameChangeParts[1].trim()} 修改群名为 ${parsedNewName}`, 
                                segmentType: 'system', 
                                forAi: true 
                            };
                            messagesToSave.push(systemMessage);
                            displayableMessages.push(systemMessage);
                        }
                    } else if (privateContent !== undefined) {
                        const innerMatch = privateContent.match(/\[([^|]+?)\|(.+?)\]/);
                        if (innerMatch) {
                            const senderName = innerMatch[1].trim();
                            const msgContent = innerMatch[2].trim();
                            const sender = contacts.find(c => c.name === senderName);
                            if (sender) {
                                (async () => {
                                    const privateMessage = { messageId: Utils.generateId('msg'), chatId: sender.id, senderId: sender.id, content: msgContent, timestamp: Date.now(), type: 'received', isUnread: true, isPrivateInGroup: true, senderInfo: sender, segmentType: 'text' };
                                    await DBHelper.put('messages', privateMessage);
                                    await UIManager.updateChatMetadata(sender.id, privateMessage, 1);
                                    UIManager.showTopNotification(privateMessage);
                                    UIManager.renderMessagesListPage(); // 刷新消息列表以显示未读
                                })();
                            }
                        }
                    } else if (giftContent !== undefined) {
                        const content = giftContent.trim();
                        const senderMatch = content.match(/发送方：(.+)/);
                        const recipientMatch = content.match(/接收方：(.+)/);
                        const nameMatch = content.match(/礼物名称：(.+)/);
                        const priceMatch = content.match(/礼物价格：(.+)/);
                        const descMatch = content.match(/礼物介绍：([\s\S]+?)寄语：/); // 非贪婪匹配
                        const messageMatch = content.match(/寄语：(.+)/);

                        const senderName = senderMatch ? senderMatch[1].trim() : null;
                        if (!senderName) return;

                        const baseMessage = createBaseMessage(senderName);
                        if (baseMessage) {
                            baseMessage.segmentType = 'gift';
                            baseMessage.content = `[礼物] ${nameMatch ? nameMatch[1].trim() : '一份礼物'}`;
                            baseMessage.cardData = {
                                recipientName: recipientMatch ? recipientMatch[1].trim() : '你',
                                name: nameMatch ? nameMatch[1].trim() : '礼物',
                                price: priceMatch ? priceMatch[1].trim() : '0.00',
                                description: descMatch ? descMatch[1].trim() : '',
                                message: messageMatch ? messageMatch[1].trim() : '一份心意。',
                                image: 'https://cfimg.200996.xyz/file/1752744415891_retouch_2025071717241258.png' // AI送礼物的默认图片
                            };
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else if (cardContent !== undefined) {
                        const parts = cardContent.split('|').map(p => p.trim());
                        const [senderName, shareType, title, summary, details] = parts;
                        const baseMessage = createBaseMessage(senderName);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[卡片] ${title}`;
                            baseMessage.cardData = { shareType, title, summary, details, isExpanded: false };
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    } else if (innerVoiceContent !== undefined) { // 捕获【】格式
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender && parts.length === 3) {
                            if (parts[0] === '心声') {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'inner_voice' });
                            } else if (parts[0] === '随笔') { // 兼容【随笔】格式
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' });
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                    } else if (essayContent !== undefined) { // 捕获「」格式
                        const parts = essayContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender && parts[0] === '随笔' && parts.length === 3) {
                            messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' });
                            UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                        }
                    } else { 
                        let bracketType, innerContent;
                        if (retractedContent) { bracketType = '{'; innerContent = retractedContent; }
                        else if (standardContent) { bracketType = '['; innerContent = standardContent; }
                        else if (emojiContent) { bracketType = '<'; innerContent = emojiContent; }
                        else { return; } 

                        if (bracketType === '<' && innerContent.startsWith('随笔|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', isUnread: false, segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            return; 
                        }

                        const parts = innerContent.split('|').map(p => p.trim());
                        const [senderName] = parts;
                        const baseMessage = createBaseMessage(senderName);
                        if (!baseMessage) return;

                        if (bracketType === '<') {
                            const emojiSetting = baseMessage.senderInfo.allowEmoji;
                            let shouldDisplay = true;

                            if (emojiSetting === 'off') {
                                shouldDisplay = false;
                            } else if (emojiSetting === 'prob') {
                                shouldDisplay = Math.random() < 0.5;
                            }
                            
                            if (!shouldDisplay) {
                                return; // 直接跳过此表情消息，不进行处理
                            }

                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else { // 处理 '{' 和 '['
                            baseMessage.isRetracted = bracketType === '{';
                            baseMessage.toBeRetracted = bracketType === '{';

                            // 检查是否允许撤回
                            if (baseMessage.toBeRetracted && baseMessage.senderInfo.allowRetraction === false) {
                                baseMessage.toBeRetracted = false; // 不再处理为待撤回状态
                                baseMessage.isRetracted = false; // 确保它不是已撤回状态
                            }
                            
                            // 正常的其他消息类型判断
                            if (parts.length === 2) { baseMessage.segmentType = 'text'; baseMessage.content = parts[1]; }
                            else if (parts[1] === '领取转账') { 
                                baseMessage.segmentType = 'transfer-receipt'; 
                                baseMessage.content = `${parts[2]}已收款${parts[3]}`; 
                                baseMessage.cardData = { recipientName: parts[0], senderName: parts[2], amount: parts[3] }; 
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('￥', '')), chatId);
                            }
                            else if (parts[1] === '退还转账') {
                                baseMessage.segmentType = 'transfer-return';
                                baseMessage.content = `${parts[0]}退还了转账${parts[3]}`;
                                baseMessage.cardData = { recipientName: parts[2], senderName: parts[0], amount: parts[3] };
                                this.findAndClaimTransfer(parts[2], parts[0], parseFloat(parts[3].replace('￥', '')), chatId);
                            }
                            else if (parts[1] === '语音') { baseMessage.segmentType = 'voice'; baseMessage.content = `[语音] ${parts[3]}`; baseMessage.cardData = { duration: parts[2], content: parts[3] }; }
                            else if (parts[1] === '引用') { baseMessage.segmentType = 'quote'; baseMessage.content = `[引用] ${parts[4]}`; baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] }; }
                            else if (parts[1] === '转账') { baseMessage.segmentType = 'transfer'; baseMessage.content = `[转账] ${parts[3]}`; baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false }; }
                            else if (parts[1] === '红包') { baseMessage.segmentType = 'red-packet'; baseMessage.content = `[红包] ${parts[2]}`; baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('￥', '')), count: parseInt(parts[4]), claimedBy: [] }; }
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage);
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                for (const msg of messagesToSave) {
                    await DBHelper.put('messages', msg);
                }

                if (newGroupNameFromAI && chatId.startsWith('group-')) {
                    const group = await DBHelper.get('groups', chatId);
                    if (group) {
                        group.name = newGroupNameFromAI;
                        await DBHelper.put('groups', group);
                        if (chatId === appState.currentChatId) {
                            chatTitle.textContent = newGroupNameFromAI;
                        }
                    }
                }

                if (displayableMessages.length > 0) {
                    chatMetadata.lastAiReplyTimestamp = Date.now();
                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }

                // 获取循环开始前的最后一条消息时间
                const lastMessageBeforeLoop = (await DBHelper.getMessages(chatId, 1, baseTimestamp)).pop();
                let lastTimestamp = lastMessageBeforeLoop ? lastMessageBeforeLoop.timestamp : 0;
                
                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    if (chatId === appState.currentChatId) {
                        // 新增：时间戳判断逻辑
                        if (lastTimestamp > 0 && msg.timestamp - lastTimestamp > 5 * 60 * 1000) {
                            const timeDiv = UIManager.createTimeDividerElement(msg.timestamp);
                            chatArea.appendChild(timeDiv);
                        }
                        
                        if (msg.segmentType === 'system') {
                            const notice = document.createElement('div');
                            notice.className = 'system-notice'; notice.id = msg.messageId; notice.textContent = msg.content;
                            chatArea.appendChild(notice);
                        } else if (msg.segmentType === 'narrator') {
                            const narratorNotice = await UIManager.createNarratorNoticeElement(msg);
                            chatArea.appendChild(narratorNotice);
                        } else {
                             await UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);
                             if (msg.toBeRetracted) {
                                const retractDelay = Math.random() * 1000 + 1000;
                                setTimeout(async () => {
                                    const msgToRetract = await DBHelper.get('messages', msg.messageId);
                                    if (msgToRetract) {
                                        msgToRetract.isRetracted = true;
                                        await DBHelper.put('messages', msgToRetract);
                                        const bubbleEl = $(`#${msg.messageId}`);
                                        if (bubbleEl) {
                                            const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                            bubbleEl.replaceWith(retractionNotice);
                                        }
                                    }
                                }, retractDelay);
                            }
                        }
                        chatArea.scrollTop = chatArea.scrollHeight;
                        lastTimestamp = msg.timestamp; // 更新最后一条消息的时间

                    } else {
                        if (msg.segmentType !== 'system' && msg.segmentType !== 'narrator' && !msg.isRetracted) {
                            UIManager.showTopNotification(msg);
                        }
                    }
                }
            },

            async parseAndDisplayActiveAIResponse(text, chatId) {
                const contacts = await DBHelper.getAll('contacts');
                const baseTimestamp = Date.now();
                let timestampOffset = 0;
                const displayableMessages = [];

                const createBaseMessage = (senderName, displayTimestamp) => {
                    const sender = contacts.find(c => c.name === senderName);
                    if (!sender) {
                        console.warn(`未找到角色 "${senderName}"，跳过此主动回复消息。`);
                        return null;
                    }
                    return {
                        messageId: Utils.generateId('msg'),
                        chatId: chatId, // 修复：为主动回复消息添加chatId，确保数据正确关联
                        senderId: sender.id,
                        timestamp: baseTimestamp + timestampOffset++,
                        type: 'received',
                        isUnread: chatId !== appState.currentChatId, 
                        senderInfo: sender,
                        isAutoReply: true, // 确保应用主动回复样式
                        displayTimestamp: displayTimestamp,
                    };
                };

                const allMessageRegex = /『([^』]+?)』|【([^】]+?)】|「([^」]+?)」|{([^{}]+?)}|\[([^\[\]]+?)\]|<([^>]+?)>/g;

                const messagesToSave = []; // 使用一个临时数组来收集所有要保存的消息

                text.replace(allMessageRegex, (match, cardContent, innerVoiceContent, essayContent, retractedContent, standardContent, emojiContent) => {
                    
                    // 新增：合并处理【心声】和【随笔】
                    if (innerVoiceContent) { 
                        const parts = innerVoiceContent.split('|').map(p => p.trim());
                        const sender = contacts.find(c => c.name === parts[1]);
                        if (sender) {
                            if (parts[0] === '心声' && parts.length === 3) {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'inner_voice' });
                            } else if (parts[0] === '随笔' && parts.length === 3) {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                        return; 
                    }
                    // 新增：合并处理「随笔」
                    if (essayContent) {
                        const parts = essayContent.split('|').map(p => p.trim());
                        if (parts[0] === '随笔' && parts.length === 3) {
                            const sender = contacts.find(c => c.name === parts[1]);
                            if (sender) {
                                messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: parts[2], timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                            }
                        }
                        return; 
                    }

                    let parts, senderName, displayTimestamp, baseMessage;

                    if (cardContent !== undefined) {
                        parts = cardContent.split('|').map(p => p.trim());
                        if (parts.length < 5) return;
                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (baseMessage) {
                            baseMessage.segmentType = 'card';
                            baseMessage.content = `[卡片] ${parts[2]}`;
                            baseMessage.cardData = { shareType: parts[1], title: parts[2], summary: parts[3], details: parts[4], isExpanded: false };
                            messagesToSave.push(baseMessage); // 修改处
                            displayableMessages.push(baseMessage);
                        }
                    } else {
                        let innerContent, bracketType;
                        if (retractedContent) { innerContent = retractedContent; bracketType = '{'; }
                        else if (standardContent) { innerContent = standardContent; bracketType = '['; }
                        else if (emojiContent) { innerContent = emojiContent; bracketType = '<'; }
                        else { return; }

                        if (bracketType === '<' && innerContent.startsWith('随笔|')) {
                            const parts = innerContent.split('|').map(p => p.trim());
                            if (parts.length >= 3) {
                                const senderName = parts[1];
                                const msgContent = parts.slice(2).join('|');
                                const sender = contacts.find(c => c.name === senderName);
                                if (sender) {
                                    messagesToSave.push({ messageId: Utils.generateId('msg'), chatId: chatId, senderId: sender.id, content: msgContent, timestamp: baseTimestamp + timestampOffset++, type: 'received', segmentType: 'essay' });
                                    UIManager.showEssayNotification(sender.remark || sender.name, sender.id);
                                }
                            }
                            return; 
                        }

                        parts = innerContent.split('|').map(p => p.trim());
                        if (parts.length < 2) return;

                        senderName = parts[0];
                        displayTimestamp = parts.pop();
                        baseMessage = createBaseMessage(senderName, displayTimestamp);
                        if (!baseMessage) return;
                        
                        baseMessage.chatId = chatId;
                        
                        if (bracketType === '{') {
                            baseMessage.isRetracted = true;
                            baseMessage.toBeRetracted = true;
                        }

                        if (bracketType === '<') {
                            baseMessage.segmentType = 'emoji-image';
                            baseMessage.content = parts[1];
                        } else if (bracketType === '[') {
                            const typeKeyword = parts[1];
                            switch (typeKeyword) {
                                case '语音':
                                    baseMessage.segmentType = 'voice';
                                    baseMessage.content = `[语音] ${parts[3]}`;
                                    baseMessage.cardData = { duration: parts[2], content: parts[3] };
                                    break;
                                case '引用':
                                    baseMessage.segmentType = 'quote';
                                    baseMessage.content = `[引用] ${parts[4]}`;
                                    baseMessage.cardData = { quotedName: parts[2], quotedContent: parts[3], newContent: parts[4] };
                                    break;
                                case '转账':
                                    baseMessage.segmentType = 'transfer';
                                    baseMessage.content = `[转账] ${parts[3]}`;
                                    baseMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                                    break;
                                case '红包':
                                    baseMessage.segmentType = 'red-packet';
                                    baseMessage.content = `[红包] ${parts[2]}`;
                                    baseMessage.cardData = { title: parts[2], amount: parseFloat(parts[3].replace('￥', '')), count: parseInt(parts[4]), claimedBy: [] };
                                    break;
                                default:
                                    baseMessage.segmentType = 'text';
                                    baseMessage.content = parts.slice(1).join('|');
                                    break;
                            }
                        } else {
                            baseMessage.segmentType = 'text';
                            baseMessage.content = parts.slice(1).join('|');
                        }

                        if (baseMessage.segmentType) {
                            messagesToSave.push(baseMessage); // 修改处
                            displayableMessages.push(baseMessage);
                        }
                    }
                });

                 // 将所有解析出的消息（包括心声和随笔）批量存入数据库
                for (const msg of messagesToSave) {
                    await DBHelper.put('messages', msg);
                }

                if (displayableMessages.length > 0 || messagesToSave.some(m => m.segmentType === 'inner_voice' || m.segmentType === 'essay')) {
                    const chatMetadata = await DBHelper.get('chatMetadata', chatId) || { chatId: chatId, unreadCount: 0 };
                    chatMetadata.lastAiReplyTimestamp = Date.now();

                    // 新增：如果生成了可见消息，也一并更新lastMessage
                    const lastDisplayableMsg = displayableMessages.length > 0 ? displayableMessages[displayableMessages.length - 1] : null;
                    if (lastDisplayableMsg) {
                        chatMetadata.lastMessage = lastDisplayableMsg;
                        chatMetadata.lastMessageTimestamp = lastDisplayableMsg.timestamp;
                    }

                    await DBHelper.put('chatMetadata', chatMetadata);
                }

                if (displayableMessages.length > 0) {
                    const lastDisplayableMsg = displayableMessages[displayableMessages.length - 1];
                    const isUnread = chatId !== appState.currentChatId;
                    await UIManager.updateChatMetadata(chatId, lastDisplayableMsg, isUnread ? displayableMessages.length : 0);
                }

                for (const msg of displayableMessages) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 400 + 200));

                    if (chatId === appState.currentChatId) {
                        UIManager.addMessageToDOM(msg, msg.senderInfo, false, true);

                        if (msg.toBeRetracted) {
                            const retractDelay = Math.random() * 1000 + 1000;
                            setTimeout(async () => {
                                const chatToUpdate = await DBHelper.get('chats', chatId);
                                const msgToRetract = chatToUpdate.history.find(m => m.messageId === msg.messageId);
                                if (msgToRetract) {
                                    msgToRetract.isRetracted = true;
                                    await DBHelper.put('chats', chatToUpdate);
                                    const bubbleEl = $(`#${msg.messageId}`);
                                    if (bubbleEl) {
                                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, msg.senderInfo);
                                        bubbleEl.replaceWith(retractionNotice);
                                    }
                                }
                            }, retractDelay);
                        }
                    } else {
                        UIManager.showTopNotification(msg);
                    }
                }
            },

            showError(message) {
                 UIManager.showModal({
                    title: "错误",
                    body: `<p>${message}</p>`,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleMomentsRefreshRequest() {
                if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const refreshBtn = $('#moments-refresh-btn i');
                refreshBtn.classList.add('fa-spin');

                try {
                    const prompt = await this.buildMomentsRefreshPrompt();
                    if (!prompt) {
                        UIManager.showToast("无法生成动态：圈子信息不完整。");
                        return;
                    }
                    
                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI 朋友圈动态 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsResponse(aiRawResponse);
                    
                    
                    const circle = await DBHelper.get('circles', appState.currentCircleId);
                    if (circle) {
                        circle.lastRefreshed = Date.now();
                        await DBHelper.put('circles', circle);
                    }

                } catch (error) {
                    if (error.name !== 'AbortError') {
                        console.error("朋友圈动态生成失败:", error);
                        this.showError(`动态生成失败: ${error.message}`);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    refreshBtn.classList.remove('fa-spin');
                }
            },
            
            async _getBoundPromptsForMoments(circle, playerInputText = '') {
                if (!circle || !circle.boundPromptFolderIds || circle.boundPromptFolderIds.length === 0) {
                    return '';
                }

                const allFolders = await DBHelper.getAll('promptFolders');
                const allPrompts = await DBHelper.getAll('prompts');

                const activeBoundFolders = allFolders.filter(f => circle.boundPromptFolderIds.includes(f.id) && f.isActive);
                if (activeBoundFolders.length === 0) return '';
                
                const activeBoundFolderIds = activeBoundFolders.map(f => f.id);
                const relevantPrompts = allPrompts.filter(p => activeBoundFolderIds.includes(p.folderId) && p.isActive);

                const promptsToInject = relevantPrompts
                    .filter(p => 
                        p.type === 'explicit' || 
                        (p.type === 'implicit' && playerInputText && JSON.parse(p.keywords).some(kw => playerInputText.includes(kw)))
                    )
                    .map(p => p.content);

                if (promptsToInject.length > 0) {
                    return `\n--- 附加风格要求 (来自绑定的提示词) ---\n${promptsToInject.join('\n\n')}\n---`;
                }
                return '';
            },
            
            async handleMomentsCommentRequest(momentId) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions'); 
                
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    
                    commentsSection.style.display = 'block'; 
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = '朋友们正在赶来评论...';


                try {
                    const prompt = await this.buildMomentsCommentPrompt(momentId);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI 朋友圈评论 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsCommentsResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("朋友圈评论生成失败:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async handleMomentsPlayerCommentResponse(momentId, playerComment) {
                 if (this.isAwaitingResponse) return;

                this.isAwaitingResponse = true;
                this.abortController = new AbortController();
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const commentsSection = postElement.querySelector('.post-interactions');
                
                let typingIndicator = commentsSection.querySelector('.post-comment-typing-indicator');
                if (!typingIndicator) {
                    typingIndicator = document.createElement('div');
                    typingIndicator.className = 'post-comment-typing-indicator';
                    commentsSection.insertBefore(typingIndicator, commentsSection.querySelector('.comment-input-wrapper'));
                }
                typingIndicator.textContent = '朋友们正在赶来评论...';
                commentsSection.style.display = 'block'; 

                try {
                    const prompt = await this.buildMomentsPlayerCommentPrompt(momentId, playerComment);
                    if (!prompt) return;

                    const aiRawResponse = await this.getApiResponse(prompt, this.abortController.signal);
                    console.log("--- AI 朋友圈玩家评论回复 (原始) ---\n", aiRawResponse);
                    await this.parseAndDisplayMomentsPlayerCommentResponse(momentId, aiRawResponse);

                } catch (error) {
                     if (error.name !== 'AbortError') {
                        console.error("朋友圈AI回复玩家评论失败:", error);
                    }
                } finally {
                    this.isAwaitingResponse = false;
                    this.abortController = null;
                    if(typingIndicator) typingIndicator.remove();
                }
            },

            async buildMomentsRefreshPrompt() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                
                
                const validMemberIds = circle.memberIds.filter(id => allContacts.some(c => c.id === id));
                if (validMemberIds.length !== circle.memberIds.length) {
                    circle.memberIds = validMemberIds; 
                    await DBHelper.put('circles', circle);
                    UIManager.showToast("已自动移除圈子中不存在的好友。");
                }
                if(validMemberIds.length === 0) return null;

                
                const shuffled = validMemberIds.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedMemberIds = shuffled.slice(0, Math.min(numToSelect, validMemberIds.length));
                const selectedMembers = selectedMemberIds.map(id => allContacts.find(c => c.id === id));
                
                const myProfile = await EventManager.getPlayerProfileForContext(appState.currentCircleId);
                const allGroups = await DBHelper.getAll('groups');

                
                const timeNow = new Date();
                const lastRefreshTime = new Date(circle.lastRefreshed || (Date.now() - 24*60*60*1000)); 
                const timePrompt = `现在是 ${timeNow.toLocaleString('zh-CN')}。上次生成动态的时间是 ${lastRefreshTime.toLocaleString('zh-CN')}。请确保本次生成的动态时间在此范围之内。`;

                const membersInfo = selectedMembers.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                const playerInfo = `玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;
                const extraMembersInfo = circle.extraMembers ? `这个圈子还有一些其他朋友：${circle.extraMembers}。` : '';

                let contextHistory = '';
                for (const member of selectedMembers) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `与 ${member.name} 的最新私聊 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `在群聊 ${group.name} 中 ${member.name} 的相关动态 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }
                const formatRules = `
---
朋友圈动态生成规则（非常重要！）：
1.  你将扮演 ${selectedMembers.map(m=>m.name).join('、')} 这几位角色，并为他们生成朋友圈动态。
2.  严格按照以下格式，每条动态都必须被一个 <朋友圈> 标签包裹。
3.  动态格式: 【作者角色名：动态内容|动态时间(月/日 HH:mm)】
4.  点赞格式(强制要求): 在动态格式之后，另起一行，用中文括号包裹点赞列表，格式为（已点赞：张三,李四,王五）。点赞者可以是圈内任何AI角色、额外好友”。
5.  评论格式: 〖评论者角色名：评论内容〗禁止在〖〗内嵌套〖〗
6.  你可以让角色互相评论，也可以让圈子里的额外好友（${circle.extraMembers || '无'}）参与评论。
7.  动态内容要符合角色人设，可以图文并茂（用文字描述图片），也可以只是纯文字。
8.  生成1到4条不等的动态，内容不能重复。
9.  作者和评论者的角色名必须是角色的名字（例如：${selectedMembers.map(m=>m.name).join(', ')}）、额外好友的名字或玩家的名字。
10. **严禁OOC，严禁生成格式之外的内容，严禁代替玩家进行评论或回复**。
11.举例：
<朋友圈>
【33：今天天气真不错，有没有要一起出去玩的？|7/3 8:36】
（已点赞：vv,入入）
〖vv：带我一个！〗
〖入入：我也要去——〗
</朋友圈>
---
`;
                
                const customPromptsSection = await this._getBoundPromptsForMoments(circle);

                const finalPrompt = [
                    timePrompt,
                    playerInfo,
                    `--- 圈子里的AI角色 ---\n${membersInfo}`,
                    extraMembersInfo,
                    `--- 最近的聊天记录参考 ---\n${contextHistory}`,
                    customPromptsSection,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS REFRESH PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsCommentPrompt(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                const allGroups = await DBHelper.getAll('groups'); // 新增：获取所有群聊信息

                // 准备角色资料
                const momentAuthor = allContacts.find(c => c.id === moment.authorId);
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                const otherMembers = circleMembers.filter(c => c.id !== moment.authorId);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));

                let membersToProvideInfo = [];
                if (momentAuthor) { // 如果作者是AI角色
                    membersToProvideInfo.push(momentAuthor);
                }
                membersToProvideInfo.push(...selectedRandomMembers);
                membersToProvideInfo = [...new Set(membersToProvideInfo)]; // 去重

                const membersInfo = membersToProvideInfo.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n');
                
                // 新增：获取聊天记录上下文
                let contextHistory = '';
                for (const member of membersToProvideInfo) {
                    const privateChat = await DBHelper.get('chats', member.id);
                    if (privateChat && privateChat.history.length > 0) {
                        const turns = this.buildTurnsFromHistory(privateChat.history, allContacts, myProfile);
                        const lastTwoTurns = turns.slice(-2);
                        if (lastTwoTurns.length > 0) {
                            contextHistory += `与 ${member.name} 的最新私聊 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                        }
                    }
                    const groupsWithMember = allGroups.filter(g => g.members.includes(member.id));
                    for (const group of groupsWithMember) {
                        const groupChat = await DBHelper.get('chats', group.id);
                        if (groupChat && groupChat.history.length > 0) {
                            const turns = this.buildTurnsFromHistory(groupChat.history, allContacts, myProfile);
                            const lastTwoTurns = turns.slice(-2);
                            if (lastTwoTurns.length > 0) {
                                contextHistory += `在群聊 ${group.name} 中 ${member.name} 的相关动态 (最多2轮):\n${lastTwoTurns.map(t => JSON.stringify(t)).join('\n')}\n`;
                            }
                        }
                    }
                }

                const postContentText = `玩家“${myProfile.name}”发布了一条动态：\n“${moment.content}”`;

                const privateChatRules = `
---
私聊规则:
1.  如果你想让某位角色私聊玩家，请使用 <私聊></私聊> 标签包裹私聊内容。
2.  私聊内容格式可以是: [角色名|消息内容] 或 {角色名|撤回内容} 或 [角色名|语音|时长|内容] 或 [角色名|转账|收款人|金额|备注]
3.  例如: <私聊>[三三|你刚才发的动态是什么意思？]</私聊>
---
`;

                const formatRules = `
---
朋友圈评论生成规则：
1.  你将扮演圈子里的好友，对玩家的动态进行评论和点赞。
2.  点赞格式：用中文括号包裹点赞列表，格式为（已点赞：张三,李四,王五）。点赞者可以是圈内任何AI角色或额外好友。
3.  严格按照以下格式，每条评论都是一个独立的单元: 〖评论者角色名：评论内容〗，禁止在〖〗内嵌套〖〗。
4.  评论内容要符合角色人设，不超过20个字。
5.  **严禁OOC，严禁生成格式之外的内容，严禁代替玩家进行评论或回复**。
6.  至少生成2条评论，最多生成5条评论。
7.  举例：
（已点赞：33,vv,入入）
〖33：这是什么，看起来很好吃的样子〗
〖入入：我也要吃www〗
---
`;
                const playerInfo = `--- 发布动态的玩家资料 ---\n玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, moment.content);

                const finalPrompt = [
                    postContentText,
                    playerInfo, // 新增：将玩家人设信息加入Prompt
                    `--- 参与评论的角色资料参考 ---\n${membersInfo}`,
                    `--- 最近的聊天记录参考 ---\n${contextHistory}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');
                
                console.log("--- MOMENTS COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async buildMomentsPlayerCommentPrompt(momentId, playerComment) {
                const moment = await DBHelper.get('moments', momentId);
                const circle = await DBHelper.get('circles', moment.circleId);
                if (!circle || !circle.memberIds || circle.memberIds.length === 0) return null;

                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                const allContacts = await DBHelper.getAll('contacts');
                
                // 准备角色资料
                let membersToProvideInfo = [];
                const circleMembers = allContacts.filter(c => circle.memberIds.includes(c.id));
                
                // 1. 添加被回复者的资料 (如果是AI角色)
                const repliedToContact = playerComment.replyTo ? circleMembers.find(c => c.name === playerComment.replyTo) : null;
                if (repliedToContact) {
                    membersToProvideInfo.push(repliedToContact);
                }

                // 2. 随机抽取 1-3 位其他圈内好友
                const otherMembers = circleMembers.filter(c => c.name !== playerComment.replyTo);
                const shuffled = otherMembers.sort(() => 0.5 - Math.random());
                const numToSelect = Math.floor(Math.random() * 3) + 1;
                const selectedRandomMembers = shuffled.slice(0, Math.min(numToSelect, otherMembers.length));
                membersToProvideInfo.push(...selectedRandomMembers);

                membersToProvideInfo = [...new Set(membersToProvideInfo)]; // 去重

                const membersInfo = membersToProvideInfo.length > 0
                    ? membersToProvideInfo.map(m => `角色名: ${m.name}\n性别: ${m.gender}\n喜好: ${m.likes || '无'}\n厌恶: ${m.dislikes || '无'}\n习惯: ${m.habits || '无'}\n背景: ${m.background || '无'}`).join('\n---\n')
                    : '无';

                // 构建历史和当前动作
                let momentAuthor = moment.authorId === myProfile.id ? myProfile : allContacts.find(c => c.id === moment.authorId) || { name: moment.authorId };
                let postAndCommentsHistory = `这是“${momentAuthor.name}”发布的动态：“${moment.content}”\n目前的评论有：\n` + 
                    (moment.comments || []).map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `“${cAuthor.name}${c.replyTo ? ` 回复 ${c.replyTo}` : ''}：${c.content}”`;
                    }).join('\n');
                
                const playerActionText = playerComment.replyTo 
                    ? `玩家“${myProfile.name}”回复了“${playerComment.replyTo}”说：“${playerComment.content}”` 
                    : `玩家“${myProfile.name}”评论说：“${playerComment.content}”`;

                const privateChatRules = `
---
私聊规则(可选):
1.  如果你想让某个角色私聊玩家，请使用 <私聊></私聊> 标签包裹。
2.  私聊内容格式可以是: [角色名|消息内容] 或 {角色名|撤回内容} 或 [角色名|语音|时长|内容] 或 [角色名|转账|收款人|金额|备注]
3.  例如: <私聊>[33|你刚才发的动态是什么意思？]</私聊>
---
`;
                
                const formatRules = `
---
朋友圈评论生成规则：
1.  你将扮演圈内好友对玩家的评论做出回应。
2.  严格按照以下格式生成回复，可以只有点赞，或只有评论，或两者都有。
3.  点赞格式：用中文括号包裹点赞列表，格式为（已点赞：张三,李四）。
4.  评论格式: 〖评论者角色名：评论内容〗，禁止在〖〗内嵌套〖〗。
5.  评论内容要符合角色人设，可以是对玩家评论的直接回应，也可以是角色之间的互动。
6.  严禁OOC，严禁生成格式之外的内容。
---
`;
                
                const playerInfo = `--- 评论的玩家资料 ---\n玩家名: ${myProfile.name}\n性别: ${myProfile.gender}\n背景: ${myProfile.background || '无'}`;

                const customPromptsSection = await this._getBoundPromptsForMoments(circle, playerComment.content);

                const finalPrompt = [
                    `--- 动态与历史评论 ---\n${postAndCommentsHistory}`,
                    `--- 玩家最新动作 ---\n${playerActionText}`,
                    playerInfo, // 新增：将玩家人设信息加入Prompt
                    `--- 其他角色资料参考 ---\n${membersInfo}`,
                    customPromptsSection,
                    privateChatRules,
                    formatRules
                ].join('\n\n');

                console.log("--- MOMENTS PLAYER COMMENT PROMPT --- \n", finalPrompt);
                return finalPrompt;
            },

            async parseAndDisplayMomentsResponse(text) {
                const momentsListUl = $('#moments-list');
                const momentBlocks = text.match(/<朋友圈>[\s\S]*?<\/朋友圈>/g) || [];
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const circle = await DBHelper.get('circles', appState.currentCircleId);

                if (momentBlocks.length > 0 && momentsListUl.innerHTML.includes('还没有动态')) {
                    momentsListUl.innerHTML = ''; 
                }

                for (const block of momentBlocks) {
                    const postMatch = block.match(/【(.*?)】/);
                    if (!postMatch) continue;

                    const [authorPart, timePart] = postMatch[1].split('|');
                    const [authorName, ...contentParts] = authorPart.split('：');
                    const content = contentParts.join('：');

                    const author = allContacts.find(c => c.name === authorName.trim());

                    
                    const likeMatch = block.match(/（已点赞：(.*?)）/);
                    const likerNames = likeMatch ? likeMatch[1].split(/,|，/).map(n => n.trim()) : [];

                    const newMoment = {
                        id: Utils.generateId('moment'),
                        circleId: appState.currentCircleId,
                        authorId: author ? author.id : authorName.trim(),
                        content: content.trim(),
                        images: [], 
                        timestamp: Utils.parseMomentTimestamp(timePart ? timePart.trim() : null),
                        likes: likerNames, 
                        comments: []
                    };
                    
                    const commentMatches = block.match(/〖(.*?)〗/g) || [];
                    for (const cMatch of commentMatches) {
                        const inner = cMatch.slice(1, -1);
                        const [cAuthorName, ...cContentParts] = inner.split('：');
                        const trimmedAuthorName = cAuthorName.trim();
                        
                        let authorId;
                        if (trimmedAuthorName === myProfile.name) {
                            authorId = myProfile.id; 
                        } else {
                            const cAuthor = allContacts.find(c => c.name === trimmedAuthorName);
                            authorId = cAuthor ? cAuthor.id : trimmedAuthorName; 
                        }
                        
                        newMoment.comments.push({
                            authorId: authorId,
                            content: cContentParts.join('：').trim(),
                            timestamp: Date.now()
                        });
                    }

                    await DBHelper.put('moments', newMoment);
                    const momentElement = UIManager.createMomentElement(newMoment, myProfile, allContacts, circle.extraMembers);
                    momentsListUl.prepend(momentElement);
                }
            },
            async parseAndDisplayMomentsCommentsResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return; // 如果找不到动态，则提前退出

                // 1. 处理私聊消息
                const privateChatRegex = /<私聊>([\s\S]*?)<\/私聊>/g;
                let privateMessageMatch;
                while ((privateMessageMatch = privateChatRegex.exec(text)) !== null) {
                    await this.handlePrivateMessageFromMoment(privateMessageMatch[1], moment);
                }
                const publicText = text.replace(privateChatRegex, '').trim();

                // 2. 处理公开的点赞和评论
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                if (!interactionsContainer) return;
                interactionsContainer.style.display = 'block';

                const likeMatch = publicText.match(/（已点赞：(.*?)）/);
                if (likeMatch && likeMatch[1]) {
                    const likerNames = likeMatch[1].split(/,|，/).map(n => n.trim()).filter(Boolean);
                    if (!moment.likes) moment.likes = [];
                    likerNames.forEach(name => {
                        if (!moment.likes.includes(name)) moment.likes.push(name);
                    });
                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                    const likeBtn = postElement.querySelector('[data-action="like"]');
                    if (likeBtn) {
                        likeBtn.classList.toggle('liked', moment.likes.includes(myProfile.name));
                    }
                }

                const commentMatches = publicText.match(/〖(.*?)〗/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                if (!commentsListContainer) return;

                if (commentMatches.length === 0 && !likeMatch) {
                    if (likeMatch) await DBHelper.put('moments', moment);
                    return;
                }

                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));
                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('：');
                    const content = cContentParts.join('：').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    const authorId = cAuthor ? cAuthor.id : cAuthorName.trim();
                    
                    const newComment = { authorId, content, timestamp: Date.now() };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    let commentAuthorInfo;
                     if (authorId === myProfile.id) {
                        commentAuthorInfo = myProfile;
                    } else {
                        commentAuthorInfo = allContacts.find(c => c.id === authorId) || { name: authorId, id: authorId };
                    }
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    const authorStyle = commentAuthorInfo.id === myProfile.id ? 'style="color: #EDD4D8;"' : '';
                    commentDiv.innerHTML = `<span class="comment-author" ${authorStyle}>${commentAuthorInfo.name}:</span> ${content}`;

                    commentsListContainer.appendChild(commentDiv);
                }

                await DBHelper.put('moments', moment);
            },

            async handlePrivateMessageFromMoment(privateContent, moment) {
                if (!moment) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await EventManager.getPlayerProfileForContext(moment.circleId);
                
                const standardMatch = privateContent.match(/\[([^\[\]]+?)\]/);
                const retractedMatch = privateContent.match(/{([^{}]+?)}/);
                const emojiMatch = privateContent.match(/<([^>]+?)>/);

                let parts, senderName, sender;
                let match = standardMatch || retractedMatch || emojiMatch;
                if (!match) return;

                parts = match[1].split('|').map(p => p.trim());
                senderName = parts[0];
                sender = allContacts.find(c => c.name === senderName);
                if (!sender) return;

                // 1. 创建朋友圈上下文的系统消息
                const momentAuthor = (await EventManager.getMomentAuthor(moment.authorId, moment.circleId))?.name || '未知作者';
                let commentsText = '无';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        const cAuthor = c.authorId === myProfile.id ? myProfile : allContacts.find(u => u.id === c.authorId) || { name: c.authorId };
                        return `${cAuthor.name}${c.replyTo ? ` 回复 ${c.replyTo}` : ''}: ${c.content}`;
                    }).join('\n');
                }
                const contextContent = `<朋友圈动态>
动态发帖人：${momentAuthor}
动态内容：${moment.content}
动态时间：${Utils.formatTimestampSmartly(moment.timestamp)}
点赞情况：${(moment.likes && moment.likes.length > 0) ? moment.likes.join(', ') : '无'}
评论区：${commentsText}
</朋友圈动态>`;

                const contextMessage = {
                    messageId: Utils.generateId('sys'),
                    chatId: sender.id,
                    timestamp: Date.now() - 1,
                    type: 'system',
                    segmentType: 'system',
                    content: contextContent,
                    isHidden: true,
                    forAi: true,
                };

                // 2. 创建实际的私聊消息
                const visibleMessage = {
                    messageId: Utils.generateId('msg'),
                    chatId: sender.id,
                    senderId: sender.id,
                    timestamp: Date.now(),
                    type: 'received',
                    isUnread: appState.currentPage !== 'chat' || appState.currentChatId !== sender.id,
                    senderInfo: sender,
                };
                
                if (retractedMatch) {
                    visibleMessage.isRetracted = true;
                    visibleMessage.segmentType = 'text';
                    visibleMessage.content = parts[1];
                } else if (emojiMatch) {
                    visibleMessage.segmentType = 'emoji-image';
                    visibleMessage.content = parts[1];
                } else {
                    if (parts.length === 2) {
                        visibleMessage.segmentType = 'text';
                        visibleMessage.content = parts[1];
                    } else if (parts[1] === '语音') {
                        visibleMessage.segmentType = 'voice';
                        visibleMessage.content = `[语音] ${parts[3]}`;
                        visibleMessage.cardData = { duration: parts[2], content: parts[3] };
                    } else if (parts[1] === '转账') {
                        visibleMessage.segmentType = 'transfer';
                        visibleMessage.content = `[转账] ${parts[3]}`;
                        visibleMessage.cardData = { recipientName: parts[2], amount: parts[3], note: parts[4], isClaimed: false };
                    } else {
                        return;
                    }
                }
                
                // 3. 将两条消息都存入数据库
                await DBHelper.put('messages', contextMessage);
                await DBHelper.put('messages', visibleMessage);

                // 4. 更新私聊的元数据并触发通知
                await UIManager.updateChatMetadata(sender.id, visibleMessage, 1);
                UIManager.showTopNotification(visibleMessage);
                UIManager.renderMessagesListPage(); // 刷新消息列表
            },

            async parseAndDisplayMomentsPlayerCommentResponse(momentId, text) {
                const moment = await DBHelper.get('moments', momentId);
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const postElement = $(`[data-moment-id="${momentId}"]`);

                if (!postElement) return;

                const interactionsContainer = postElement.querySelector('.post-interactions');
                interactionsContainer.style.display = 'block';

                
                const likeMatch = text.match(/（已点赞：(.*?)）/);
                if (likeMatch && likeMatch[1]) {
                    const newLikerNames = likeMatch[1].split(/,|，/).map(n => n.trim()).filter(Boolean);
                    
                    if (!moment.likes) moment.likes = [];
                    newLikerNames.forEach(name => {
                        if (!moment.likes.includes(name)) {
                            moment.likes.push(name);
                        }
                    });

                    const likesContainer = interactionsContainer.querySelector('.post-likes');
                    if (likesContainer && moment.likes.length > 0) {
                        likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    }
                }

                
                const commentMatches = text.match(/〖(.*?)〗/g) || [];
                const commentsListContainer = interactionsContainer.querySelector('.post-comments-list');
                
                if (commentMatches.length === 0 && !likeMatch) return;
                
                for (const cMatch of commentMatches) {
                    await new Promise(resolve => setTimeout(resolve, Math.random() * 800 + 400));

                    const inner = cMatch.slice(1, -1);
                    const [cAuthorName, ...cContentParts] = inner.split('：');
                    const content = cContentParts.join('：').trim();
                    if (!content) continue;

                    const cAuthor = allContacts.find(c => c.name === cAuthorName.trim());
                    
                    const newComment = {
                        authorId: cAuthor ? cAuthor.id : cAuthorName.trim(),
                        content: content,
                        timestamp: Date.now()
                    };
                    if (!moment.comments) moment.comments = [];
                    moment.comments.push(newComment);
                    
                    const commentDiv = document.createElement('div');
                    commentDiv.className = 'post-comment-item';
                    commentDiv.dataset.authorName = cAuthor ? cAuthor.name : cAuthorName.trim();
                    commentDiv.dataset.authorId = newComment.authorId;
                    commentDiv.innerHTML = `<span class="comment-author">${cAuthor ? cAuthor.name : cAuthorName.trim()}:</span> ${content}`;
                    commentsListContainer.appendChild(commentDiv);
                }
                
                await DBHelper.put('moments', moment);
            },
            async getGiftApiResponse(prompt, signal) {
                let giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                
                if (!giftApiConfig || !giftApiConfig.key) {
                    throw new Error('礼物搜索API未配置，请先在礼物页面右上角设置。设置前阅读帮助内容，你也可以点击“使用主API配置”按钮来快速配置。\n如果不想配置API，可以选择自定义按钮，自定义自己想要赠送的礼物');
                }
                
                // Use a copy of the main getApiResponse logic, but with the specific giftApiConfig
                const { provider, url, key, model, temperature } = giftApiConfig;
                
                let apiUrl = url;
                let headers = { 'Content-Type': 'application/json' };
                let body;

                const messagesForApi = [{ role: 'user', content: prompt }];

                if (['siliconflow', 'paioupu', 'volcano', 'custom'].includes(provider)) {
                    headers['Authorization'] = `Bearer ${key}`;
                    if (!apiUrl.endsWith('/chat/completions')) {
                        apiUrl = apiUrl.endsWith('/') ? `${apiUrl}chat/completions` : `${apiUrl}/chat/completions`;
                    }
                    body = { model: model, messages: messagesForApi, temperature: temperature || 0.5 };
                } else if (provider === 'gemini') {
                    apiUrl += `${model}:generateContent?key=${key}`;
                    body = {
                        contents: [{ role: 'user', parts: [{ text: prompt }] }],
                        generationConfig: { temperature: temperature || 0.5 }
                    };
                } else {
                    throw new Error('不支持的API提供商。');
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify(body),
                    signal: signal
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API请求失败: ${response.status} - ${errorData.error ? errorData.error.message : JSON.stringify(errorData)}`);
                }
                
                const data = await response.json();
                
                if (provider === 'gemini') {
                    if (data.candidates && data.candidates[0].content) {
                        return data.candidates[0].content.parts[0].text;
                    } else {
                        throw new Error(`Gemini API未返回有效回复。`);
                    }
                } else {
                    if (data.choices && data.choices[0].message) {
                        return data.choices[0].message.content;
                    } else {
                        throw new Error(`API未返回有效回复。`);
                    }
                }
            },

            async handleGiftSearchRequest(keyword) {
                if (!keyword) return;

                const giftsGrid = $('#gifts-grid');
                const refreshBtn = $('#gift-search-refresh-btn');
                const sectionTitle = $('#gifts-section-title');
                const cancelBtn = $('#gift-cancel-search-btn');

                giftsGrid.innerHTML = '';

                const loader = document.createElement('div');
                loader.className = 'gift-loader';
                loader.style.display = 'block';
                loader.innerHTML = `
                    <div class="loader-spinner"></div>
                    <p>正在努力寻找礼物...</p>
                `;
                giftsGrid.appendChild(loader);

                refreshBtn.style.display = 'block';
                cancelBtn.style.display = 'inline-flex';
                sectionTitle.textContent = `“${keyword}”的搜索结果`;
                
                // 新增：获取绑定的提示词
                let customPrompt = '';
                try {
                    const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig');
                    if (giftApiConfig && giftApiConfig.giftPromptFolderIds && giftApiConfig.giftPromptFolderIds.length > 0) {
                        const allPrompts = await DBHelper.getAll('prompts');
                        const relevantPrompts = allPrompts
                            .filter(p => giftApiConfig.giftPromptFolderIds.includes(p.folderId) && p.isActive)
                            .map(p => p.content);
                        if (relevantPrompts.length > 0) {
                            customPrompt = `\n--- 附加风格要求 ---\n${relevantPrompts.join('\n\n')}\n---`;
                        }
                    }
                } catch(e) { console.error("获取礼物绑定提示词失败", e); }


                const prompt = `请你扮演一位专业的电商商品文案策划，为我推荐8个与关键词“${keyword}”同类或相关的创意礼物。
要求：
1. 礼物名称要生动有趣，可以包含虚构的品牌名或系列名。
2. 礼物简介要精炼且有吸引力，20字以内，突出礼物的特点或寓意。
3. 礼物图片必须是来自Unsplash, Pexels等免费图库的高质量URL。
4. 严格以JSON数组格式返回，不要有任何多余的文字或代码块标记。
5. 每个JSON对象必须包含四个键：
   - "url": 图片链接 (string)
   - "name": 礼物名称 (string)
   - "summary": 礼物简介 (string)
   - "price": 礼物价格 (number)${customPrompt}
`;
                try {
                    const response = await this.getGiftApiResponse(prompt, new AbortController().signal);
                    console.log("--- AI 礼物搜索 (原始) ---\n", response); // 添加日志
                    
                    const jsonString = response.replace(/```json/g, '').replace(/```/g, '').trim();
                    const gifts = JSON.parse(jsonString);

                    giftsGrid.innerHTML = '';

                    if (Array.isArray(gifts) && gifts.length > 0) {
                        gifts.forEach(gift => {
                            const giftData = {
                                name: gift.name,
                                price: Number(gift.price) || 0,
                                image: gift.url,
                                message: gift.summary
                            };
                            const card = EventManager.createGiftCard(giftData);
                            card.onclick = () => EventManager.showSendGiftModal(giftData);
                            giftsGrid.appendChild(card);
                        });
                    } else {
                        giftsGrid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; color: #aaa;">没有找到相关的礼物，换个关键词试试？</p>';
                    }
                } catch (error) {
                    console.error("礼物搜索失败:", error);
                    giftsGrid.innerHTML = `<p style="grid-column: 1 / -1; text-align: center; color: #e74c3c;">搜索失败了...<br>${error.message}</p>`;
                }
            },
        };

        
        const EventManager = {

            async setupEmojiMaps() {
                const profile = await DBHelper.get('profile', 'myProfile');
                appState.customEmojis = profile.customEmojis || {};

                // Combine for AI map
                appState.aiEmojiMap = { ...BUILTIN_AI_EMOJIS };
                for (const [id, data] of Object.entries(appState.customEmojis)) {
                    appState.aiEmojiMap[id] = data.name;
                }

                // Combine for Player map
                appState.playerEmojiMap = { ...BUILTIN_PLAYER_EMOJIS };
                for (const [id, data] of Object.entries(appState.customEmojis)) {
                    appState.playerEmojiMap[id] = data.name;
                }
            },

            BUILTIN_CHARACTERS: {
                '旁白001': {
                    id: '旁白001',
                    remark: '旁白',
                    avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzMiAzMiIgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIj48cmVjdCB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIGZpbGw9IiNmZmYiLz48cGF0aCBkPSJNMTYuMSA1LjJjLTEuNyAyLjUtMy44IDQuOC02LjIgNi43LTIuNCAxLjktNS4xIDMuMy03LjkgNC4xLjQgMi4xIDEuMyA0LjEgMi43IDUuOCAxLjQgMS',
                    gender: '其他',
                    likes: '描述场景、补充设定、推动剧情',
                    previewDesc: '推动剧情、描述场景。需要添加到群聊内使用。',
                    dislikes: '被当成普通角色对话',
                    habits: '在关键时刻出现',
                    background: '请严格使用 <旁白>旁白内容</旁白> 的格式进行回复，用于描述场景、补充设定或推动剧情。'
                }
            },
            _syncColorInputs(colorPickerId, hexInputId) {
                const colorPicker = $(`#${colorPickerId}`);
                const hexInput = $(`#${hexInputId}`);

                if (!colorPicker || !hexInput) return;

                const updateHex = () => {
                    hexInput.value = colorPicker.value.toUpperCase();
                };

                const updatePicker = () => {
                    let value = hexInput.value.trim();
                    if (/^#?([0-9A-F]{6}|[0-9A-F]{3})$/i.test(value)) {
                         if (!value.startsWith('#')) {
                            value = '#' + value;
                        }
                        colorPicker.value = value;
                        // Dispatch input event to trigger other listeners (like theme saving)
                        colorPicker.dispatchEvent(new Event('input', { bubbles: true }));
                    } else {
                        // Revert to the color picker's current value if invalid
                        hexInput.value = colorPicker.value.toUpperCase();
                    }
                };

                colorPicker.addEventListener('input', updateHex);
                hexInput.addEventListener('change', updatePicker);
            },
            init() {
                
                bottomNav.addEventListener('click', (e) => {
                    const navItem = e.target.closest('.nav-item');
                    if (navItem) UIManager.navigateTo(navItem.dataset.page);
                });

                
                $('#nav-to-moments').addEventListener('click', () => UIManager.navigateTo('moments', 'discover'));

                $('#nav-to-pomodoro').addEventListener('click', () => UIManager.navigateTo('pomodoro', 'discover'));
                
                $('#moments-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#moments-refresh-btn').addEventListener('click', () => AIHandler.handleMomentsRefreshRequest());
                $('#moments-new-post-btn').addEventListener('click', () => this.handleNewMoment());
                $('#moments-manage-btn').addEventListener('click', () => UIManager.showCircleManagementSidebar());
                $('#moments-list').addEventListener('click', (e) => {
                    const postElement = e.target.closest('.moments-post');
                    if (!postElement) return;

                    const momentId = postElement.dataset.momentId;
                    const actionBtn = e.target.closest('[data-action]');
                    const commentItem = e.target.closest('.post-comment-item');

                    
                    if (actionBtn) {
                        const action = actionBtn.dataset.action;

                        if (action === 'toggle-comment') {
                            this.toggleCommentInput(postElement);
                        } else if (action === 'submit-comment') {
                            this.handlePlayerComment(momentId);
                        } else if (action === 'like') {
                            this.handlePlayerLike(momentId);
                        } else if (action === 'forward') {
                            this.handleForwardMoment(momentId);
                        } else if (action === 'delete-moment') {
                            this.confirmDeleteMoment(momentId, postElement);
                        }
                        return; 
                    }
                    
                    
                    if (commentItem) {
                        const authorName = commentItem.dataset.authorName;
                        this.toggleCommentInput(postElement, authorName);
                    }
                });

                $('#moments-list').addEventListener('mousedown', e => this.handleMomentCommentInteractionStart(e, 'mouse'));
                $('#moments-list').addEventListener('keypress', async (e) => {
                    // 检查事件目标是否为评论输入框，以及是否按下了回车键
                    if (!e.target.matches('.comment-input-wrapper input') || e.key !== 'Enter' || e.shiftKey) {
                        return;
                    }

                    // 阻止默认的回车换行行为
                    e.preventDefault();

                    // 获取聊天设置
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend) {
                        const momentId = e.target.closest('.moments-post').dataset.momentId;
                        if (momentId) {
                            this.handlePlayerComment(momentId);
                        }
                    }
                });

                $('#moments-list').addEventListener('touchstart', e => this.handleMomentCommentInteractionStart(e, 'touch'));


                
                // --- 礼物功能事件监听 ---
                $('#gift-btn').addEventListener('click', () => UIManager.navigateTo('gifts', 'chat'));
                $('#gifts-back-btn').addEventListener('click', () => UIManager.navigateTo('chat'));
                $('#custom-gift-btn').addEventListener('click', () => this.showCustomGiftModal());
                $('#gift-api-config-btn').addEventListener('click', () => this.showGiftApiConfigModal());
                $('#gift-search-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        AIHandler.handleGiftSearchRequest(e.target.value);
                    }
                });
                $('#gift-search-refresh-btn').addEventListener('click', () => {
                    const keyword = $('#gift-search-input').value.trim();
                    if(keyword) AIHandler.handleGiftSearchRequest(keyword);
                });
                $('#gift-cancel-search-btn').addEventListener('click', async () => {
                    $('#gift-search-input').value = '';
                    $('#gift-search-refresh-btn').style.display = 'none';
                    $('#gift-cancel-search-btn').style.display = 'none';
                    await UIManager.renderGiftsPage();
                });
                $('#gift-bind-prompt-btn').addEventListener('click', () => this.handleGiftPromptBinding());
                $('#gift-help-btn').addEventListener('click', () => this.showGiftHelpModal());
                $('#my-avatar').addEventListener('click', () => this.handleEditProfile());
                $('#batch-delete-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#select-all-btn').addEventListener('click', () => this.handleSelectAll());
                $('#cancel-selection-btn').addEventListener('click', () => this.handleBatchDelete());
                $('#delete-selected-btn').addEventListener('click', () => this.handleConfirmBatchDelete());
                $('#add-menu-btn').addEventListener('click', () => this.showAddMenu());
                $$('.tab-btn').forEach(btn => btn.addEventListener('click', () => UIManager.renderContactsPage(btn.dataset.tab)));
                $('#sort-friends-btn').addEventListener('click', () => this.handleSortContacts());
                $('#sort-groups-btn').addEventListener('click', () => this.handleSortGroups());
                $('#setting-chat').addEventListener('click', () => this.handleChatSettings());
                $('#setting-api').addEventListener('click', () => this.handleApiSettings());
                $('#setting-prompts').addEventListener('click', () => UIManager.navigateTo('prompts', 'settings'));
                $('#setting-theme').addEventListener('click', () => UIManager.navigateTo('theme-settings', 'settings'));
                $('#setting-reset').addEventListener('click', () => this.handleResetApp());
                $('#setting-wish-pool').addEventListener('click', () => this.handleWishPool());

                $('#pomodoro-back-btn').addEventListener('click', () => UIManager.navigateTo('discover'));
                $('#pomodoro-start-btn').addEventListener('click', () => this.startPomodoro());
                $('#pomodoro-stop-btn').addEventListener('click', () => this.stopPomodoro());
                $('#pomodoro-float-ball').addEventListener('click', () => {
                    // 检查是否正在拖动，如果是，则不触发点击事件
                    if ($('#pomodoro-float-ball').isDragging) {
                        $('#pomodoro-float-ball').isDragging = false; // 重置状态
                        return;
                    }
                    UIManager.navigateTo('pomodoro');
                });
                
                // --- 新增：番茄钟悬浮球拖动逻辑 ---
                const setupPomodoroDrag = () => {
                    const floatBall = $('#pomodoro-float-ball');
                    let isDragging = false;
                    let initialY;
                    let initialBottom;
                    let hasMoved = false;

                    const onDragStart = (e) => {
                        if (e.target.closest('.time-left') || e.target.closest('.progress-ring')) {
                            isDragging = true;
                            hasMoved = false;
                            floatBall.isDragging = false; // 自定义属性，用于区分点击和拖拽
                            floatBall.classList.add('dragging');

                            initialY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
                            initialBottom = parseInt(window.getComputedStyle(floatBall).bottom, 10);
                            
                            // 阻止默认行为，如页面滚动
                            e.preventDefault();

                            document.addEventListener('mousemove', onDragMove);
                            document.addEventListener('touchmove', onDragMove, { passive: false });
                            document.addEventListener('mouseup', onDragEnd);
                            document.addEventListener('touchend', onDragEnd);
                        }
                    };

                    const onDragMove = (e) => {
                        if (!isDragging) return;

                        e.preventDefault();
                        hasMoved = true;
                        floatBall.isDragging = true;

                        const currentY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
                        const deltaY = currentY - initialY;
                        let newBottom = initialBottom - deltaY;

                        // 限制拖动范围
                        const maxHeight = window.innerHeight - floatBall.offsetHeight - 20; // 20px 边距
                        const minHeight = 80; // 底部最小边距
                        newBottom = Math.max(minHeight, Math.min(newBottom, maxHeight));
                        
                        floatBall.style.bottom = `${newBottom}px`;
                    };

                    const onDragEnd = () => {
                        isDragging = false;
                        floatBall.classList.remove('dragging');
                        
                        document.removeEventListener('mousemove', onDragMove);
                        document.removeEventListener('touchmove', onDragMove);
                        document.removeEventListener('mouseup', onDragEnd);
                        document.removeEventListener('touchend', onDragEnd);
                        
                        // 如果只是轻点没有移动，确保 isDragging 状态被正确重置
                        if (!hasMoved) {
                            setTimeout(() => { floatBall.isDragging = false; }, 10);
                        }
                    };

                    floatBall.addEventListener('mousedown', onDragStart);
                    floatBall.addEventListener('touchstart', onDragStart, { passive: false });
                };
                setupPomodoroDrag();
                // --- 拖动逻辑结束 ---
                
                const messageListUl = $('#message-list-ul');
                let messageListLongPressTimer = null;
                messageListUl.addEventListener('mousedown', (e) => handleInteractionStart(e, 'mouse'));
                messageListUl.addEventListener('touchstart', (e) => handleInteractionStart(e, 'touch'), { passive: true });

                function handleInteractionStart(e, type) {
                    const item = e.target.closest('.message-item');
                    if (!item) return;

                    clearTimeout(messageListLongPressTimer);
                    messageListLongPressTimer = setTimeout(() => {
                        UIManager.showMessageListOptions(item);
                    }, 500);

                    function clearLongPress() {
                        clearTimeout(messageListLongPressTimer);
                        document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                        document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                    }
                    document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                }
                
                $('#setting-tutorial').addEventListener('click', () => UIManager.navigateTo('tutorial', 'settings'));
                
                
                $('#tutorial-back-btn').addEventListener('click', () => UIManager.navigateTo('settings'));
                $('#page-tutorial .page-content').addEventListener('click', (e) => {
                    const item = e.target.closest('.setting-item');
                    if (!item) return;

                    const showTutorialModal = (title, body) => {
                        UIManager.showModal({
                            title: title,
                            body: `<div style="line-height: 1.7; font-size: 0.95rem;">${body}</div>`,
                            actions: [{ text: '我明白了', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    };

                    switch (item.id) {
                        case 'tutorial-api':
                            showTutorialModal('如何配置API', `
                                <p>聊天室需要你提供一个AI服务商的API Key才能运行。</p>
                                <p>1. 进入 <strong>设置 > API配置</strong> 页面。</p>
                                <p>2. 从“API提供商”下拉框中选择你拥有的服务商。如Gemini(谷歌官方), SiliconFlow(硅基流动)等。</p>
                                <p>3. 系统会自动填充大部分服务商的默认URL和模型，你只需在 <strong>API Key</strong> 输入框中填入你的密钥即可。</p>
                                <p>4. 如果你使用自定义或未列出的服务商，请选择“自定义”并手动填写所有字段。</p>
                                <p>5. 如果你是<strong>自己购入的Gemini模型</strong>，请选择“自定义”并手动填写所有字段。所有需要填入的字段可询问你的api卖家</p>
                                <p><strong>提示：</strong>API Key非常重要，请妥善保管，不要泄露。</p>
                            `);
                            break;
                        case 'tutorial-character':
                            showTutorialModal('如何创建新角色', `
                                <p>角色是与你聊天的好友。</p>
                                <p>1. 进入 <strong>通讯录</strong> 页面。</p>
                                <p>2. 点击右上角的 <strong>+</strong> 号按钮。</p>
                                <p>3. 在弹出的菜单中选择 <strong>添加新好友</strong>。</p>
                                <p>4. 填写角色的各项信息。<strong>姓名</strong>是角色的唯一ID，不可重复。其他信息如喜好、背景按需要填写。</p>
                                <p>5. 点击“添加”即可完成创建。</p>
                                <p>6. 点击<strong>通讯录</strong>页面的好友可进入聊天界面</p>
                            `);
                            break;
                        case 'tutorial-group':
                            showTutorialModal('如何创建群聊', `
                                <p>你可以创建包含多个好友角色的群聊。</p>
                                <p>1. 同样在 <strong>通讯录</strong> 页面，点击右上角 <strong>+</strong> 号并选择 <strong>新建群聊</strong>。</p>
                                <p>2. 为群聊起一个名字，并从好友列表中勾选要加入群聊的好友角色（至少一位）。</p>
                                <p>3. 你还可以指定一位群主，群主可以是你自己或任何一位好友角色。</p>
                                <p>4. 创建成功后，你就可以在群聊中与多个好友同时互动了。</p>
                            `);
                            break;
                        case 'tutorial-chatting':
                            showTutorialModal('如何进行聊天', `
                                <p><strong>1. 发送与回复：</strong></p>
                                <p>在聊天输入框（右下角）输入并发送你的所有消息后，点击左下角的 <strong>羽毛按钮 <i class="fas fa-feather-alt"></i></strong> 来让AI进行回复。</p>
                                <p><strong>2. 重新生成：</strong></p>
                                <p>如果你对AI的最新回复不满意，可以点击你自己的头像，AI会撤销刚才的回复并重新生成一次。</p>
                                <p><strong>3. 查看内心：</strong></p>
                                <p>想知道好友在想什么吗？点击好友的头像，可以看到TA最近的“心声”和“随笔”。</p>
                                <p><strong>4. 更多操作：</strong></p>
                                <p>长按任意一条消息气泡，可以进行“引用”、“删除”或“撤回”（仅自己发的消息）操作。</p>
                            `);
                            break;
                        case 'tutorial-opening-scene':
                            showTutorialModal('开场白是什么？', `
                                <p>开场白是一个<strong>预设的对话场景</strong>，用于快速开启一段特定情境的对话，而无需从零开始引导。</p>
                                <p><strong>如何添加与应用：</strong></p>
                                <p>1. 在好友或群聊的聊天界面，点击右上角的菜单按钮(<i class="fas fa-ellipsis-v"></i> 或 <i class="fas fa-ellipsis-h"></i>)进入管理界面。</p>
                                <p>2. 选择 <strong>开场白设定</strong>，你可以在这里新建、编辑或删除多个开场白方案。</p>
                                <p>3. 在开场白列表中点击 <strong>应用</strong> 按钮后，<strong>当前聊天记录会被清空</strong>，然后好友/群聊会根据你设定的开场白内容，自动开始一段新的对话。</p>
                                <p><strong>提示：</strong>这是一个非常适合快速测试角色设定或开启新剧情的功能。</p>
                            `);
                            break;
                        case 'tutorial-prompts':
                            showTutorialModal('提示词是什么？', `
                                <p>提示词（Prompt）是用来指导AI如何回应的特殊指令，能极大地影响角色的性格、说话风格和行为逻辑。</p>
                                <p><strong>功能与绑定：</strong></p>
                                <p>你可以在 <strong>设置 > 自定义提示词</strong> 页面创建和管理提示词。提示词可以绑定给单个好友、群聊、甚至朋友圈（影响动态生成），让好友在不同场景下遵循不同的规则。</p>
                                <p>点击<strong>聊天界面/朋友圈界面右上角</strong>的管理按钮，选择<strong>绑定提示词</strong></p>
                                <p><strong>提示词类型：</strong></p>
                                <p>  - <strong>显性(Explicit):</strong> 这种提示词<strong>总是</strong>会被激活，非常适合定义角色的核心性格、世界观或必须遵守的规则。</p>
                                <p>  - <strong>隐性(Implicit):</strong> 只有当你的发言中包含预设的<strong>关键词</strong>时，这种提示词才会被激活。适合设定一些特定情境下的反应，如“当玩家提到‘下雨’时，角色会表现出悲伤”。</p>
                                <p><strong>导入与导出：</strong></p>
                                <p>在提示词管理页面，你可以将写好的提示词文件夹导出为<code>.json</code>文件，用于备份或分享给他人。同样，也可以导入他人分享的提示词文件。</p>
                                <p><strong>注意（Token消耗）：</strong></p>
                                <p>提示词内容越长、绑定的提示词越多，每次与好友交互时消耗的Token就越多，并降低响应速度。请根据需要自行取舍。</p>
                            `);
                            break;
                        case 'tutorial-import-export':
                             showTutorialModal('如何导入导出', `
                                <p>你可以方便地分享或备份你的角色与群聊数据。</p>
                                <p><strong>导出：</strong></p>
                                <p>1. 在通讯录点击好友或群聊的详情按钮，或在聊天页面点击右上角菜单进入管理页面。</p>
                                <p>2. 点击“导出角色/群聊”按钮，会生成一个 <code>.json</code> 格式的配置文件，保存到本地即可。</p>
                                <p><strong>导入：</strong></p>
                                <p>1. 在通讯录页面，点击右上角 <strong>+</strong> 号，选择 <strong>导入角色/群聊</strong>。</p>
                                <p>2. 选择你之前导出的 <code>.json</code> 文件，系统会自动识别并导入。</p>
                                <p>导入前确保导入的文件是支持这个聊天室使用的。</p>
                                <p><strong>提示：</strong>如果导入的角色名与现有角色冲突，系统会提示你选择“更新”或“覆盖”。</p>
                            `);
                            break;
                        case 'tutorial-emoji':
                            showTutorialModal('如何新增/删除表情包', `
                                <p>你可以添加和管理自己的专属表情包。</p>
                                <p>1. 在任意聊天界面，点击输入框下方的 <strong>收藏表情 <i class="fas fa-star"></i></strong> 按钮，打开收藏表情面板。</p>
                                <p>2. 点击面板左上角的 <strong><i class="fas fa-plus"></i></strong> 按钮，可以<strong>新增</strong>自定义表情。你需要提供表情图片的URL链接和表情的文字描述（这个描述会告诉AI表情的含义）。</p>
                                <p>3. 点击 <strong><i class="fas fa-minus"></i></strong> 按钮，可以<strong>删除</strong>你添加过的自定义表情。</p>
                                <p><strong>提示：</strong>在普通表情包面板，你也可以点击每个表情右上角的星星 <i class="fas fa-star"></i> 来收藏或取消收藏内置表情。</p>
                            `);
                            break;
                        case 'tutorial-persona':
                            showTutorialModal('玩家人设及绑定', `
                                <p>你可以创建多套“你”的人设，并在不同聊天中切换，让AI根据不同的人设与你互动。</p>
                                <p><strong>1. 创建/管理预设：</strong></p>
                                <p>  - 在 <strong>消息</strong> 页面，点击左上角你自己的头像，会滑出“我的信息”侧边栏。</p>
                                <p>  - 在这里编辑你的姓名、性别、背景等信息，这就是你<strong>当前使用</strong>的人设。</p>
                                <p>  - 点击下方的 <strong>读取/保存/删除</strong> 按钮，可以管理你的人设<strong>预设</strong>。你可以将当前的人设保存为一个新的预设，或读取一个已有的预设来替换当前人设。</p>
                                <p><strong>2. 绑定人设：</strong></p>
                                <p>  - <strong>绑定</strong>的作用是将某个特定的人设预设<strong>固定</strong>给一个聊天对象或场景。</p>
                                <p>  - 你可以在以下地方进行绑定：</p>
                                <p>    • <strong>私聊/群聊：</strong>聊天界面右上角菜单 > 绑定玩家人设。</p>
                                <p>    • <strong>好友分组：</strong>通讯录 > 分组 > 对应分组右上角菜单 > 绑定玩家人设 (会对此分组下所有未单独绑定的好友生效)。</p>
                                <p>    • <strong>朋友圈：</strong>发现 > 朋友圈 > 右上角菜单 > 修改当前圈子 > 绑定玩家人设。</p>
                                <p><strong>重要：</strong>如果一个聊天对象没有绑定任何特定人设，AI将默认使用你在“我的信息”侧边栏中<strong>当前正在使用</strong>的人设与你对话。</p>
                            `);
                            break;
                        case 'tutorial-narrator':
                             showTutorialModal('旁白如何使用', `
                                <p>“旁白”功能允许你设定一个“故事的讲述者”来描述场景、补充设定或推动剧情。</p>
                                <p><strong>使用方法：</strong></p>
                                <p>通讯录新增内置角色选择旁白，将旁白添加进入群聊内。或者自行创建一个旁白角色，固定它使用 <code>&lt;旁白&gt;...&lt;/旁白&gt;</code> 的格式来发送旁白消息。</p>
                                <p>当然，你也可以自己输入旁白消息格式，来作为那个剧情的推动者。</p>
                                <p><strong>示例：</strong></p>
                                <p><code>&lt;旁白&gt;窗外下起了淅淅沥沥的小雨，房间里的气氛有些沉闷。&lt;/旁白&gt;</code></p>
                            `);
                            break;
                        case 'tutorial-moments':
                            showTutorialModal('朋友圈如何使用', `
                                <p>朋友圈是一个模拟社交动态的趣味功能。</p>
                                <p>1. 进入 <strong>发现 > 朋友圈</strong>。首次进入需要点击右上角菜单按钮，先创建一个“圈子”。</p>
                                <p>2. 点击右上角菜单按钮可以 <strong>管理圈子</strong>（增删改查、切换）。</p>
                                <p>3. 点击相机图标可以 <strong>发布你自己的动态</strong>。</p>
                                <p>4. 点击刷新按钮，好友会根据已有设定，<strong>自动生成新的朋友圈动态</strong>。</p>
                                <p>5. 你可以像真实社交软件一样，对动态进行点赞、评论和转发。</p>
                            `);
                            break;
                        case 'tutorial-theme':
                            showTutorialModal('如何设置主题', `
                                <p>你可以高度自定义应用的外观。</p>
                                <p>1. 进入 <strong>设置 > 主题设置</strong>。</p>
                                <p>2. 在这里，你可以更改<strong>弹窗风格</strong>、<strong>聊天气泡样式</strong>、<strong>字体大小</strong>和<strong>颜色</strong>。</p>
                                <p>3. 点击 <strong>通用设置 > 背景与封面</strong>，可以上传你喜欢的图片作为全局页面背景、全局聊天背景，好友/群聊聊天界面右上角可设置专属聊天背景。支持自定义红包和转账的封面图。</p>
                                <p>4. <strong>字体设置</strong>你可以加载可免费使用的或已购买的本地字体文件/网络字体资源</p>
                            `);
                            break;
                    }
                });
                
                
                chatBackBtn.addEventListener('click', async () => {
                    const chatId = appState.currentChatId;
                    if (chatId) {
                        const chatData = await DBHelper.get('chats', chatId);
                        if (chatData && chatData.history) {
                            let madeChanges = false;
                            chatData.history.forEach(msg => {
                                if (msg.isUnread) {
                                    msg.isUnread = false;
                                    madeChanges = true;
                                }
                            });
                            if (madeChanges) {
                                await DBHelper.put('chats', chatData);
                            }
                        }
                    }
                    this.resetQuoteState();
                    UIManager.navigateTo('messages');
                });
                $('#chat-manage-btn').addEventListener('click', () => {
                    const chatId = appState.currentChatId;
                    if (!chatId) return;
                    if (chatId.startsWith('group-')) this.handleOpenGroupManagementSidebar(chatId);
                    else this.handleOpenFriendManagementSidebar(chatId);
                });
                 sendBtn.addEventListener('click', () => this.handlePlayerSendMessage());
                messageInput.addEventListener('keypress', async (e) => {
                    const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
                    if (chatSettings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        this.handlePlayerSendMessage();
                    }
                });
                aiRequestBtn.addEventListener('click', () => {
                    if (AIHandler.isAwaitingResponse) AIHandler.cancelAiRequest();
                    else AIHandler.handleAiReplyRequest();
                });
                messageInput.addEventListener('input', () => {
                    messageInput.style.height = 'auto';
                    messageInput.style.height = (messageInput.scrollHeight) + 'px';
                });

                
                appContainer.addEventListener('click', (e) => this.handleClickEffect(e));
                modalOverlay.addEventListener('click', (e) => {
                    if (e.target === modalOverlay && !modalOverlay.classList.contains('no-overlay-close')) UIManager.hideModal();
                });
                $('#sidebar-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#sidebar-overlay')) UIManager.hideSidebar();
                });

                $('#bottom-sheet-overlay').addEventListener('click', (e) => {
                    if (e.target === $('#bottom-sheet-overlay')) UIManager.hideBottomSheet();
                });

                
                emojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    favoriteEmojiCard.classList.remove('active'); // 关闭另一个
                    emojiCard.classList.toggle('active');
                });

                favoriteEmojiBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    emojiCard.classList.remove('active'); // 关闭另一个
                    favoriteEmojiCard.classList.toggle('active');
                    if (favoriteEmojiCard.classList.contains('active')) {
                        this.renderFavoriteEmojiPage();
                    }
                });

                $('#simulated-image-btn').addEventListener('click', () => this.handleSimulatedImageSend());
                $('#card-btn').addEventListener('click', () => this.handlePlayerCardSend());
                voiceBtn.addEventListener('click', () => this.handleVoiceInput());
                $('#transfer-btn').addEventListener('click', () => this.handlePlayerTransfer());
                $('#red-packet-btn').addEventListener('click', () => this.handlePlayerRedPacket());
                document.addEventListener('click', (e) => {
                    if (!chatInputArea.contains(e.target)) {
                        emojiCard.classList.remove('active');
                        favoriteEmojiCard.classList.remove('active');
                    }
                });
                $('#emoji-prev-btn').addEventListener('click', () => { appState.emojiCurrentPage--; this.renderEmojiPage(); });
                $('#emoji-next-btn').addEventListener('click', () => { appState.emojiCurrentPage++; this.renderEmojiPage(); });
                $('#favorite-emoji-prev-btn').addEventListener('click', () => { appState.favoriteEmojiCurrentPage--; this.renderFavoriteEmojiPage(); });
                $('#favorite-emoji-next-btn').addEventListener('click', () => { appState.favoriteEmojiCurrentPage++; this.renderFavoriteEmojiPage(); });
                
                chatArea.addEventListener('mousedown', (e) => this.handleInteractionStart(e, 'mouse'));
                chatArea.addEventListener('touchstart', (e) => this.handleInteractionStart(e, 'touch'));
                cancelQuoteBtn.addEventListener('click', () => this.resetQuoteState());

                chatArea.addEventListener('click', async (e) => {
                    const messageRow = e.target.closest('.message-row');
                    if (!messageRow) return;
                    const messageId = messageRow.dataset.messageId;
                    const voiceBubble = e.target.closest('.voice-message-bubble');
                    if (voiceBubble) {
                        const wrapper = voiceBubble.closest('.bubble-and-tag-wrapper');
                        const transcript = wrapper.querySelector('.voice-transcript');
                        if (transcript) transcript.classList.toggle('show');
                        return;
                    }
                    const cardWrapper = e.target.closest('.card-message-wrapper');
                    if (cardWrapper) {
                        const cardId = cardWrapper.dataset.cardId;
                        if (!cardId) return;
                        const detailElement = document.getElementById(cardId);
                        if (detailElement) detailElement.classList.toggle('visible');
                        return;
                    }
                    const specialBubble = e.target.closest('.transfer-or-red-packet-bubble');
                    if (specialBubble) {
                        const msg = await DBHelper.get('messages', messageId);
                        if (!msg) return;
                        if (msg.segmentType === 'transfer' && !msg.cardData.isClaimed) {
                            this.handleTransferClick(msg);
                        } else if (msg.segmentType === 'red-packet' && !msg.cardData.isClaimedByPlayer) {
                            this.handleRedPacketClick(msg);
                        }
                        return; 
                    }

                    
                    const customForwardCard = e.target.closest('[data-type="custom-forward"]');
                    if (customForwardCard) {
                        const messageId = customForwardCard.closest('.message-row').dataset.messageId;
                        if (messageId) {
                            this.showCustomForwardDetail(messageId);
                        }
                        return;
                    }
                    
                    const forwardedMomentCard = e.target.closest('.forwarded-moment-card-content');
                    if (forwardedMomentCard) {
                        const momentId = forwardedMomentCard.dataset.momentId;
                        if (momentId) {
                            this.showForwardedMomentDetail(momentId);
                        }
                        return; 
                    }
                    const giftBubble = e.target.closest('.gift-bubble');
                    if (giftBubble) {
    this.showGiftDetailsModal(messageId);
    return;
    }
                });
                chatArea.addEventListener('scroll', () => {
                    if (chatArea.scrollTop < 50 && !appState.isHistoryLoading) {
                        UIManager.loadMoreMessages();
                    }
                });

                const momentsBg = $('#moments-bg');
                const momentsBgInput = $('#moments-bg-input');

                momentsBg.addEventListener('click', () => {
                    momentsBgInput.click();
                });

                momentsBgInput.addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (!file || !appState.currentCircleId) return;

                    try {
                        const compressedImage = await Utils.compressImage(file, 1000, 1000, 0.8);
                        const circle = await DBHelper.get('circles', appState.currentCircleId);
                        if (circle) {
                            circle.backgroundImage = compressedImage;
                            await DBHelper.put('circles', circle);
                            momentsBg.src = compressedImage;
                            UIManager.showToast('背景已更换！');
                        }
                    } catch (error) {
                        console.error("更换背景失败：", error);
                        UIManager.showToast('图片处理失败，请重试');
                    }
                });
            },

            async getPlayerProfileForContext(contextId) {
                const baseProfile = await DBHelper.get('profile', 'myProfile');
                let boundProfile = null;
                let boundId = null; // 使用 ID 而非索引

                if (!contextId) {
                    return baseProfile;
                }

                if (contextId.startsWith('group-')) { // Group Chat
                    const group = await DBHelper.get('groups', contextId);
                    boundId = group?.boundPersonaPresetId;
                } else if (contextId.startsWith('contact-')) { // Private Chat
                    const contact = await DBHelper.get('contacts', contextId);
                    if (contact) {
                        if (contact.boundPersonaPresetId) {
                            boundId = contact.boundPersonaPresetId;
                        } else if (contact.folderId) {
                            const folder = await DBHelper.get('friendFolders', contact.folderId);
                            boundId = folder?.boundPersonaPresetId;
                        }
                    }
                } else if (contextId.startsWith('circle-')) { // Moments Circle
                    const circle = await DBHelper.get('circles', contextId);
                    boundId = circle?.boundPersonaPresetId;
                }

                if (boundId && baseProfile.presets && Array.isArray(baseProfile.presets)) {
                    // 通过 ID 查找预设，而不是索引
                    boundProfile = baseProfile.presets.find(p => p && p.presetId === boundId);
                }

                // Return the bound profile, or the base profile if no valid binding is found.
                return boundProfile || baseProfile;
            },

        async handlePlayerSendMessage(prebuiltMessage = null) {
            const content = messageInput.value.trim();
            if (!prebuiltMessage && (!content || !appState.currentChatId)) return;

            let message;
            const profile = await this.getPlayerProfileForContext(appState.currentChatId);
            const allMessages = await DBHelper.getMessages(appState.currentChatId, 1, Date.now());
            const lastMessage = allMessages.pop();

            const now = Date.now();
            
            if (lastMessage && (now - lastMessage.timestamp > 5 * 60 * 1000)) {
                const timeDivider = UIManager.createTimeDividerElement(now);
                chatArea.appendChild(timeDivider);
            }

            if (prebuiltMessage) {
                message = prebuiltMessage;
                message.timestamp = now; 
            } else if (appState.quotingMessage) {
                
                const quotedMsg = appState.quotingMessage;
                const contact = await DBHelper.get('contacts', quotedMsg.senderId);
                const senderName = contact ? (contact.remark || contact.name) : '对方';

                let quotedContentText;
                if (quotedMsg.segmentType === 'text') quotedContentText = quotedMsg.content;
                else if (quotedMsg.segmentType === 'voice') quotedContentText = '[语音]';
                else if (quotedMsg.segmentType === 'emoji-image') quotedContentText = '[表情包]';
                else quotedContentText = '[消息]';

                message = {
                    messageId: Utils.generateId('msg'),
                    content: `[引用] ${content}`,
                    timestamp: now,
                    type: 'sent',
                    segmentType: 'quote',
                    cardData: {
                        quotedName: senderName,
                        quotedContent: quotedContentText,
                        newContent: content
                    }
                };
                this.resetQuoteState();
            } else {
                const narratorRegex = /^<旁白>([\s\S]*)<\/旁白>$/;
                const narratorMatch = content.match(narratorRegex);

                if (narratorMatch) {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content: narratorMatch[1].trim(),
                        timestamp: now,
                        type: 'sent',
                        segmentType: 'narrator',
                    };
                } else {
                    message = {
                        messageId: Utils.generateId('msg'),
                        content,
                        timestamp: now,
                        type: 'sent',
                        isRetracted: false,
                        isUnread: false,
                        segmentType: 'text',
                    };
                }
            }
            
            message.chatId = appState.currentChatId;
            await DBHelper.put('messages', message);
            await UIManager.updateChatMetadata(appState.currentChatId, message);
            
            const chatMetadata = await DBHelper.get('chatMetadata', appState.currentChatId) || { chatId: appState.currentChatId, turnCountSinceLastPrompt: 0, totalPlayerTurns: 0 };
chatMetadata.turnCountSinceLastPrompt = (chatMetadata.turnCountSinceLastPrompt || 0) + 1;
chatMetadata.totalPlayerTurns = (chatMetadata.totalPlayerTurns || 0) + 1;
await DBHelper.put('chatMetadata', chatMetadata);

UIManager.addMessageToDOM(message, profile, false, true);

// 触发自动总结
const isGroup = appState.currentChatId.startsWith('group-');
const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', appState.currentChatId);
if (entity && entity.autoSummaryEnabled && chatMetadata.totalPlayerTurns > 0 && chatMetadata.totalPlayerTurns % 30 === 0) {
    console.log(`达到第 ${chatMetadata.totalPlayerTurns} 轮，触发自动总结。`);
    // 使用 setTimeout 确保它在后台运行，不阻塞UI
    setTimeout(() => AIHandler.handleAutoSummaryRequest(appState.currentChatId), 0);
}
            
            
            if (!prebuiltMessage) {
                messageInput.value = '';
                messageInput.style.height = 'auto';
                messageInput.focus();
            }
        },
            
            
            
            renderEmojiPage() {
                const emojiEntries = Object.entries(appState.playerEmojiMap);
                const pageCount = Math.ceil(emojiEntries.length / appState.emojisPerPage);

                if (appState.emojiCurrentPage < 0) appState.emojiCurrentPage = pageCount - 1;
                if (appState.emojiCurrentPage >= pageCount) appState.emojiCurrentPage = 0;
                
                const pageIndex = appState.emojiCurrentPage;
                const start = pageIndex * appState.emojisPerPage;
                const end = start + appState.emojisPerPage;
                const pageEmojis = emojiEntries.slice(start, end);

                emojiGrid.innerHTML = '';
                pageEmojis.forEach(([id, desc]) => {
                    const item = document.createElement('div');
                    item.className = 'emoji-item';
                    item.dataset.emojiId = id;
                    item.title = desc;
                    
                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }
                    
                    const isFavorite = appState.favoriteEmojis.includes(id);

                    item.innerHTML = `
                        <img src="${emojiSrc}" alt="${desc}">
                        <div class="favorite-emoji-toggle ${isFavorite ? 'is-favorite' : ''}" title="收藏">
                            <i class="fas fa-star"></i>
                        </div>
                    `;
                    
                    const imgEl = item.querySelector('img');
                    imgEl.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: id,
                            timestamp: Date.now(), // This will be correctly handled by the send function
                            type: 'sent',
                            segmentType: 'emoji-image',
                        };
                        // Use the centralized function to handle sending
                        await EventManager.handlePlayerSendMessage(message);
                        emojiCard.classList.remove('active');
                    });

                    const favToggle = item.querySelector('.favorite-emoji-toggle');
                    favToggle.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const emojiId = item.dataset.emojiId;
                        const index = appState.favoriteEmojis.indexOf(emojiId);
                        
                        if (index > -1) {
                            appState.favoriteEmojis.splice(index, 1);
                            favToggle.classList.remove('is-favorite');
                        } else {
                            appState.favoriteEmojis.push(emojiId);
                            favToggle.classList.add('is-favorite');
                        }
                        
                        const profile = await DBHelper.get('profile', 'myProfile');
                        profile.favoriteEmojis = appState.favoriteEmojis;
                        await DBHelper.put('profile', profile);
                    });
                    
                    emojiGrid.appendChild(item);
                });
                
                $('#emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
            },

            renderFavoriteEmojiPage() {
                favoriteEmojiGrid.innerHTML = '';
                const favNav = $('#favorite-emoji-card .emoji-nav');

                // 1. 先把固定的控制按钮加上
                const addEmojiBtn = document.createElement('div');
                addEmojiBtn.className = 'emoji-item-add';
                addEmojiBtn.innerHTML = '<i class="fas fa-plus"></i>';
                addEmojiBtn.title = '添加自定义表情';
                addEmojiBtn.onclick = () => this.showAddCustomEmojiModal();
                favoriteEmojiGrid.appendChild(addEmojiBtn);

                const deleteEmojiBtn = document.createElement('div');
                deleteEmojiBtn.className = 'emoji-item-add';
                deleteEmojiBtn.innerHTML = '<i class="fas fa-minus"></i>';
                deleteEmojiBtn.title = '删除自定义表情';
                deleteEmojiBtn.onclick = () => this.showDeleteCustomEmojiModal();
                favoriteEmojiGrid.appendChild(deleteEmojiBtn);

                // 2. 对收藏的表情进行分页
                const favoriteEmojis = appState.favoriteEmojis;
                // 每页能放的表情数 = 总槽位 - 控制按钮占用的槽位
                const emojiSlotsPerPage = appState.emojisPerPage - 2;

                // 如果没有表情或一页就能显示完，隐藏分页器
                if (favoriteEmojis.length === 0 || emojiSlotsPerPage <= 0 || favoriteEmojis.length <= emojiSlotsPerPage) {
                    favNav.style.display = 'none';
                } else {
                    favNav.style.display = 'flex';
                }
                
                if (favoriteEmojis.length === 0) return; // 如果没表情了，直接返回

                const pageCount = Math.ceil(favoriteEmojis.length / emojiSlotsPerPage);

                if (appState.favoriteEmojiCurrentPage < 0) appState.favoriteEmojiCurrentPage = 0;
                if (appState.favoriteEmojiCurrentPage >= pageCount) appState.favoriteEmojiCurrentPage = pageCount - 1;
                
                const pageIndex = appState.favoriteEmojiCurrentPage;
                const start = pageIndex * emojiSlotsPerPage;
                const end = start + emojiSlotsPerPage;
                const pageEmojis = favoriteEmojis.slice(start, end);

                pageEmojis.forEach(id => {
                    const desc = appState.playerEmojiMap[id] || '已收藏表情';
                    const emojiItem = document.createElement('div');
                    emojiItem.className = 'emoji-item';
                    emojiItem.dataset.emojiId = id;
                    emojiItem.title = desc;

                    let emojiSrc;
                    if (id.startsWith('custom-')) {
                        emojiSrc = appState.customEmojis[id]?.url || '';
                    } else {
                        emojiSrc = `https://z.wiki/u/${id}`;
                    }

                    emojiItem.innerHTML = `<img src="${emojiSrc}" alt="${desc}" style="width: 60px; height: 60px;">`;
                    
                    let longPressTimer;
                    let isLongPress = false;
                    
                    const startLongPress = (e) => {
                        isLongPress = false; // Reset on new press
                        longPressTimer = setTimeout(() => {
                            isLongPress = true;
                            UIManager.showModal({
                                title: "取消收藏",
                                body: `<p>要将这个表情移出收藏吗？</p>`,
                                actions: [
                                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                    { text: '确定', class: 'btn-danger', handler: async () => {
                                        const index = appState.favoriteEmojis.indexOf(id);
                                        if (index > -1) {
                                            appState.favoriteEmojis.splice(index, 1);
                                            const profile = await DBHelper.get('profile', 'myProfile');
                                            profile.favoriteEmojis = appState.favoriteEmojis;
                                            await DBHelper.put('profile', profile);
                                            this.renderFavoriteEmojiPage();
                                            UIManager.showToast("已取消收藏");
                                        }
                                        UIManager.hideModal();
                                    }}
                                ]
                            });
                        }, 500);
                    };

                    const cancelLongPress = () => clearTimeout(longPressTimer);
                    
                    const handleClick = async (e) => {
                        if (isLongPress) return;
                        await this.handlePlayerSendMessage({
                            messageId: Utils.generateId('msg'),
                            content: id,
                            type: 'sent',
                            segmentType: 'emoji-image',
                        });
                        favoriteEmojiCard.classList.remove('active');
                    };

                    emojiItem.addEventListener('mousedown', startLongPress);
                    emojiItem.addEventListener('touchstart', startLongPress, { passive: true });
                    emojiItem.addEventListener('mouseup', cancelLongPress);
                    emojiItem.addEventListener('mouseleave', cancelLongPress);
                    emojiItem.addEventListener('touchend', cancelLongPress);
                    emojiItem.addEventListener('touchcancel', cancelLongPress);
                    emojiItem.addEventListener('click', handleClick);

                    favoriteEmojiGrid.appendChild(emojiItem);
                });

                if (pageCount > 1) {
                    $('#favorite-emoji-page-indicator').textContent = `${pageIndex + 1} / ${pageCount}`;
                }
            },

            async showAddCustomEmojiModal() {
                UIManager.showModal({
                    title: "添加自定义表情",
                    body: `
                        <div class="form-group">
                            <label for="custom-emoji-url">表情包链接 (URL)</label>
                            <input type="text" id="custom-emoji-url" placeholder="请粘贴图片的URL">
                        </div>
                        <div class="form-group">
                            <label for="custom-emoji-name">表情包名称/描述</label>
                            <input type="text" id="custom-emoji-name" placeholder="例如：可爱猫猫摇尾巴">
                        </div>
                        <p style="font-size:0.8rem; color:#aaa;">表情包可以是静态图片/动态图片，表情包名称将用于AI理解表情含义，请准确填写含义。</p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const url = $('#custom-emoji-url').value.trim();
                            const name = $('#custom-emoji-name').value.trim();

                            if (!url || !name) {
                                return UIManager.showToast("链接和名称都不能为空。");
                            }
                            if (!url.startsWith('http')) {
                                return UIManager.showToast("请输入一个有效的URL。");
                            }

                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) {
                                profile.customEmojis = {};
                            }
                            
                            const emojiId = `custom-${Utils.generateId('')}`;
                            profile.customEmojis[emojiId] = { url, name };
                            await DBHelper.put('profile', profile);

                            // Update in-memory maps
                            appState.customEmojis[emojiId] = { url, name };
                            appState.playerEmojiMap[emojiId] = name;
                            appState.aiEmojiMap[emojiId] = name;

                            UIManager.hideModal();
                            UIManager.showToast("自定义表情添加成功！");
                            
                            if (!appState.favoriteEmojis.includes(emojiId)) {
                                appState.favoriteEmojis.push(emojiId);
                                profile.favoriteEmojis = appState.favoriteEmojis;
                                await DBHelper.put('profile', profile);
                            }
                            this.renderFavoriteEmojiPage();
                        }}
                    ]
                });
            },


            async showDeleteCustomEmojiModal() {
                const customEmojis = appState.customEmojis;
                if (Object.keys(customEmojis).length === 0) {
                    return UIManager.showToast("没有可删除的自定义表情");
                }

                const emojiListHtml = Object.entries(customEmojis).map(([id, data]) => `
                    <label class="member-select-item">
                        <input type="checkbox" name="delete-custom-emoji" value="${id}">
                        <img src="${data.url}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${data.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "删除自定义表情",
                    body: `<div class="member-select-list" style="max-height: 40vh;">${emojiListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除选中', class: 'btn-danger', handler: async () => {
                            const checkedEmojis = $$('input[name="delete-custom-emoji"]:checked');
                            if (checkedEmojis.length === 0) {
                                return UIManager.showToast("请选择要删除的表情");
                            }
                            const idsToDelete = Array.from(checkedEmojis).map(cb => cb.value);

                            const profile = await DBHelper.get('profile', 'myProfile');
                            if (!profile.customEmojis) profile.customEmojis = {};
                            if (!profile.favoriteEmojis) profile.favoriteEmojis = [];

                            // --- 核心修复：同时更新 appState ---
                            idsToDelete.forEach(id => {
                                // 从数据库对象中删除
                                delete profile.customEmojis[id];
                                const favIndexDB = profile.favoriteEmojis.indexOf(id);
                                if (favIndexDB > -1) {
                                    profile.favoriteEmojis.splice(favIndexDB, 1);
                                }
                                
                                // 从当前应用状态中删除
                                const favIndexApp = appState.favoriteEmojis.indexOf(id);
                                if (favIndexApp > -1) {
                                    appState.favoriteEmojis.splice(favIndexApp, 1);
                                }
                            });
                            // --- 修复结束 ---
                            
                            await DBHelper.put('profile', profile);

                            // Update app state maps and re-render
                            await this.setupEmojiMaps();
                            this.renderFavoriteEmojiPage();

                            UIManager.hideModal();
                            UIManager.showToast("选中的表情已删除");
                        }}
                    ]
                });
            },

        async initEmojiPanel() {
            this.renderEmojiPage(); 
        },

        handleVoiceInput() {
            UIManager.showModal({
                isPersistent: true, 
                customClass: 'modal-neumorphic',
                title: "发送语音",
                body: `
                    <div class="form-group">
                        <label for="modal-voice-text-input">语音内容 (文本)</label>
                        <textarea id="modal-voice-text-input" rows="4" placeholder="输入语音消息内容..."></textarea>
                    </div>
                `,
                actions: [
                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: '发送', class: 'btn-primary', handler: async () => {
                        const text = $('#modal-voice-text-input').value.trim();
                        if (!text) return;

                        let duration = Math.max(1, Math.ceil(text.length / 4));
                        duration = Math.min(duration, 60); 

                        const profile = await DBHelper.get('profile', 'myProfile');
                        const message = {
                            messageId: Utils.generateId('msg'),
                            content: `[语音] ${text}`,
                            timestamp: Date.now(),
                            type: 'sent',
                            segmentType: 'voice',
                            cardData: {
                                duration: `${duration}s`,
                                content: text
                            }
                        };
                        
                        await this.handlePlayerSendMessage(message);
                        UIManager.hideModal();
                    }}
                ]
            });
            setTimeout(() => $('#modal-voice-text-input').focus(), 100);
        },           

            async handlePlayerTransfer() {
                const isGroup = appState.currentChatId.startsWith('group-');
                let recipientHtml;
                let recipientName; 

                if (isGroup) {
                    
                    recipientHtml = `
                        <div class="form-group">
                            <label>转账给</label>
                            <div id="transfer-recipient-display" class="form-group" style="padding: 12px 15px; cursor: pointer; background: #F0F0F3; border-radius: 12px; box-shadow: inset -5px -5px 9px rgba(255,255,255,0.7), inset 5px 5px 9px rgba(174,174,192,0.2);">
                                <span style="color: #888;">请选择收款人</span>
                            </div>
                        </div>
                    `;
                } else {
                    
                    const contact = await DBHelper.get('contacts', appState.currentChatId);
                    recipientName = contact.name;
                }
                
                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "转账",
                    body: `
                        ${isGroup ? recipientHtml : ''}
                        <div class="form-group">
                            <label for="modal-transfer-amount">转账金额</label>
                            <input type="number" id="modal-transfer-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-transfer-note">备注 (选填)</label>
                            <input type="text" id="modal-transfer-note" placeholder="转账说明">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '转账', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-transfer-amount').value);
                            const note = $('#modal-transfer-note').value.trim();

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('请输入有效的金额');
                            }
                            if (isGroup && !recipientName) { 
                                return UIManager.showToast('请选择收款人');
                            }

                            const formattedAmount = `￥${amount.toFixed(2)}`;
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[转账] ${formattedAmount}`,
                                type: 'sent',
                                segmentType: 'transfer',
                                cardData: {
                                    recipientName: recipientName,
                                    amount: formattedAmount,
                                    note: note,
                                    isClaimed: false
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                
                if(isGroup) {
                    const displayDiv = $('#transfer-recipient-display');
                    displayDiv.addEventListener('click', async () => {
                         const group = await DBHelper.get('groups', appState.currentChatId);
                         const contacts = await DBHelper.getAll('contacts');
                         const members = group.members
                            .map(id => contacts.find(c => c.id === id))
                            .filter(Boolean);

                        if (members.length === 0) return;
                        
                        UIManager.showBottomSheet({
                            title: '选择收款人',
                            customClass: 'compact-list', 
                            items: members.map(m => ({ value: m.name, text: m.remark || m.name })),
                            onSelect: (value, text) => {
                                recipientName = value; 
                                displayDiv.querySelector('span').textContent = text; 
                                displayDiv.querySelector('span').style.color = 'var(--text-color-dark)';
                            }
                        });
                    });
                }
            },

            async handlePlayerRedPacket() {
                const isGroup = appState.currentChatId.startsWith('group-');
                const groupOnlyHtml = isGroup ? `
                    <div class="form-group">
                        <label for="modal-rp-count">红包个数</label>
                        <input type="number" id="modal-rp-count" value="1" min="1" step="1">
                    </div>
                ` : '';

                UIManager.showModal({
                    isPersistent: true, 
                    customClass: 'modal-neumorphic',
                    title: "发红包",
                    body: `
                        <div class="form-group">
                            <label for="modal-rp-amount">总金额</label>
                            <input type="number" id="modal-rp-amount" placeholder="0.00" min="0.01" step="0.01">
                        </div>
                        <div class="form-group">
                            <label for="modal-rp-title">红包祝福语 (选填)</label>
                            <input type="text" id="modal-rp-title" placeholder="恭喜发财，大吉大利">
                        </div>
                        ${groupOnlyHtml}
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '塞钱进红包', class: 'btn-primary', handler: async () => {
                            const amount = parseFloat($('#modal-rp-amount').value);
                            const title = $('#modal-rp-title').value.trim() || '恭喜发财，大吉大利';
                            const count = isGroup ? parseInt($('#modal-rp-count').value, 10) : 1;

                            if (isNaN(amount) || amount <= 0) {
                                return UIManager.showToast('请输入有效的金额');
                            }
                            if (isGroup && (isNaN(count) || count <= 0)) {
                                return UIManager.showToast('请输入有效的红包个数');
                            }
                            if (isGroup && amount < count * 0.01) {
                                return UIManager.showToast('单个红包金额不能少于0.01元');
                            }

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[红包] ${title}`,
                                type: 'sent',
                                segmentType: 'red-packet',
                                cardData: {
                                    title: title,
                                    amount: amount,
                                    count: count,
                                    isClaimedByPlayer: false, 
                                    claimedBy: []
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
            },
           
            
            
            handleInteractionStart(e, type) {
                const bubble = e.target.closest('.bubble');
                if (!bubble) return;

                const messageRow = bubble.closest('.message-row');
                if (!messageRow || !messageRow.dataset.messageId) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) {
                        existingButton.remove();
                    }
                    
                    if (messageRow.classList.contains('received')) {
                        this.showMessageOptions(messageRow, 'received');
                    } else if (messageRow.classList.contains('sent')) {
                        this.showMessageOptions(messageRow, 'sent');
                    }
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            async startQuote(messageRowElement) {
                const messageId = messageRowElement.dataset.messageId;
                const messageData = await DBHelper.get('messages', messageId);
                if (!messageData || messageData.isRetracted) return;

                appState.quotingMessage = messageData;
                const contact = await DBHelper.get('contacts', messageData.senderId);
                const senderName = contact ? (contact.remark || contact.name) : '对方';

                let quotedContentText;
                if (messageData.segmentType === 'text') quotedContentText = messageData.content;
                else if (messageData.segmentType === 'voice') quotedContentText = '[语音]';
                else if (messageData.segmentType === 'emoji-image') quotedContentText = '[表情包]';
                else return;
                
                quotePreviewContent.textContent = `${senderName}: ${quotedContentText}`;
                quotePreviewArea.style.display = 'flex';
                messageInput.focus();
            },

            resetQuoteState() {
                appState.quotingMessage = null;
                quotePreviewArea.style.display = 'none';
            },

            async showMessageOptions(messageRowElement, messageType) {
                const messageId = messageRowElement.dataset.messageId;
                if (!messageId) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';

                let buttonsHtml = '';
                if (messageType === 'sent') {
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> 删除</button>
                        <button class="retract-btn" data-action="retract"><i class="fas fa-undo"></i> 撤回</button>
                    `;
                } else { 
                    buttonsHtml = `
                        <button class="retract-btn" data-action="delete"><i class="fas fa-trash"></i> 删除</button>
                        <button class="retract-btn" data-action="quote"><i class="fas fa-quote-left"></i> 引用</button>
                    `;
                }
                wrapper.innerHTML = buttonsHtml;
                
                
                wrapper.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;

                    if (action === 'delete') {
                        await DBHelper.delete('messages', messageId);
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.remove();
                        wrapper.remove();
                    } else if (action === 'retract') {
                        const msgToRetract = await DBHelper.get('messages', messageId);
                        if (!msgToRetract) return;

                        msgToRetract.isRetracted = true;
                        await DBHelper.put('messages', msgToRetract);

                        const myProfile = await DBHelper.get('profile', 'myProfile');
                        const retractionNotice = UIManager.createRetractionNotice(msgToRetract, myProfile);
                        
                        const originalRow = $(`#${messageId}`);
                        if (originalRow) originalRow.replaceWith(retractionNotice);
                        wrapper.remove();
                    } else if (action === 'quote') {
                        this.startQuote(messageRowElement);
                        wrapper.remove();
                    }
                });

                const bubbleWrapper = messageRowElement.querySelector('.bubble-and-tag-wrapper');
                if (bubbleWrapper) {
                    bubbleWrapper.appendChild(wrapper);
                    setTimeout(() => wrapper.classList.add('show'), 10);
                }

                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async handleEditProfile() {
                const profile = await DBHelper.get('profile', 'myProfile');
                UIManager.showSidebar({
                    position: 'left', 
                    title: "我的信息",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${profile.avatar}" id="profile-avatar-preview" class="avatar-preview">
                                <input type="file" id="profile-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('profile-avatar-input').click()">上传新头像</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="profile-name-input">姓名</label>
                            <input type="text" id="profile-name-input" value="${profile.name}">
                        </div>
                        <div class="form-group">
                            <label for="profile-gender-select">性别</label>
                            <select id="profile-gender-select">
                                <option value="男" ${profile.gender === '男' ? 'selected' : ''}>男</option>
                                <option value="女" ${profile.gender === '女' ? 'selected' : ''}>女</option>
                                <option value="其他" ${profile.gender === '其他' ? 'selected' : ''}>其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="profile-background-input">背景资料 (选填)</label>
                            <textarea id="profile-background-input">${profile.background || ''}</textarea>
                        </div>
                        <div class="details-actions" style="margin-top: 20px; flex-direction: row; justify-content: space-around; gap: 10px;">
                            <button class="details-btn" id="load-profile-preset-btn" style="flex: 1;">读取</button>
                            <button class="details-btn" id="save-profile-preset-btn" style="flex: 1;">保存</button>
                            <button class="details-btn" id="delete-profile-preset-btn" style="flex: 1;">删除</button>
                        </div>
                        <p style="text-align: center; font-size: 12px; color: #aaa; user-select: none; margin-top: 30px;">此聊天室由33制作，xhs:@回风</p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideSidebar() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const newAvatar = $('#profile-avatar-preview').src;
                            const newName = $('#profile-name-input').value.trim();
                            if (!newName) { 
                                UIManager.showModal({ title:"提示", body:"<p>姓名不能为空！</p>", actions:[{text:"好的", class:"btn-primary", handler:()=>UIManager.hideModal()}]});
                                return; 
                            }
                            
                            const updatedProfile = {
                                ...profile,
                                avatar: newAvatar,
                                name: newName,
                                gender: $('#profile-gender-select').value,
                                background: $('#profile-background-input').value.trim()
                            };
                            
                            await DBHelper.put('profile', updatedProfile);
                            $('#my-avatar').src = newAvatar;
                            UIManager.hideSidebar();
                        }}
                    ]
                });
                
                
                $('#profile-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const base64 = await Utils.fileToBase64(file);
                        $('#profile-avatar-preview').src = base64;
                    }
                });


                $('#load-profile-preset-btn').addEventListener('click', () => this.handleLoadProfilePreset());
                $('#save-profile-preset-btn').addEventListener('click', () => this.handleSaveProfilePreset());
                $('#delete-profile-preset-btn').addEventListener('click', () => this.handleDeleteProfilePreset());
            },

            async handleLoadProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p); // 过滤掉可能的null值

                if (presets.length === 0) {
                    return UIManager.showToast("没有可读取的预设");
                }

                const items = presets.map((preset) => ({
                    value: preset.presetId, // 使用唯一的 presetId
                    text: preset.name
                }));

                UIManager.showBottomSheet({
                    title: '选择要读取的预设',
                    items: items,
                    onSelect: (presetId) => { // 回调接收的是 presetId
                        const selectedPreset = presets.find(p => p.presetId === presetId);
                        if (selectedPreset) {
                            $('#profile-avatar-preview').src = selectedPreset.avatar;
                            $('#profile-name-input').value = selectedPreset.name;
                            $('#profile-gender-select').value = selectedPreset.gender;
                            $('#profile-background-input').value = selectedPreset.background || '';
                            UIManager.showToast(`已加载预设 "${selectedPreset.name}"`);
                        }
                    }
                });
            },
            
            async handleSaveProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                const items = [{
                    value: 'new',
                    text: `保存为新预设 (${presets.length}/20)`
                }];

                presets.forEach((preset) => {
                    items.push({
                        value: preset.presetId, // 使用 presetId
                        text: `覆盖预设: ${preset.name}`
                    });
                });

                UIManager.showBottomSheet({
                    title: '保存预设',
                    items: items,
                    onSelect: (value) => { // value 现在是 presetId 或 'new'
                        const currentData = {
                            name: $('#profile-name-input').value.trim(),
                            avatar: $('#profile-avatar-preview').src,
                            gender: $('#profile-gender-select').value,
                            background: $('#profile-background-input').value.trim()
                        };

                        if (!currentData.name) {
                            UIManager.showToast("保存失败，姓名不能为空");
                            return;
                        }

                        if (value === 'new') {
                            this.confirmAndSavePreset(null, currentData); // 传入 null 代表新建
                        } else {
                            this.confirmAndSavePreset(value, currentData); // 传入 presetId
                        }
                    }
                });
            },
            
            async confirmAndSavePreset(presetIdToOverwrite, currentData) {
                const profile = await DBHelper.get('profile', 'myProfile');
                const isNew = presetIdToOverwrite === null;
                const existingPreset = isNew ? null : (profile.presets || []).find(p => p.presetId === presetIdToOverwrite);

                const doSave = async (presetName) => {
                    const newPreset = {
                        ...currentData,
                        name: presetName,
                        presetId: isNew ? Utils.generateId('persona') : presetIdToOverwrite
                    };

                    // 直接使用已经获取到的 profile 对象，避免重复读取
                    profile.presets = (profile.presets || []).filter(p => p);

                    if (isNew) {
                        if (profile.presets.length >= 20) {
                            UIManager.showToast("预设已达到20个上限");
                            return;
                        }
                        profile.presets.push(newPreset);
                    } else {
                        const indexToUpdate = profile.presets.findIndex(p => p.presetId === presetIdToOverwrite);
                        if (indexToUpdate !== -1) {
                            profile.presets[indexToUpdate] = newPreset;
                        } else {
                            // 如果找不到要覆盖的，就当作新的添加
                            profile.presets.push(newPreset);
                        }
                    }

                    await DBHelper.put('profile', profile); // 保存更新后的整个 profile 对象
                    UIManager.hideModal();
                    UIManager.showToast(`预设 "${presetName}" 已保存`);
                };

                UIManager.showModal({
                    title: isNew ? '保存为新预设' : '覆盖预设',
                    body: `
                        <p>${existingPreset ? `这将覆盖预设 "${existingPreset.name}"。` : '为这个新预设起个名字吧。'}</p>
                        <div class="form-group">
                            <label for="preset-name-input">预设名称</label>
                            <input type="text" id="preset-name-input" value="${existingPreset ? existingPreset.name : currentData.name}">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认保存', class: 'btn-primary', handler: () => {
                            const presetName = $('#preset-name-input').value.trim();
                            if (!presetName) {
                                UIManager.showToast("预设名称不能为空");
                                return;
                            }
                            doSave(presetName);
                        }}
                    ]
                });
            },

            async handleDeleteProfilePreset() {
                const profile = await DBHelper.get('profile', 'myProfile');
                const presets = (profile.presets || []).filter(p => p);

                if (presets.length === 0) {
                    UIManager.showToast("没有可删除的预设");
                    return;
                }
                
                const items = presets.map(preset => ({
                    value: preset.presetId, // 使用唯一的 presetId 作为 value
                    text: `删除预设: ${preset.name}`
                }));

                if (items.length === 0) {
                     UIManager.showToast("没有可删除的预设");
                     return;
                }

                UIManager.showBottomSheet({
                    title: '选择要删除的预设',
                    items: items,
                    onSelect: (presetIdToDelete) => {
                        const presetToDelete = presets.find(p => p.presetId === presetIdToDelete);
                        if (!presetToDelete) return;
                        
                        UIManager.showModal({
                            title: '确认删除',
                            body: `<p>确定要删除预设 "${presetToDelete.name}" 吗？所有与此预设的绑定都将被清除。</p>`,
                            actions: [
                                { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                                { text: '删除', class: 'btn-danger', handler: async () => {
                                    // 1. 更新所有绑定到此预设的实体
                                    const storesToUpdate = ['contacts', 'groups', 'friendFolders', 'circles'];
                                    for (const storeName of storesToUpdate) {
                                        const entities = await DBHelper.getAll(storeName);
                                        for (const entity of entities) {
                                            if (entity.boundPersonaPresetId === presetIdToDelete) {
                                                entity.boundPersonaPresetId = null; // 解除绑定
                                                await DBHelper.put(storeName, entity);
                                            }
                                        }
                                    }

                                    // 2. 从 profile 中移除该预设
                                    const profileToUpdate = await DBHelper.get('profile', 'myProfile');
                                    profileToUpdate.presets = profileToUpdate.presets.filter(p => p.presetId !== presetIdToDelete);
                                    await DBHelper.put('profile', profileToUpdate);
                                    
                                    UIManager.hideModal();
                                    UIManager.showToast(`预设 "${presetToDelete.name}" 已删除`);
                                }}
                            ]
                        });
                    }
                });
            },

            showAddMenu() {
                UIManager.showModal({
                    title: "新建/导入",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0;">
                            <div class="setting-item" id="add-friend-menu">
                                <i class="fas fa-user-plus"></i>
                                <span>添加新好友</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-group-menu">
                                <i class="fas fa-users"></i>
                                <span>新建群聊</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="create-friend-folder-menu">
                                <i class="fas fa-folder-plus"></i>
                                <span>新建分组</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="add-builtin-character-menu">
                                <i class="fas fa-user-secret"></i>
                                <span>新增内置角色</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                             <div class="setting-item" id="import-data-menu">
                                <i class="fas fa-file-import"></i>
                                <span>导入角色/群聊</span>
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>`,
                    actions: [] 
                });
                
                $('#add-friend-menu').addEventListener('click', () => this.handleAddFriend());
                $('#create-group-menu').addEventListener('click', () => this.handleCreateGroup());
                $('#add-builtin-character-menu').addEventListener('click', () => this.showBuiltinCharacterSelection());
                $('#import-data-menu').addEventListener('click', () => this.handleImportData());
                $('#create-friend-folder-menu').addEventListener('click', () => this.showAddEditFriendFolderModal());
            },
            
            handleAddFriend() {
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());
                UIManager.showModal({
                    isPersistent: true, 
                    title: "添加新好友",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="add-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="add-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('add-friend-avatar-input').click()">上传头像</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-name">姓名 (唯一ID, 必填)</label>
                            <input type="text" id="add-friend-name" placeholder="为AI好友起个名字">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-remark">备注 (选填)</label>
                            <input type="text" id="add-friend-remark" placeholder="你对TA的称呼">
                        </div>
                        <div class="form-group">
                            <label for="add-friend-gender">性别 (必填)</label>
                            <select id="add-friend-gender">
                                <option value="男">男</option>
                                <option value="女">女</option>
                                <option value="其他">其他</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-retraction">允许撤回消息</label>
                            <select id="add-friend-allow-retraction">
                                <option value="true" selected>开启</option>
                                <option value="false">关闭</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-allow-emoji">允许发送表情包</label>
                            <select id="add-friend-allow-emoji">
                                <option value="on" selected>开启</option>
                                <option value="off">关闭</option>
                                <option value="prob">概率</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-likes">喜好 (选填)</label>
                            <textarea id="add-friend-likes" placeholder="例如：甜食、运动、旅游"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-dislikes">厌恶 (选填)</label>
                            <textarea id="add-friend-dislikes" placeholder="例如：被忽视、下雨"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-habits">习惯 (选填)</label>
                            <textarea id="add-friend-habits" placeholder="例如：晨跑、运动"></textarea>
                        </div>
                        <div class="form-group">
                            <label for="add-friend-background">背景资料 (选填)</label>
                            <textarea id="add-friend-background" placeholder="角色的其他资料"></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal(); 
                            this.showAddMenu(); 
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const name = $('#add-friend-name').value.trim();
                            if (!name) { 
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>好友的姓名不能为空哦。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return; 
                            }
                            
                            
                            const existing = await DBHelper.getAll('contacts', 'name');
                            if (existing.some(c => c.name === name)) {
                                this.showAddMenu(); 
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>姓名 "${name}" 已经被其他好友占用了，换一个吧。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const newContact = {
                                id: Utils.generateId('contact'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#add-friend-avatar-preview').src,
                                remark: $('#add-friend-remark').value.trim(),
                                gender: $('#add-friend-gender').value,
                                allowRetraction: $('#add-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#add-friend-allow-emoji').value,
                                likes: $('#add-friend-likes').value.trim(),
                                dislikes: $('#add-friend-dislikes').value.trim(),
                                habits: $('#add-friend-habits').value.trim(),
                                background: $('#add-friend-background').value.trim()
                            };
                            
                            await DBHelper.put('contacts', newContact);
                            UIManager.hideModal();
                            await UIManager.renderContactsPage();
                        }}
                    ]
                });

                $('#add-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#add-friend-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            async showBuiltinCharacterSelection() {
                const existingContacts = await DBHelper.getAll('contacts');
                const existingNames = existingContacts.map(c => c.name);

                const charactersHtml = Object.entries(this.BUILTIN_CHARACTERS).map(([id, char]) => {
                    const isAdded = existingNames.includes(id);
                    return `
                        <label class="member-select-item" style="${isAdded ? 'opacity: 0.5; cursor: not-allowed;' : 'cursor: pointer;'}">
                            <input type="radio" name="builtin-char" value="${id}" ${isAdded ? 'disabled' : ''}>
                            <img src="${char.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px;">
                            <div>
                                <span style="font-weight: bold;">${char.remark}</span>
                                <p style="font-size: 0.8rem; color: #888; margin: 2px 0 0 0;">${char.previewDesc || char.likes}</p>
                            </div>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: '选择内置角色',
                    body: `<div class="member-select-list" style="max-height: 40vh;">${charactersHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '添加', class: 'btn-primary', handler: () => {
                            const selectedRadio = $('input[name="builtin-char"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("请选择一个要添加的角色");
                                return;
                            }
                            this.addSpecificBuiltinCharacter(selectedRadio.value);
                        }}
                    ]
                });
            },

            async addSpecificBuiltinCharacter(characterId) {
                const charData = this.BUILTIN_CHARACTERS[characterId];
                if (!charData) {
                    UIManager.showToast("未找到该内置角色");
                    return;
                }

                const existing = await DBHelper.getAll('contacts');
                if (existing.some(c => c.name === charData.id)) {
                    UIManager.showToast(`角色 "${charData.remark}" 已存在`);
                    UIManager.hideModal();
                    return;
                }

                const newContact = {
                    id: Utils.generateId('contact'),
                    createdAt: Date.now(),
                    name: charData.id,
                    remark: charData.remark,
                    avatar: charData.avatar,
                    gender: charData.gender,
                    likes: charData.likes,
                    dislikes: charData.dislikes,
                    habits: charData.habits,
                    background: charData.background
                };

                await DBHelper.put('contacts', newContact);
                UIManager.hideModal();
                await UIManager.renderContactsPage();
                UIManager.showToast(`内置角色 “${charData.remark}” 已添加`);
            },

            async handleCreateGroup() {
                const friends = await DBHelper.getAll('contacts');
                if (friends.length === 0) {
                     this.showAddMenu(); 
                     UIManager.showModal({
                         title: "提示",
                         body: `<p>通讯录中还没有好友，快去添加一些好友再来创建群聊吧！</p>`,
                         actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                     });
                     return;
                }
                
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const defaultAvatar = Utils.createAvatarDataUrl(Utils.getRandomColor());

                const memberListHtml = friends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="group-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');
                
                
                const creatorOptionsHtml = `<option value="${myProfile.id}">我 (${myProfile.name})</option>` + friends.map(f =>
                    `<option value="${f.id}">${f.remark || f.name}</option>`
                ).join('');

                UIManager.showModal({
                    title: "新建群聊",
                    body: `
                         <div class="form-group">
                            <label>群头像 (选填)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultAvatar}" id="create-group-avatar-preview" class="avatar-preview">
                                <input type="file" id="create-group-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('create-group-avatar-input').click()">上传头像</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="create-group-name">群名称 (必填)</label>
                            <input type="text" id="create-group-name" placeholder="为群聊起个名字">
                        </div>
                        <div class="form-group">
                            <label for="create-group-creator">选择群主 (必填)</label>
                            <select id="create-group-creator">${creatorOptionsHtml}</select>
                        </div>
                        <div class="form-group">
                            <label>选择群成员</label>
                            <div class="member-select-list">${memberListHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#create-group-name').value.trim();
                            if (!name) {
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>群聊还没有名字呢，给它起一个吧。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const selectedMembers = [...$$('input[name="group-members"]:checked')].map(cb => cb.value);
                            if (selectedMembers.length < 1) { 
                                UIManager.showModal({
                                    title: "提示",
                                    body: `<p>创建群聊至少需要选择一位好友哦。</p>`,
                                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                                });
                                return;
                            }
                            
                            const creatorId = $('#create-group-creator').value;
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            
                            if (creatorId !== myProfile.id && !selectedMembers.includes(creatorId)) {
                                selectedMembers.push(creatorId);
                            }

                            const newGroup = {
                                id: Utils.generateId('group'),
                                createdAt: Date.now(),
                                name,
                                avatar: $('#create-group-avatar-preview').src,
                                members: selectedMembers,
                                creatorId: creatorId 
                            };
                            
                            await DBHelper.put('groups', newGroup);

                            
                            try {
                                const creatorContact = creatorId === myProfile.id ? myProfile : await DBHelper.get('contacts', creatorId);
                                const memberNames = (await Promise.all(
                                    selectedMembers.map(id => DBHelper.get('contacts', id))
                                )).filter(Boolean).map(c => c.name).join('、');

                                
                                const creatorNameForScene = creatorContact ? creatorContact.name : "一位神秘的朋友";
                                const defaultSceneContent = `${creatorNameForScene} 创建了群聊 “${newGroup.name}”，群聊成员有：${memberNames}、${myProfile.name}。现在，大家开始积极发言吧！`;
                                const defaultScene = {
                                    id: Utils.generateId('scene'),
                                    groupId: newGroup.id,
                                    name: '默认开场白',
                                    content: defaultSceneContent
                                };
                                await DBHelper.put('openingScenes', defaultScene);
                            } catch(e) {
                                console.error("创建默认开场白失败:", e);
                            }

                            UIManager.hideModal();
                            await UIManager.renderContactsPage('groups');
                        }}
                    ]
                });
                
                 $('#create-group-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#create-group-avatar-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },
            
            async handleSortContacts() {
                appState.contactsSortOrder = appState.contactsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('friends');
            },
            
            async handleSortGroups() {
                appState.groupsSortOrder = appState.groupsSortOrder === 'asc' ? 'desc' : 'asc';
                await UIManager.renderContactsPage('groups');
            },
            
            async handleBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const actionBar = $('#selection-action-bar');
                const contactsPage = $('#page-contacts');
                
                if (activeTab === 'friends') {
                    appState.friendSelectionMode = !appState.friendSelectionMode;
                    appState.groupSelectionMode = false; // Ensure other mode is off
                } else {
                    appState.groupSelectionMode = !appState.groupSelectionMode;
                    appState.friendSelectionMode = false; // Ensure other mode is off
                }
                
                const isAnyModeActive = appState.friendSelectionMode || appState.groupSelectionMode;
                actionBar.style.display = isAnyModeActive ? 'flex' : 'none';
                contactsPage.classList.toggle('selection-mode', isAnyModeActive);
                
                await UIManager.renderContactsPage(activeTab);
            },

            handleSelectAll() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkboxes = $$(`${listId} .contact-select-checkbox`);
                const allChecked = Array.from(checkboxes).every(cb => cb.checked);
                checkboxes.forEach(cb => cb.checked = !allChecked);
            },
            
            async handleConfirmBatchDelete() {
                const activeTab = $('.tabs .tab-btn.active').dataset.tab;
                const listId = activeTab === 'friends' ? '#friends-list-ul' : '#groups-list-ul';
                const checkedItems = $$(`${listId} .contact-select-checkbox:checked`);
                
                if (checkedItems.length === 0) {
                    return UIManager.showToast("请至少选择一项");
                }
                
                const idsToDelete = Array.from(checkedItems).map(cb => cb.closest('.contact-item').dataset.id);

                if (activeTab === 'friends') {
                    const allGroups = await DBHelper.getAll('groups');
                    const problematicFriends = [];
                    for (const friendId of idsToDelete) {
                        const groupsIn = allGroups.filter(g => g.members.includes(friendId));
                        if (groupsIn.length > 0) {
                            const friend = await DBHelper.get('contacts', friendId);
                            problematicFriends.push({ name: friend.name, groups: groupsIn.map(g => g.name).join(', ') });
                        }
                    }

                    if (problematicFriends.length > 0) {
                        const errorMsg = problematicFriends.map(p => `<strong>${p.name}</strong> 仍在群聊: ${p.groups}`).join('<br>');
                        return UIManager.showModal({
                            title: "无法删除",
                            body: `<p>以下好友因仍在群聊中而无法删除，请先将其移出群聊：</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                            actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                        });
                    }
                }

                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除选中的 ${idsToDelete.length} 个${activeTab === 'friends' ? '好友' : '群聊'}吗？相关聊天记录也将被永久删除。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const storeName = activeTab === 'friends' ? 'contacts' : 'groups';
                            for (const id of idsToDelete) {
                                await DBHelper.delete(storeName, id);
                                await DBHelper.delete('chats', id);
                                await DBHelper.delete('chatMetadata', id); // 新增：删除聊天元数据
                            }
                            UIManager.hideModal();
                            UIManager.showToast("删除成功");
                            this.handleBatchDelete(); // Exit selection mode and refresh
                            await UIManager.renderMessagesListPage(); // 新增：刷新消息列表
                        }}
                    ]
                });
            },

            handleImportData() {
                const fileInput = $('#import-data-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            await this.processImportedFile(data);
                        } catch (error) {
                            console.error("导入失败:", error);
                            UIManager.showToast("文件解析失败，请检查文件格式。");
                        } finally {
                            fileInput.value = ''; 
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async processImportedFile(data) {
                if (data.type === 'contact' && data.contactData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflict = existingContacts.find(c => c.name === data.contactData.name);
                    if (conflict) {
                        this.handleCharacterImportConflict(data, conflict);
                    } else {
                        const importedContact = data.contactData;
                        // Use the original ID from the imported file
                        const newContact = { ...importedContact, createdAt: Date.now() }; 
                        delete newContact.openingScenes; // Avoid storing scenes inside contact object

                        await DBHelper.put('contacts', newContact);
                        await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);
                        
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newContact.id; // 确保chatId已设置
                                    await DBHelper.put('messages', message);
                                }
                                
                                // 更新聊天元数据
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                }
                            }
                        }
                        
                        UIManager.showToast(`角色 "${newContact.name}" 导入成功！`);
                        if (newContact.author) {
                           EventManager.showAttributionModal(newContact);
                        }
                        await UIManager.renderContactsPage();
                        await UIManager.renderMessagesListPage(); // 新增：刷新消息列表
                    }
                } else if (data.type === 'group' && data.groupData && data.memberData) {
                    const existingContacts = await DBHelper.getAll('contacts');
                    const conflictingMembers = data.memberData.filter(im => existingContacts.some(ec => ec.name === im.name));

                    if (conflictingMembers.length > 0) {
                        this.handleGroupImportConflict(data, conflictingMembers);
                    } else {
                        // Import members with their original IDs
                        for (const member of data.memberData) {
                            const newMember = { ...member, createdAt: Date.now() };
                            delete newMember.openingScenes;
                            await DBHelper.put('contacts', newMember);
                            await this.importOpeningScenes(member.openingScenes, member.id, false);
                        }
                        
                        // Import the group, checking for its own ID conflict
                        const importedGroup = data.groupData;
                        const existingGroup = await DBHelper.get('groups', importedGroup.id);
                        
                        const newGroup = {
                            ...importedGroup,
                            createdAt: Date.now()
                        };
                        // If group ID conflicts, generate a new one
                        if(existingGroup) {
                            newGroup.id = Utils.generateId('group');
                        }
                        delete newGroup.openingScenes;

                        await DBHelper.put('groups', newGroup);
                        
                        // 导入聊天记录，由于成员ID已保留，因此无需映射。
                        if (data.chatHistory && data.participants) {
                            const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                            if (reconstructedHistory && reconstructedHistory.history) {
                                for (const message of reconstructedHistory.history) {
                                    message.chatId = newGroup.id; // 确保chatId已设置
                                    await DBHelper.put('messages', message);
                                }

                                // 更新聊天元数据
                                const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                if (displayableHistory.length > 0) {
                                    const lastMessage = displayableHistory[displayableHistory.length - 1];
                                    const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                    await UIManager.updateChatMetadata(newGroup.id, lastMessage, unreadCount);
                                }
                            }
                        }

                        await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                        UIManager.showToast(`群聊 "${newGroup.name}" 及所有成员导入成功！`);
                        if (newGroup.author) {
                            EventManager.showAttributionModal(newGroup);
                        }
                        await UIManager.renderContactsPage('groups');
                        await UIManager.renderMessagesListPage(); // 新增：刷新消息列表
                    }
                } else {
                    UIManager.showToast("导入失败：文件类型未知或数据不完整。");
                }
            },

            handleCharacterImportConflict(data, existingContact) {
                const importedContact = data.contactData;
                UIManager.showModal({
                    title: "角色冲突",
                    body: `<p>通讯录中已存在名为 <strong>${existingContact.name}</strong> 的角色。<br><strong>更新</strong>：不清除原消息记录<br><strong>覆盖</strong>：清除该角色原来的消息记录<br>请选择操作：</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '更新角色', class: 'btn-primary', handler: async () => {
                            const updatedContact = { ...existingContact, ...importedContact, id: existingContact.id };
                            delete updatedContact.openingScenes; 
                            await DBHelper.put('contacts', updatedContact);
                            
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await this.importOpeningScenes(importedContact.openingScenes, existingContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`角色 "${existingContact.name}" 已更新。`);
                            if(updatedContact.author) EventManager.showAttributionModal(updatedContact);
                            await UIManager.renderContactsPage();
                        }},
                        { text: '覆盖角色', class: 'btn-danger', handler: async () => {
                            // Delete existing data associated with the conflicting contact
                            await DBHelper.delete('chats', existingContact.id);
                            await DBHelper.deleteMessagesForChat(existingContact.id); // <-- 这是关键的修复
                            await DBHelper.delete('chatMetadata', existingContact.id); 
                            const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existingContact.id);
                            for (const scene of oldScenes) {
                                await DBHelper.delete('openingScenes', scene.id);
                            }
                            await DBHelper.delete('contacts', existingContact.id);

                            // Re-import with the original ID
                            const newContact = { ...importedContact, id: importedContact.id, createdAt: Date.now() };
                            delete newContact.openingScenes;
                            await DBHelper.put('contacts', newContact);
                            
                            // Import history using original ID
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = newContact.id; // 确保chatId已设置
                                        await DBHelper.put('messages', message);
                                    }
                                    // Re-create metadata if history is imported
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(newContact.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedContact.openingScenes, newContact.id, false);

                            UIManager.hideModal();
                            UIManager.showToast(`角色 "${newContact.name}" 已被覆盖。`);
                            if(newContact.author) EventManager.showAttributionModal(newContact);
                            await UIManager.renderContactsPage();
                            await UIManager.renderMessagesListPage(); // 新增：刷新消息列表
                        }}
                    ]
                });
            },

            handleGroupImportConflict(data, conflictingMembers) {
                const importedGroup = data.groupData;
                const importedMembers = data.memberData;
                const conflictNames = conflictingMembers.map(m => m.name).join('、');
                UIManager.showModal({
                    title: "群聊成员冲突",
                    body: `<p>在导入群聊 <strong>${importedGroup.name}</strong> 时，发现以下成员已存在于你的通讯录中：<br><strong>${conflictNames}</strong><br>请选择如何处理这些冲突的角色。<br><strong>更新</strong>：不清除原消息记录<br><strong>覆盖</strong>：清除该角色原来的消息记录</p>`,
                    actions: [
                        { text: '取消导入', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '全部更新', class: 'btn-primary', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const memberIdMap = {};
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                let finalMember;
                                if (existing) {
                                    finalMember = { ...existing, ...member, id: existing.id };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await this.importOpeningScenes(member.openingScenes, existing.id, false);
                                } else {
                                    finalMember = { ...member, id: Utils.generateId('contact'), createdAt: Date.now() };
                                    delete finalMember.openingScenes;
                                    await DBHelper.put('contacts', finalMember);
                                    await this.importOpeningScenes(member.openingScenes, finalMember.id, false);
                                }
                                memberIdMap[member.id] = finalMember.id;
                            }
                            
                            const newMemberIds = importedGroup.members.map(oldId => memberIdMap[oldId]).filter(Boolean);
                            const newCreatorId = memberIdMap[importedGroup.creatorId] || importedGroup.creatorId;
                            const newGroup = { ...importedGroup, id: Utils.generateId('group'), createdAt: Date.now(), members: newMemberIds, creatorId: newCreatorId };
                            delete newGroup.openingScenes;

                            await DBHelper.put('groups', newGroup);
                            await this.importOpeningScenes(importedGroup.openingScenes, newGroup.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`群聊 "${importedGroup.name}" 导入成功，冲突成员已更新。`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                        }},
                        { text: '全部覆盖', class: 'btn-danger', handler: async () => {
                            const existingContacts = await DBHelper.getAll('contacts');
                            const existingGroups = await DBHelper.getAll('groups');
                            
                            // Delete existing group if name conflicts
                            const oldGroup = existingGroups.find(g => g.name === importedGroup.name);
                            if (oldGroup) {
                                await DBHelper.deleteMessagesForChat(oldGroup.id); // <-- 这是关键的修复
                                await DBHelper.deleteMessagesForChat(oldGroup.id); // <-- 这是关键的修复
                                await DBHelper.delete('chats', oldGroup.id);
                                await DBHelper.delete('chatMetadata', oldGroup.id);
                                await DBHelper.delete('groups', oldGroup.id);
                            }

                            // Delete conflicting members and their data
                            for (const member of importedMembers) {
                                const existing = existingContacts.find(c => c.name === member.name);
                                if (existing) {
                                    await DBHelper.delete('chats', existing.id);
                                    await DBHelper.delete('chatMetadata', existing.id); // 新增：删除旧的成员元数据
                                    const oldScenes = (await DBHelper.getAll('openingScenes')).filter(s => s.contactId === existing.id);
                                    for (const scene of oldScenes) await DBHelper.delete('openingScenes', scene.id);
                                    await DBHelper.delete('contacts', existing.id);
                                }
                            }
                            
                            // Now import all members with their original IDs
                            for (const member of importedMembers) {
                                const newMember = { ...member, createdAt: Date.now() };
                                delete newMember.openingScenes;
                                await DBHelper.put('contacts', newMember);
                                await this.importOpeningScenes(member.openingScenes, member.id, false);
                            }
                            
                            // Import the group, checking for its own ID conflict
                            const groupToImport = { ...importedGroup, createdAt: Date.now() };
                            const groupWithSameIdExists = await DBHelper.get('groups', groupToImport.id);
                            if (groupWithSameIdExists) {
                                groupToImport.id = Utils.generateId('group');
                            }
                            delete groupToImport.openingScenes;

                            await DBHelper.put('groups', groupToImport);
                            
                            // Import chat history. Since member IDs are preserved, no mapping is needed.
                            if (data.chatHistory && data.participants) {
                                const reconstructedHistory = await this.reconstructChatHistory(data.chatHistory, data.participants);
                                if (reconstructedHistory && reconstructedHistory.history) {
                                    for (const message of reconstructedHistory.history) {
                                        message.chatId = groupToImport.id; // 确保chatId已设置
                                        await DBHelper.put('messages', message);
                                    }
                                    // Re-create metadata if history is imported
                                    const displayableHistory = reconstructedHistory.history.filter(m => !['inner_voice', 'essay'].includes(m.segmentType));
                                    if (displayableHistory.length > 0) {
                                        const lastMessage = displayableHistory[displayableHistory.length - 1];
                                        const unreadCount = reconstructedHistory.history.filter(m => m.isUnread).length;
                                        await UIManager.updateChatMetadata(groupToImport.id, lastMessage, unreadCount);
                                    }
                                }
                            }

                            await this.importOpeningScenes(importedGroup.openingScenes, groupToImport.id, true);
                            UIManager.hideModal();
                            UIManager.showToast(`群聊 "${importedGroup.name}" 导入成功，冲突成员已被覆盖。`);
                            if (importedGroup.author) EventManager.showAttributionModal(importedGroup);
                            await UIManager.renderContactsPage('groups');
                            await UIManager.renderMessagesListPage(); // 新增：刷新消息列表
                        }}
                    ]
                });
            },


            showAttributionModal(entity) {
                UIManager.showModal({
                    title: "作者信息",
                    body: `
                        <div class="details-card">
                            <div class="details-field">
                                <span class="label">来源于</span>
                                <span class="value">${entity.author}</span>
                            </div>
                            <div class="details-section" style="margin-top: 15px;">
                                <div class="details-section-title">作者有话说</div>
                                <p>${entity.authorWords || '作者很懒，什么都没留下...'}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async reconstructChatHistory(chatHistory, participants) {
                if (!chatHistory || !chatHistory.history || !participants) {
                    return chatHistory;
                }

                const participantMap = participants.reduce((map, p) => {
                    map[p.id] = p;
                    return map;
                }, {});
                
                // --- 核心修复：处理时间戳冲突 ---
                let lastTimestamp = 0;
                let offset = 1; // 偏移量，单位为毫秒
                
                chatHistory.history.forEach(msg => {
                    // 绑定参与者信息
                    if (msg.senderId && participantMap[msg.senderId]) {
                        msg.senderInfo = participantMap[msg.senderId];
                    }
                    
                    // 检查并修正时间戳
                    if (msg.timestamp <= lastTimestamp) {
                        // 如果当前消息的时间戳小于或等于上一条，就在上一条的基础上增加偏移量
                        msg.timestamp = lastTimestamp + offset;
                    } else {
                        // 如果是新的时间戳，重置偏移量
                        offset = 1;
                    }
                    
                    // 更新上一条消息的时间戳记录
                    lastTimestamp = msg.timestamp;
                });
                // --- 修复结束 ---

                return chatHistory;
            },

            async handleExportContact(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                contact.openingScenes = allOpeningScenes.filter(s => s.contactId === contactId);
                this.showExportModal(contact, false);
            },

            async handleExportGroup(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                const membersData = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);
                const allOpeningScenes = await DBHelper.getAll('openingScenes');
                group.openingScenes = allOpeningScenes.filter(s => s.groupId === groupId);
                
                const exportPackage = {
                    groupData: group,
                    memberData: membersData
                };
                this.showExportModal(exportPackage, true);
            },

            showExportModal(entity, isGroup) {
                const myProfile = { name: '你' };
                const targetEntity = isGroup ? entity.groupData : entity;

                const authorName = targetEntity.author || myProfile.name;
                const authorWords = targetEntity.authorWords || '';
                const isAuthorFixed = !!targetEntity.author;

                UIManager.showModal({
                    title: `导出${isGroup ? '群聊' : '角色'}`,
                    body: `
                        <div class="form-group">
                            <label for="export-author-name">作者名</label>
                            <input type="text" id="export-author-name" value="${authorName}" ${isAuthorFixed ? 'disabled' : ''}>
                        </div>
                        <div class="form-group">
                            <label for="export-author-words">作者有话说 (选填)</label>
                            <textarea id="export-author-words" rows="3">${authorWords}</textarea>
                        </div>
                        <div class="form-group" style="display: flex; align-items: center; justify-content: center; padding-top: 10px;">
                            <input type="checkbox" id="export-chat-history-checkbox" style="width: 16px; height: 16px; margin-right: 8px;">
                            <label for="export-chat-history-checkbox" style="margin: 0; cursor: pointer;">同时导出聊天记录</label>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成文件', class: 'btn-primary', handler: async () => {
                            const newAuthorName = $('#export-author-name').value.trim();
                            const newAuthorWords = $('#export-author-words').value.trim();
                            const includeHistory = $('#export-chat-history-checkbox').checked;

                            let exportData;
                            let chatId;

                            if (isGroup) {
                                entity.groupData.author = newAuthorName;
                                entity.groupData.authorWords = newAuthorWords;
                                exportData = { type: 'group', ...entity };
                                chatId = entity.groupData.id;
                            } else {
                                entity.author = newAuthorName;
                                entity.authorWords = newAuthorWords;
                                exportData = { type: 'contact', contactData: entity };
                                chatId = entity.id;
                            }

                            if (includeHistory) {
                                // -- BUGFIX: 从正确的 'messages' 表获取所有聊天记录，而不是从旧的 'chats' 表。
                                const allMessagesForChat = await DBHelper.getMessages(chatId, Number.MAX_SAFE_INTEGER);
                                const chatHistory = { history: allMessagesForChat };

                                if (chatHistory && chatHistory.history && chatHistory.history.length > 0) {
                                    const participants = {};
                                    const myProfile = await DBHelper.get('profile', 'myProfile');
                                    const allContacts = await DBHelper.getAll('contacts');
                                    
                                    participants[myProfile.id] = myProfile;

                                    for (const msg of chatHistory.history) {
                                        if (msg.senderId && !participants[msg.senderId]) {
                                            const senderInfo = allContacts.find(c => c.id === msg.senderId);
                                            if (senderInfo) {
                                                participants[msg.senderId] = senderInfo;
                                            }
                                        }
                                        delete msg.senderInfo; 
                                    }
                                    
                                    exportData.chatHistory = chatHistory;
                                    exportData.participants = Object.values(participants);
                                }
                            }

                            const filename = `${isGroup ? entity.groupData.name : entity.name}_${new Date().toISOString().slice(0, 10)}.json`;
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);
                            
                            UIManager.showModal({
                                title: '文件已生成',
                                body: `
                                    <p>请点击下面的链接下载文件。</p>
                                    <a href="${url}" download="${filename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                                        点击下载 ${filename}
                                    </a>
                                    <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(下载后此链接将失效)</p>
                                `,
                                actions: [{
                                    text: '关闭',
                                    class: 'btn-secondary',
                                    handler: () => {
                                        URL.revokeObjectURL(url); 
                                        UIManager.hideModal();
                                    }
                                }]
                            });
                        }}
                    ]
                });
            },

            handleResetApp() {
                UIManager.showModal({
                    title: '确认重置',
                    body: `<p>此操作将删除所有数据，包括你的个人信息、联系人、群聊、聊天记录和API配置，且无法恢复。你确定要继续吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认重置', class: 'btn-danger', handler: () => {
                            indexedDB.deleteDatabase(DBHelper.DB_NAME);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "操作成功",
                                body: `<p>应用已重置，所有数据已被清除。页面即将刷新...</p><p>如果没有反应，请手动刷新。</p>`,
                                actions: [{ text: '立即刷新', class: 'btn-primary', handler: () => window.location.reload() }]
                            });
                            setTimeout(() => window.location.reload(), 3000); 
                        }}
                    ]
                });
            },

            
            async applyBackgroundSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const appContainer = $('#app-container');
                if (settings.appBackground) {
                    appContainer.style.backgroundImage = `url(${settings.appBackground})`;
                } else {
                    appContainer.style.backgroundImage = '';
                }
            },

            async applyFontSettings() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const root = document.documentElement;
                const fontSettings = settings.fonts || {};
                const customFonts = settings.customFonts || {};

                const fontTypes = {
                    Global: '--font-main',
                    Bubble: '--font-bubble',
                    InnerVoice: '--font-inner-voice',
                    Essay: '--font-essay'
                };

                
                const defaultFontValues = {
                    global: '"SimSun", "宋体", serif',
                    bubble: '"LXGW WenKai Screen", "Kaiti", "楷体", serif',
                    innervoice: '"Long Cang", cursive',
                    essay: '"Long Cang", cursive'
                };

                for (const [type, cssVar] of Object.entries(fontTypes)) {
                    const typeKey = type.toLowerCase();
                    const setting = fontSettings[typeKey]; 

                    if (setting && setting.type === 'custom' && customFonts[setting.value]) {
                        
                        const customFont = customFonts[setting.value];
                        root.style.setProperty(cssVar, `"${customFont.name}", sans-serif`);
                    } else if (setting && setting.type === 'builtin') {
                        
                        root.style.setProperty(cssVar, setting.value);
                    } else {
                        
                        
                        
                        
                        root.style.setProperty(cssVar, defaultFontValues[typeKey]);
                    }
                }
            },

            async loadAndApplyFontsInBackground() {
                
                try {
                    await this.loadCustomFontsOnStartup();
                    await this.applyFontSettings();
                    console.log("Custom fonts and settings applied in the background.");
                } catch (error) {
                    console.error("Failed to load and apply fonts in background:", error);
                }
            },


        async renderThemeSettingsPage() {
            const contentArea = $('#theme-settings-content');
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const chatSettings = await DBHelper.get('apiConfig', 'chatSettings') || {};
            appState.theme = chatSettings.theme || 'neumorphic';

            const bubbleStyles = {
                'default': { name: '默认', type: 'A', style: 'background: white; border: 2px solid var(--player-bubble-bg);' },
                '3d': { name: '立体3D', type: 'A', style: 'background: var(--player-bubble-bg); border-bottom: 3px solid rgba(0,0,0,0.2); border-radius: 12px;' },
                'neumorphic': { name: '拟态', type: 'A', style: 'background: var(--player-bubble-bg); box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #fff; color: #555;' },
                'stripes': { name: '柔和条纹', type: 'A', style: 'background-color: var(--player-bubble-bg); background-image: repeating-linear-gradient(45deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.2) 15px, rgba(255, 255, 255, 0.1) 15px, rgba(255, 255, 255, 0.1) 30px);' },
                'grid': { name: '网格', type: 'A', style: 'background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 0, 0, 0.1) 1px, transparent 1px); background-color: color-mix(in srgb, var(--player-bubble-bg) 80%, transparent);' },
                'cute': { name: '可爱风', type: 'A', style: 'background: transparent; border: 2px solid var(--player-bubble-bg); border-radius: 25px 25px 5px 25px;' },
                'frosted-glass': { name: '毛玻璃', type: 'A', style: 'background-color: color-mix(in srgb, var(--player-bubble-bg) 25%, transparent); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px); border: 1px solid rgba(255, 255, 255, 0.2);' },
                'neumorphic-2': { name: '拟态2', type: 'B', style: 'background: #F0F0F3; box-shadow: -5px -5px 9px rgba(255, 255, 255, 0.9), 5px 5px 9px rgba(174, 174, 192, 0.4);' },
                'ancient': { name: '古风', type: 'B', style: 'background: #f5f0e1; color: #5d4037; border: 2px solid #8d6e63;' },
                'chinese': { name: '国风', type: 'B', style: 'background: #c81e1e; border: 1px solid #f9d56e; color: #f9d56e;' },
                'doodle': { name: '手绘涂鸦', type: 'B', style: 'background: white; border: 2px solid #333; color: #333; box-shadow: 3px 3px 0px #ccc; border-radius: 15px 10px 15px 12px;' },
                'hand-drawn': { name: '手绘涂鸦2', type: 'B', style: 'background: white; border: 3px solid #333; box-shadow: 5px 5px 0 rgba(0, 0, 0, 0.1); font-family: "Comic Sans MS", cursive; color: #333;' },
                'stripey': { name: '可爱条纹', type: 'B', style: 'background: repeating-linear-gradient(45deg, #FFC0CB, #FFC0CB 10px, #F8C8D1 10px, #F8C8D1 20px);' },
                'gradient': { name: '渐变彩虹', type: 'B', style: 'background: linear-gradient(45deg, #a1c4fd, #c2e9fb, #ff9a9e, #a1c4fd); animation: gradientBG 8s ease infinite; background-size: 300% 300%;' },
                'glow-jelly': { name: '发光果冻', type: 'B', style: 'background: linear-gradient(135deg, #ff7e5f, #feb47b); box-shadow: 0 0 15px rgba(255, 126, 95, 0.7);' },
                'metal': { name: '金属质感', type: 'B', style: 'background: linear-gradient(145deg, #e0e0e0, #c0c0c0);' },
                'ocean': { name: '海洋风', type: 'B', style: 'background: linear-gradient(160deg, #0077b6, #00b4d8);' },
                'paw': { name: '猫爪风', type: 'B', style: 'background: #fce1cb; color: #8b5e34;' },
            };

            const currentStyle = settings.bubbleStyle || 'default';
            let bubbleStyleOptionsHTML = '';
            for (const [key, value] of Object.entries(bubbleStyles)) {
                bubbleStyleOptionsHTML += `
                    <div class="bubble-style-option ${currentStyle === key ? 'selected' : ''}" data-style-key="${key}">
                        <div class="bubble-style-preview" style="${value.style}"><span>${value.type}</span></div>
                        <span>${value.name}</span>
                    </div>
                `;
            }

            
            const fontSizeOptions = {
                'small': { name: '小', value: '0.8rem' },
                'normal-small': { name: '较小', value: '0.88rem' },
                'default': { name: '默认', value: '0.95rem' },
                'normal-large': { name: '较大', value: '1.05rem' },
                'large': { name: '大', value: '1.15rem' }
            };
            const currentFontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizeRadioHTML = Object.entries(fontSizeOptions).map(([key, value]) => `
                <label style="cursor:pointer;"><input type="radio" name="font-size-radio" value="${key}" ${currentFontSizeKey === key ? 'checked' : ''}> ${value.name}</label>
            `).join('');


            contentArea.innerHTML = `
                <style>
                    
                    .theme-setting-card .color-input-group { display: flex; flex-direction: column; align-items: center; gap: 8px; }
                    .theme-setting-card .color-input-group label { font-size: 0.9rem; color: var(--text-color-medium); }
                    .bubble-style-options-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 15px; justify-content: center; margin-top: 10px; }
                    .bubble-style-option { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 10px; border-radius: 10px; border: 2px solid transparent; transition: all 0.3s ease; background-color: rgba(0,0,0,0.03); }
                    .bubble-style-option.selected { border-color: var(--accent-color); transform: scale(1.05); }
                    .bubble-style-option:hover { background-color: rgba(0,0,0,0.06); }
                    .bubble-style-preview { width: 80px; height: 40px; border-radius: 10px; margin-bottom: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); border: 1px solid rgba(0,0,0,0.05); display: flex; justify-content: center; align-items: center; font-size: 0.8rem; color: white; text-shadow: 1px 1px 1px rgba(0,0,0,0.2); font-weight: bold; }
                    .bubble-style-option span { font-size: 0.9rem; color: var(--text-color-dark); text-align: center; }
                    .bubble-style-preview span { color: white; }
                </style>
                <div class="theme-setting-card">
                    <h3>弹窗风格</h3>
                    <div style="display: flex; justify-content: space-around; padding-top: 10px;">
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="default" ${appState.theme !== 'neumorphic' ? 'checked' : ''}> 默认</label>
                        <label style="cursor:pointer;"><input type="radio" name="modal-theme" value="neumorphic" ${appState.theme === 'neumorphic' ? 'checked' : ''}> 拟态</label>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>通用设置</h3>
                    <div class="theme-setting-group">
                       <button id="font-settings-btn" class="theme-page-btn">字体设置</button>
                       <button id="background-settings-btn" class="theme-page-btn">背景与封面</button>
                    </div>
                </div>
                <div class="theme-setting-card">
                    <h3>聊天气泡样式</h3>
                    <div id="bubble-style-options" class="bubble-style-options-container">${bubbleStyleOptionsHTML}</div>
                </div>
                <div class="theme-setting-card">
                    <h3>聊天字体大小</h3>
                    <div id="font-size-radio-group" style="display: flex; justify-content: space-around; padding-top: 10px;">
                        ${fontSizeRadioHTML}
                    </div>
                    <p style="font-size: 0.8rem; color: var(--text-color-light); text-align: center; margin-top: 10px; padding: 0 15px;">
                        聊天字体大小同时还取决于自定义字体因素影响
                    </p>
                </div>
                <div class="theme-setting-card" id="bubble-color-card">
                    <h3>气泡颜色 (限A类气泡)</h3>
                    <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                        <div class="color-input-group">
                            <label for="friend-bubble-bg-color">好友消息背景</label>
                            <div class="color-picker-container">
                                <input type="color" id="friend-bubble-bg-color" value="${settings.friendBubbleBg || '#FFFFFF'}">
                                <input type="text" class="color-hex-input" id="friend-bubble-bg-hex" value="${settings.friendBubbleBg || '#FFFFFF'}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div class="color-input-group">
                            <label for="player-bubble-bg-color">我的消息背景</label>
                            <div class="color-picker-container">
                                <input type="color" id="player-bubble-bg-color" value="${settings.playerBubbleBg || '#A7C7E7'}">
                                <input type="text" class="color-hex-input" id="player-bubble-bg-hex" value="${settings.playerBubbleBg || '#A7C7E7'}" maxlength="7" size="7">
                            </div>
                        </div>
                    </div>
                </div>
                 <div class="theme-setting-card">
                    <h3>聊天气泡字体颜色</h3>
                     <div style="display: flex; justify-content: space-around; align-items: center; gap: 20px; margin-top: 15px;">
                        <div class="color-input-group">
                            <label for="friend-bubble-text-color">好友消息</label>
                            <div class="color-picker-container">
                                <input type="color" id="friend-bubble-text-color" value="${settings.friendBubbleTextColor || '#5D534A'}">
                                <input type="text" class="color-hex-input" id="friend-bubble-text-hex" value="${settings.friendBubbleTextColor || '#5D534A'}" maxlength="7" size="7">
                            </div>
                        </div>
                        <div class="color-input-group">
                            <label for="player-bubble-text-color">我的消息</label>
                            <div class="color-picker-container">
                                <input type="color" id="player-bubble-text-color" value="${settings.playerBubbleTextColor || '#FFFFFF'}">
                                <input type="text" class="color-hex-input" id="player-bubble-text-hex" value="${settings.playerBubbleTextColor || '#FFFFFF'}" maxlength="7" size="7">
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            $('#theme-settings-back-btn').onclick = () => UIManager.navigateTo('settings');
            
            EventManager._syncColorInputs('friend-bubble-bg-color', 'friend-bubble-bg-hex');
            EventManager._syncColorInputs('player-bubble-bg-color', 'player-bubble-bg-hex');
            EventManager._syncColorInputs('friend-bubble-text-color', 'friend-bubble-text-hex');
            EventManager._syncColorInputs('player-bubble-text-color', 'player-bubble-text-hex');
            
            
            $('#font-size-radio-group').onchange = async (e) => {
                if (e.target.name === 'font-size-radio') {
                    const sizeKey = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    settingsToSave.bubbleFontSize = sizeKey;
                    await DBHelper.put('apiConfig', settingsToSave);
                    await this.applyBubbleFontSize(); 
                }
            };

            const saveBubbleSettings = async () => {
                const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                settingsToSave.bubbleStyle = document.querySelector('.bubble-style-option.selected').dataset.styleKey;
                settingsToSave.friendBubbleBg = $('#friend-bubble-bg-color').value;
                settingsToSave.playerBubbleBg = $('#player-bubble-bg-color').value;
                settingsToSave.friendBubbleTextColor = $('#friend-bubble-text-color').value;
                settingsToSave.playerBubbleTextColor = $('#player-bubble-text-color').value;
                await DBHelper.put('apiConfig', settingsToSave);
                await this.applyBubbleSettings();
            };

            $$('input[name="modal-theme"]').forEach(radio => {
                radio.onchange = async (e) => {
                    appState.theme = e.target.value;
                    const settingsToSave = await DBHelper.get('apiConfig', 'chatSettings') || { id: 'chatSettings' };
                    settingsToSave.theme = appState.theme;
                    await DBHelper.put('apiConfig', settingsToSave);
                };
            });

            
            $('#bubble-style-options').onclick = (e) => {
                const option = e.target.closest('.bubble-style-option');
                if (!option) return;

                $$('.bubble-style-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                const isTypeA = bubbleStyles[option.dataset.styleKey].type === 'A';
                $('#bubble-color-card').style.display = isTypeA ? 'block' : 'none';
                saveBubbleSettings();
            };

            ['friend-bubble-bg-color', 'player-bubble-bg-color', 'friend-bubble-text-color', 'player-bubble-text-color'].forEach(id => {
                $(`#${id}`).oninput = saveBubbleSettings; 
            });
            
            const initialStyleIsTypeA = bubbleStyles[currentStyle].type === 'A';
            $('#bubble-color-card').style.display = initialStyleIsTypeA ? 'block' : 'none';

            $('#font-settings-btn').onclick = () => this.handleFontSettings();

            $('#background-settings-btn').onclick = () => {
                UIManager.showModal({
                    title: "背景与封面",
                    body: `
                        <div class="settings-list" style="padding:0; margin:0 -10px;">
                            <div class="setting-item" id="modal-bg-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-desktop"></i><span>应用/聊天背景</span><i class="fas fa-chevron-right"></i>
                            </div>
                            <div class="setting-item" id="modal-cover-settings-btn-nav" style="cursor:pointer;">
                                <i class="fas fa-photo-video"></i><span>自定义封面</span><i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });
                
                $('#modal-bg-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleBackgroundSettings();
                });
                $('#modal-cover-settings-btn-nav').addEventListener('click', () => {
                    UIManager.hideModal();
                    this.handleCoverSettings();
                });
            };
        },

        async handleBackgroundSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey) => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">上传</button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">移除</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: '背景设置',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('app-bg', '主题背景', settings.appBackground, 'appBackground')}
                        ${createUploadHTML('global-bg', '聊天背景', settings.globalChatBg, 'globalChatBg')}
                    </div>`,
                actions: [{ text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                        if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                        UIManager.showToast('图片已更新');
                    } catch (error) { 
                        console.error("图片上传或应用失败:", error);
                        UIManager.showToast('图片处理失败'); 
                    }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    if (dbKey === 'appBackground') await EventManager.applyBackgroundSettings();
                    if (dbKey === 'globalChatBg' && appState.currentPage === 'chat' && appState.currentChatId) await UIManager.applyChatBackground(appState.currentChatId);
                    UIManager.showToast('图片已移除');
                };
            };
            setupUploadHandler('app-bg', 'appBackground');
            setupUploadHandler('global-bg', 'globalChatBg');
        },

        async handleCoverSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const createUploadHTML = (type, title, previewSrc, dbKey, previewStyle = '') => `
                <div class="theme-upload-item">
                    <span>${title}</span>
                    <div class="theme-upload-preview-wrapper" style="${previewStyle}">
                        <img src="${previewSrc || ''}" id="${type}-preview" class="theme-upload-preview" style="${previewSrc ? '' : 'display:none;'}">
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <input type="file" id="${type}-input" accept="image/*" style="display: none;">
                        <button class="theme-page-btn" onclick="document.getElementById('${type}-input').click()">上传</button>
                        <button class="theme-page-btn" id="${type}-remove-btn" style="${previewSrc ? '' : 'display:none;'}">移除</button>
                    </div>
                </div>`;

            UIManager.showModal({
                title: '自定义封面',
                body: `
                    <div class="theme-setting-group" style="padding: 10px 0;">
                        ${createUploadHTML('rp-cover', '红包封面', settings.redPacketCover, 'redPacketCover', 'width: 80px; height: 106px;')}
                        ${createUploadHTML('transfer-cover', '转账封面', settings.transferCover, 'transferCover')}
                        ${createUploadHTML('receipt-cover', '收款封面', settings.receiptCover, 'receiptCover')}
                    </div>`,
                actions: [{ text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal() }]
            });

            const setupUploadHandler = (type, dbKey) => {
                const input = $(`#${type}-input`);
                const preview = $(`#${type}-preview`);
                const removeBtn = $(`#${type}-remove-btn`);
                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    try {
                        const base64 = await Utils.compressImage(file, 800, 800, 0.7);
                        preview.src = base64;
                        preview.style.display = 'block';
                        removeBtn.style.display = 'inline-block';
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave[dbKey] = base64;
                        await DBHelper.put('apiConfig', settingsToSave);
                        UIManager.showToast('封面已更新');
                    } catch (error) { UIManager.showToast('图片处理失败'); }
                };
                removeBtn.onclick = async () => {
                    preview.src = '';
                    preview.style.display = 'none';
                    removeBtn.style.display = 'none';
                    input.value = '';
                    const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                    delete settingsToSave[dbKey];
                    await DBHelper.put('apiConfig', settingsToSave);
                    UIManager.showToast('封面已移除');
                };
            };
            setupUploadHandler('rp-cover', 'redPacketCover');
            setupUploadHandler('transfer-cover', 'transferCover');
            setupUploadHandler('receipt-cover', 'receiptCover');
        },

        async applyBubbleSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const root = document.documentElement;
            const appContainer = $('#app-container');

            
            root.style.setProperty('--friend-bubble-bg', settings.friendBubbleBg || '#FFFFFF');
            root.style.setProperty('--player-bubble-bg', settings.playerBubbleBg || 'var(--accent-color)');
            root.style.setProperty('--friend-bubble-text-color', settings.friendBubbleTextColor || '#5D534A');
            root.style.setProperty('--player-bubble-text-color', settings.playerBubbleTextColor || '#FFFFFF');

            
            const styleKey = settings.bubbleStyle || 'default';
            const classList = Array.from(appContainer.classList);
            
            
            let newClassList = classList.filter(c => !c.startsWith('app-bubble-style-'));
            if(classList.includes('bottom-offset-active')) {
                if(!newClassList.includes('bottom-offset-active')) {
                     newClassList.push('bottom-offset-active');
                }
            }
            
            
            newClassList.push(`app-bubble-style-${styleKey}`);
            appContainer.className = newClassList.join(' ');
        },

        async applyBubbleFontSize() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSizeKey = settings.bubbleFontSize || 'default';
            const fontSizes = {
                'small': '0.8rem',
                'normal-small': '0.88rem',
                'default': '0.95rem',
                'normal-large': '1.05rem',
                'large': '1.15rem'
            };
            document.documentElement.style.setProperty('--font-bubble-size', fontSizes[fontSizeKey]);
        },

        async handleFontSettings() {
            const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
            const fontSettings = settings.fonts || {};
            const customFonts = settings.customFonts || {};

            const builtinFonts = {
                '宋体 (SimSun)': '"SimSun", "宋体", serif',
                '楷体 (LXGW WenKai)': '"LXGW WenKai Screen", "Kaiti", "楷体", serif',
                '龙藏体 (Long Cang)': '"Long Cang", cursive',
                'System Default': `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif`,
            };
            
            const defaultFontValues = {
                global: builtinFonts['宋体 (SimSun)'],
                bubble: builtinFonts['楷体 (LXGW WenKai)'],
                innervoice: builtinFonts['龙藏体 (Long Cang)'],
                essay: builtinFonts['龙藏体 (Long Cang)']
            };

            const createFontSelectorHTML = (typeKey, typeLabel) => {
                const settingKey = typeKey.toLowerCase();
                const currentSetting = fontSettings[settingKey] || { type: 'builtin', value: defaultFontValues[settingKey] };

                
                let optionsHTML = Object.entries(builtinFonts).map(([name, value]) =>
                    `<option value='${value}' data-type="builtin" ${currentSetting.type === 'builtin' && currentSetting.value === value ? 'selected' : ''}>${name}</option>`
                ).join('');

                for (const [key, font] of Object.entries(customFonts)) {
                    optionsHTML += `<option value="${key}" data-type="custom" ${currentSetting.type === 'custom' && currentSetting.value === key ? 'selected' : ''}>${font.name} (自定义)</option>`;
                }

                return `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                        <label>${typeLabel}</label>
                        <select class="font-select" data-font-type="${settingKey}" style="flex-grow: 1; max-width: 60%;">${optionsHTML}</select>
                    </div>`;
            };

            UIManager.showModal({
                title: "字体设置",
                body: `
                    <div class="form-group" style="display: flex; justify-content: space-around; padding-bottom: 15px; border-bottom: 1px dashed var(--border-color);">
                        <button id="font-upload-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">本地</button>
                        <button id="font-url-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">网络</button>
                        <button id="font-delete-btn" class="modal-btn btn-secondary" style="padding: 8px 12px; font-size: 0.9rem;">删除</button>
                    </div>
                    <div style="margin-top: 20px;">
                        ${createFontSelectorHTML('Global', '全局字体')}
                        ${createFontSelectorHTML('Bubble', '气泡字体')}
                        ${createFontSelectorHTML('InnerVoice', '心声字体')}
                        ${createFontSelectorHTML('Essay', '随笔字体')}
                    </div>
                `,
                actions: [
                    { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                    { text: '保存', class: 'btn-primary', handler: async () => {
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.fonts = settingsToSave.fonts || {};

                        $$('.font-select').forEach(select => {
                            const fontTypeKey = select.dataset.fontType;
                            const selectedOption = select.options[select.selectedIndex];
                            settingsToSave.fonts[fontTypeKey] = {
                                type: selectedOption.dataset.type,
                                value: selectedOption.value
                            };
                        });

                        await DBHelper.put('apiConfig', settingsToSave);
                        await this.applyFontSettings();
                        UIManager.hideModal();
                        UIManager.showToast("字体设置已保存并应用");
                    }}
                ]
            });

            $('#font-upload-btn').onclick = () => this.handleFontUpload(false);
            $('#font-url-btn').onclick = () => this.handleFontUrl(false);
            $('#font-delete-btn').onclick = () => this.handleDeleteCustomFont();
        },

            async handleFontUpload() {
                UIManager.showModal({
                    title: "上传本地字体",
                    body: `
                        <div style="font-size: 0.9rem; line-height: 1.6;">
                            <p>请选择字体文件进行上传。支持的格式为 <code>.ttf</code>, <code>.otf</code>, <code>.woff</code>, <code>.woff2</code>。</p>
                            <p><strong>强烈推荐使用 <code>.woff2</code> 格式</strong>，因为它的文件体积更小，加载速度更快。</p>
                            <p>请尽量选择体积较小的字体文件，过大的字体会导致刷新页面时加载变慢。</p>
                            <p style="color: var(--text-color-medium); margin-top: 15px;">加载字体需要一些时间，选择使用自定义字体后刷新页面使字体生效。</p>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings(); 
                        }},
                        { text: '继续上传', class: 'btn-primary', handler: () => {
                            UIManager.hideModal(); 
                            this.triggerActualFontUpload(); 
                        }}
                    ]
                });
            },

            triggerActualFontUpload() {
                const fontFileInput = $('#font-file-input');
                fontFileInput.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const fontName = file.name.split('.')[0];
                    try {
                        const base64 = await Utils.fileToBase64(file);
                        const customFontKey = `${Utils.generateId('font')}`;
                        const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                        settingsToSave.customFonts = settingsToSave.customFonts || {};
                        settingsToSave.customFonts[customFontKey] = { name: fontName, data: base64 };
                        await DBHelper.put('apiConfig', settingsToSave);

                        
                        await this.loadCustomFontsOnStartup();
                        
                        this.handleFontSettings(); 
                        UIManager.showToast(`字体 "${fontName}" 上传成功！`);
                    } catch (error) {
                        UIManager.showToast("字体文件读取失败");
                    } finally {
                        fontFileInput.value = '';
                    }
                };
                fontFileInput.click();
            },

            async handleFontUrl() {
                UIManager.showModal({
                    title: "添加网络字体",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">字体名称 (自定义)</label>
                            <input type="text" id="font-url-name-input" placeholder="例如：思源黑体">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">字体文件 URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();
                            if (!fontName || !fontUrl) return UIManager.showToast("名称和URL均不能为空");
                            if (!fontUrl.startsWith('http')) return UIManager.showToast("请输入有效的URL");

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();

                            UIManager.hideModal();
                            this.handleFontSettings();
                            UIManager.showToast(`网络字体 "${fontName}" 添加成功！`);
                        }}
                    ]
                });
            },

            async handleDeleteCustomFont() {
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const customFonts = settings.customFonts || {};

                if (Object.keys(customFonts).length === 0) {
                    return UIManager.showToast("没有可删除的自定义字体");
                }

                
                const fontListHtml = Object.entries(customFonts).map(([key, font]) => `
                    <label class="member-select-item">
                        <input type="radio" name="delete-font-radio" value="${key}">
                        <span>${font.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要删除的字体",
                    body: `<div class="member-select-list">${fontListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const selectedRadio = $('input[name="delete-font-radio"]:checked');
                            if (!selectedRadio) return UIManager.showToast("请选择一个要删除的字体");

                            const fontKeyToDelete = selectedRadio.value;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || {};
                            
                            
                            if (settingsToSave.customFonts && settingsToSave.customFonts[fontKeyToDelete]) {
                                delete settingsToSave.customFonts[fontKeyToDelete];
                            }

                            
                            if (settingsToSave.fonts) {
                                for (const typeKey in settingsToSave.fonts) {
                                    if (settingsToSave.fonts[typeKey].value === fontKeyToDelete) {
                                        
                                        settingsToSave.fonts[typeKey] = { type: 'builtin', value: '"SimSun", "宋体", serif' }; 
                                    }
                                }
                            }
                            
                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            UIManager.showToast("自定义字体已删除");
                            this.handleFontSettings(); 
                        }}
                    ]
                });
            },

            async loadCustomFontsOnStartup() {
                
                const settings = await DBHelper.get('apiConfig', 'themeSettings') || {};
                const fontSettings = settings.fonts || {}; 
                const customFonts = settings.customFonts || {}; 

                
                if (Object.keys(customFonts).length === 0) {
                    
                    let fontStyleTag = document.getElementById('dynamic-font-styles');
                    if (fontStyleTag) fontStyleTag.innerHTML = '';
                    return;
                }

                
                const activeCustomFontKeys = new Set();
                
                for (const setting of Object.values(fontSettings)) {
                    
                    if (setting.type === 'custom' && setting.value) {
                        
                        activeCustomFontKeys.add(setting.value);
                    }
                }

                
                let fontStyleTag = document.getElementById('dynamic-font-styles');
                if (!fontStyleTag) {
                    fontStyleTag = document.createElement('style');
                    fontStyleTag.id = 'dynamic-font-styles';
                    document.head.appendChild(fontStyleTag);
                }

                
                let fontFaceRules = '';
                
                for (const key of activeCustomFontKeys) {
                    const font = customFonts[key]; 
                    if (font && font.name && font.data) {
                        let src;
                        
                        if (font.data.startsWith('data:')) {
                            src = `url(${font.data})`;
                        } else {
                            src = `url('${font.data}')`;
                        }
                        
                        fontFaceRules += `@font-face { font-family: "${font.name}"; src: ${src}; }\n`;
                    }
                }

                
                fontStyleTag.innerHTML = fontFaceRules;
            },

            async handleFontUrl(fontTypeKey) {
                UIManager.showModal({
                    title: "添加网络字体",
                    body: `
                        <div class="form-group">
                            <label for="font-url-name-input">字体名称 (自定义)</label>
                            <input type="text" id="font-url-name-input" placeholder="例如：思源黑体">
                        </div>
                        <div class="form-group">
                            <label for="font-url-input">字体文件 URL</label>
                            <input type="text" id="font-url-input" placeholder="https://.../font.woff2">
                        </div>
                        <p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 10px;">
                            提示：字体文件越大，加载时间越长，请尽量选择体积较小的字体。
                        </p>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            
                            UIManager.hideModal();
                            this.handleFontSettings();
                        }},
                        { text: '添加', class: 'btn-primary', handler: async () => {
                            const fontName = $('#font-url-name-input').value.trim();
                            const fontUrl = $('#font-url-input').value.trim();

                            if (!fontName || !fontUrl) {
                                return UIManager.showToast("名称和URL均不能为空");
                            }

                            
                            if (!fontUrl.startsWith('http')) {
                                return UIManager.showToast("请输入有效的URL");
                            }

                            const customFontKey = `${Utils.generateId('font')}`;
                            const settingsToSave = await DBHelper.get('apiConfig', 'themeSettings') || { id: 'themeSettings' };
                            settingsToSave.customFonts = settingsToSave.customFonts || {};
                            settingsToSave.fonts = settingsToSave.fonts || {};

                            
                            settingsToSave.customFonts[customFontKey] = { name: fontName, data: fontUrl };
                            settingsToSave.fonts[fontTypeKey] = { type: 'custom', value: customFontKey };

                            await DBHelper.put('apiConfig', settingsToSave);

                            
                            await this.loadCustomFontsOnStartup();
                            await this.applyFontSettings();
                            UIManager.hideModal();
                            
                            this.handleFontSettings();
                        }}
                    ]
                });
            },



            async handleChatBackgroundSettings(chatId, isGroup) {
                const entity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const currentBg = entity.chatBackground || null;
                const currentNameColor = entity.nameColor || '#888888';

                const createUploadSection = (id, label, previewSrc) => `
                    <div class="background-upload-section">
                        <label>${label}</label>
                        <img src="${previewSrc || 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='}" 
                             alt="${label}预览" 
                             class="background-preview" 
                             id="${id}-preview"
                             style="${previewSrc ? '' : 'display: none;'}">
                        <input type="file" id="${id}-input" accept="image/*" style="display: none;">
                        <button class="modal-btn btn-secondary" style="padding: 8px 15px;" onclick="document.getElementById('${id}-input').click()">上传</button>
                        <button class="modal-btn btn-danger" style="padding: 8px 15px; ${previewSrc ? '' : 'display: none;'}" id="${id}-remove-btn">移除</button>
                    </div>`;
                
                const createColorPickerSection = (id, label, value) => `
                     <div class="background-upload-section" style="flex-direction: row; justify-content: space-between; align-items: center; padding: 10px 20px;">
                        <label>${label}</label>
                        <div class="color-picker-container">
                             <input type="color" id="${id}-input" value="${value}">
                             <input type="text" class="color-hex-input" id="${id}-hex" value="${value}" maxlength="7" size="7">
                        </div>
                    </div>
                `;

                const currentNarratorStyle = entity.narratorStyle || 'grey';

                UIManager.showModal({
                    title: `专属设置 - ${entity.name}`,
                    customClass: 'theme-settings-modal',
                    body: `
                        <div class="form-group">
                           ${createUploadSection('exclusive-bg', '专属背景', currentBg)}
                        </div>
                        <div class="form-group">
                           ${createColorPickerSection('exclusive-name-color', '角色名字颜色', currentNameColor)}
                        </div>
                        <div class="form-group">
                            <label>旁白样式</label>
                            <div class="narrator-style-selector" id="narrator-style-selector">
                                <div class="narrator-style-option grey-option ${currentNarratorStyle === 'grey' ? 'selected' : ''}" data-style="grey">灰色</div>
                                <div class="narrator-style-option white-option ${currentNarratorStyle === 'white' ? 'selected' : ''}" data-style="white">白色</div>
                                <div class="narrator-style-option black-option ${currentNarratorStyle === 'black' ? 'selected' : ''}" data-style="black">黑色</div>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { 
                            text: '保存', 
                            class: 'btn-primary', 
                            // The handler logic is now managed externally to handle dynamic updates
                            handler: () => {} 
                        }
                    ]
                });

                this._syncColorInputs('exclusive-name-color-input', 'exclusive-name-color-hex');
                
                const setupUpload = (id) => {
                    const input = $(`#${id}-input`);
                    const preview = $(`#${id}-preview`);
                    const removeBtn = $(`#${id}-remove-btn`);

                    input.addEventListener('change', async (e) => {
                        const file = e.target.files[0];
                        if (file) {
                            preview.src = await Utils.fileToBase64(file);
                            preview.style.display = 'block';
                            removeBtn.style.display = 'inline-block';
                        }
                    });

                    removeBtn.addEventListener('click', () => {
                        preview.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='; 
                        preview.style.display = 'none';
                        removeBtn.style.display = 'none';
                        input.value = ''; 
                    });
                };
                setupUpload('exclusive-bg');

                
                const narratorSelector = $('#narrator-style-selector');
                narratorSelector.addEventListener('click', (e) => {
                    const option = e.target.closest('.narrator-style-option');
                    if (!option) return;
                    
                    narratorSelector.querySelectorAll('.narrator-style-option').forEach(opt => opt.classList.remove('selected'));
                    option.classList.add('selected');

                    const handler = narratorSelector.closest('.modal-content').querySelector('.modal-btn.btn-primary').__handler;
                    if(handler) {
                        handler.call(); // Re-trigger save logic if needed, or just update UI state.
                    }
                });

                const saveHandler = async () => {
                    const previewSrc = $('#exclusive-bg-preview').src;
                    const blankGif = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';
                    const newBg = (previewSrc.startsWith('data:image') && previewSrc !== blankGif) ? previewSrc : null;
                    const newNameColor = $('#exclusive-name-color-input').value;
                    const newNarratorStyle = narratorSelector.querySelector('.selected').dataset.style;

                    entity.chatBackground = newBg;
                    entity.nameColor = newNameColor;
                    entity.narratorStyle = newNarratorStyle;
                    await DBHelper.put(isGroup ? 'groups' : 'contacts', entity);

                    if (appState.currentChatId === chatId) {
                        await UIManager.applyChatBackground(chatId);
                        await UIManager.refreshChatView();
                    }

                    UIManager.hideModal();
                    UIManager.showToast('专属设置已保存！');
                };

                // 为"保存"按钮绑定新的处理函数
                const saveButton = modalContentWrapper.querySelector('.modal-actions .btn-primary');
                if (saveButton) {
                    // 我们不再需要原来的空handler，直接覆盖onclick事件
                    saveButton.onclick = saveHandler;
                }
            },

            async handleChatSettings() {
                
                let chatSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyCharLimit: 5000,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    promptTurnFrequency: 1, 
                    activeReplyInterval: 0, 
                };
                if (!chatSettings) {
                    chatSettings = defaults;
                } else {
                    
                    chatSettings = { ...defaults, ...chatSettings };
                }

                
                const createSwitch = (id, label, description, isChecked) => `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-bottom: 1px solid var(--border-color);">
                        <div style="flex-grow: 1;">
                            <label style="margin-bottom: 5px; font-size: 1.1rem;">${label}</label>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 0; line-height: 1.4;">
                                ${description}
                            </p>
                        </div>
                        <div style="flex-shrink: 0; margin-left: 20px;">
                            <label class="switch">
                                <input type="checkbox" id="${id}" ${isChecked ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                `;
                
                
                const createNumberInput = (label, description, inputId, initialValue, unit = '') => `
                    <div class="form-group" style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; margin-top: 15px;">
                        <div style="flex-grow: 1;">
                            <label style="margin-bottom: 5px; font-size: 1.1rem;" for="${inputId}">${label}</label>
                            <p style="font-size: 0.8rem; color: var(--text-color-medium); margin-top: 0; line-height: 1.4;">
                                ${description}
                            </p>
                        </div>
                        <div style="flex-shrink: 0; margin-left: 20px; display: flex; align-items: center;">
                            <input type="number" id="${inputId}" value="${initialValue}" min="0" step="1" class="form-group" style="width: 70px; text-align: center; padding: 8px; margin: 0;">
                            ${unit ? `<span style="margin-left: 8px; font-size: 0.9rem; color: var(--text-color-medium);">${unit}</span>` : ''}
                        </div>
                    </div>
                `;


                
                UIManager.showModal({
                    title: '聊天设置',
                    body: `
                        <style>.switch{position:relative;display:inline-block;width:52px;height:30px}.switch input{opacity:0;width:0;height:0}.slider{position:absolute;cursor:pointer;top:0;left:0;right:0;bottom:0;background-color:#ccc;transition:.4s;border-radius:30px}.slider:before{position:absolute;content:"";height:24px;width:24px;left:3px;bottom:3px;background-color:white;transition:.4s;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,0.2)}input:checked+.slider{background-color:var(--accent-color)}input:checked+.slider:before{transform:translateX(22px)}</style>
                        ${createSwitch('memory-interconnection-switch', '记忆互通', '开启后，好友会获取相关群聊+私聊作为记忆参考，对话更连贯。', chatSettings.memoryInterconnection)}
                        ${createSwitch('show-my-name-in-group-switch', '群聊显示自己名字', '开启后，你在群聊中发送的消息上方会显示你的名字。', chatSettings.showMyNameInGroup)}
                        ${createSwitch('show-names-in-private-switch', '私聊显示名字', '开启后，私聊时双方的消息上方都会显示名字。', chatSettings.showNamesInPrivate)}
                        ${createSwitch('bottom-bar-offset-switch', '底部状态栏上移', '开启后，为手机自带的底部导航条预留空间，防止遮挡。', chatSettings.bottomBarOffset)}
                        ${createSwitch('enter-to-send-switch', '回车自动发送', '开启后，在输入框内按回车键将直接发送消息。', chatSettings.enterToSend)}
                        
                        ${createNumberInput('聊天记录字数上限', '设定每次请求AI时附带的聊天记录字数，影响记忆和Token消耗。', 'history-char-limit-input', chatSettings.historyCharLimit, '字')}
                        ${createNumberInput('提示词发送频率', '每N个玩家回合发送一次包含自定义提示词的完整Prompt，以节省Token。', 'prompt-freq-input', chatSettings.promptTurnFrequency)}
                        ${createNumberInput('主动回复间隔', '当距离AI上次回复超过N小时后，进入聊天会自动触发AI主动回复。输入0可关闭。', 'active-reply-interval-input', chatSettings.activeReplyInterval)}
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const newSettings = {
                                id: 'chatSettings',
                                memoryInterconnection: $('#memory-interconnection-switch').checked,
                                historyCharLimit: parseInt($('#history-char-limit-input').value, 10),
                                showMyNameInGroup: $('#show-my-name-in-group-switch').checked,
                                showNamesInPrivate: $('#show-names-in-private-switch').checked,
                                bottomBarOffset: $('#bottom-bar-offset-switch').checked,
                                enterToSend: $('#enter-to-send-switch').checked,
                                promptTurnFrequency: parseInt($('#prompt-freq-input').value, 10),
                                activeReplyInterval: parseInt($('#active-reply-interval-input').value, 10), 
                            };
                            await DBHelper.put('apiConfig', newSettings);
                            this.applyChatSettings(newSettings); 
                            UIManager.hideModal();
                        }}
                    ]
                });
            },
            
            applyChatSettings(settings) {
                
                appContainer.classList.toggle('bottom-offset-active', settings.bottomBarOffset);
            },
            async handleApiSettings() {
                await AIHandler.loadApiConfig(); 
                const config = AIHandler.apiConfig;
                
                const getApiProviderOptions = () => `
                    <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                    <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow</option>
                    <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>派欧云</option>
                    <option value="volcano" ${config.provider === 'volcano' ? 'selected' : ''}>火山</option>
                    <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>自定义</option>
                `;
                
                UIManager.showModal({
                    title: 'API 配置',
                    body: `
                        <div class="form-group">
                            <label for="api-provider">API提供商</label>
                            <select id="api-provider">${getApiProviderOptions()}</select>
                        </div>
                        <div class="form-group">
                            <label for="api-url">API URL</label>
                            <input type="text" id="api-url" value="${config.url}" placeholder="输入API URL">
                        </div>
                        <div class="form-group">
                            <label for="api-key">API Key</label>
                            <div style="position: relative; display: flex; align-items: center;">
                                <input type="password" id="api-key" value="${config.key}" placeholder="输入API密钥" style="width: 100%; padding-right: 40px;">
                                <i class="fas fa-eye" id="toggle-api-key-visibility" style="position: absolute; right: 15px; cursor: pointer; color: #aaa;"></i>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="api-model-select">模型</label>
                            <select id="api-model-select"></select>
                            <input type="text" id="api-model-input" value="${config.model}" placeholder="输入自定义模型名称" style="display:none;">
                        </div>
                        <div class="form-group">
                            <label for="temperature">温度 (0-1)</label>
                            <input type="number" id="temperature" min="0" max="1" step="0.1" value="${config.temperature}">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const newConfig = {
                                provider: $('#api-provider').value,
                                url: $('#api-url').value.trim(),
                                key: $('#api-key').value.trim(),
                                temperature: parseFloat($('#temperature').value)
                            };
                            
                            if (isNaN(newConfig.temperature) || newConfig.temperature < 0 || newConfig.temperature > 1) {
                                newConfig.temperature = 0.7; 
                            }
                            
                            const modelSelect = $('#api-model-select');
                            const modelInput = $('#api-model-input');
                            if (modelInput.style.display !== 'none') {
                                newConfig.model = modelInput.value.trim();
                            } else {
                                newConfig.model = modelSelect.value;
                            }
                            
                            await AIHandler.saveApiConfig(newConfig);
                            UIManager.hideModal();
                            UIManager.showModal({
                                title: "操作成功",
                                body: `<p>API配置已成功保存！<br>聊天需要点击左下角<i class="fas fa-feather-alt"></i>小羽毛按钮<br>其他可见设置页面的食用指南<br><br>33祝你游玩愉快⌯>ᴗo⌯ .ᐟ.ᐟ</p>`,
                                actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                            });
                        }}
                    ]
                });
                
                const toggleBtn = $('#toggle-api-key-visibility');
                const apiKeyInput = $('#api-key');
                toggleBtn.addEventListener('click', () => {
                    if (apiKeyInput.type === 'password') {
                        apiKeyInput.type = 'text';
                        toggleBtn.classList.remove('fa-eye');
                        toggleBtn.classList.add('fa-eye-slash');
                    } else {
                        apiKeyInput.type = 'password';
                        toggleBtn.classList.remove('fa-eye-slash');
                        toggleBtn.classList.add('fa-eye');
                    }
                });

                const updateApiFields = () => {
                    const provider = $('#api-provider').value;
                    const apiUrlInput = $('#api-url');
                    const modelSelect = $('#api-model-select');
                    const modelInput = $('#api-model-input');
                    const currentModel = AIHandler.apiConfig.model;
                    
                    modelSelect.innerHTML = '';
                    
                    const modelOptions = {
                        gemini: [
                            "gemini-2.5-flash", "gemini-2.5-pro", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest"
                        ],
                        siliconflow: [
                            "deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "Qwen/Qwen2-72B-Instruct", "01-ai/Yi-1.5-34B-Chat", "mistralai/Mistral-7B-Instruct-v0.2", "mistralai/Mixtral-8x7B-Instruct-v0.1"
                        ],
                        paioupu: [
                            "deepseek/deepseek-v3"
                        ]
                    };

                    const setOptions = (options) => {
                        modelSelect.innerHTML = options.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                        modelSelect.value = options.includes(currentModel) ? currentModel : options[0];
                    };
                    
                    switch (provider) {
                        case 'gemini':
                            apiUrlInput.value = 'https://generativelanguage.googleapis.com/v1beta/models/';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.gemini);
                            break;
                        case 'siliconflow':
                            apiUrlInput.value = 'https://api.siliconflow.cn/v1/chat/completions';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.siliconflow);
                            break;
                        case 'paioupu':
                            apiUrlInput.value = 'https://api.ppinfra.com/v3/openai';
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            setOptions(modelOptions.paioupu);
                            break;
                        case 'volcano':
                            apiUrlInput.value = 'https://ark.cn-beijing.volces.com/api/v3';
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel;
                            break;
                        case 'custom':
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel;
                            break;
                    }
                };
                
                $('#api-provider').addEventListener('change', () => {
                    if ($('#api-provider').value === 'custom') {
                        $('#api-url').value = '';
                    }
                    updateApiFields();
                });
                updateApiFields(); 
            },
            
            async handleForwardMoment(momentId) {
                const allMetadata = await DBHelper.getAll('chatMetadata');
                const contacts = await DBHelper.getAll('contacts');
                const groups = await DBHelper.getAll('groups');

                const recentConversations = allMetadata
                    .filter(meta => meta.lastMessage) //确保有聊天记录
                    .sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);

                if (recentConversations.length === 0) {
                    UIManager.showModal({
                        title: "转发动态",
                        body: `<p style="text-align: center; color: #aaa; padding: 20px 0;">最近没有新的聊天会话，<br>去和好友们开启一个聊天窗口吧！</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const conversationDetails = recentConversations.map(meta => {
                    let details;
                    if (meta.chatId.startsWith('contact-')) {
                        details = contacts.find(c => c.id === meta.chatId);
                    } else {
                        details = groups.find(g => g.id === meta.chatId);
                    }
                    return details ? { ...details, chatId: meta.chatId } : null;
                }).filter(Boolean);

                const chatListHtml = conversationDetails.map(item => `
                    <label class="member-select-item">
                        <input type="radio" name="forward-target" value="${item.chatId}">
                        <img src="${item.avatar}" class="contact-item-avatar" style="width:40px;height:40px;margin-right:10px; border-radius: 8px;">
                        <span>${item.remark || item.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "转发给",
                    body: `<div class="member-select-list" style="max-height: 40vh;">${chatListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const selectedRadio = $('input[name="forward-target"]:checked');
                            if (!selectedRadio) {
                                UIManager.showToast("请选择一个聊天");
                                return;
                            }
                            const targetChatId = selectedRadio.value;

                            const moment = await DBHelper.get('moments', momentId);
                            const momentAuthor = await this.getMomentAuthor(moment.authorId, moment.circleId);
                            
                            const aiContent = await this.buildForwardedMomentAIContent(moment, momentAuthor, targetChatId);

                            const cardData = {
                                momentId: moment.id,
                                authorName: momentAuthor.name,
                                preview: moment.content,
                            };

                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: aiContent,
                                type: 'sent',
                                segmentType: 'moment_forward',
                                cardData: cardData
                            };
                            
                            const originalChatId = appState.currentChatId;
                            const originalPage = appState.currentPage;

                            appState.currentChatId = targetChatId; 
                            await this.handlePlayerSendMessage(message);
                            
                            // 恢复原始状态
                            appState.currentChatId = originalChatId;
                            appState.currentPage = originalPage;

                            UIManager.hideModal();
                            UIManager.showToast(`已转发给 ${conversationDetails.find(c => c.chatId === targetChatId).name}`);
                            await UIManager.renderMessagesListPage(); // 刷新消息列表
                        }}
                    ]
                });
            },

            async confirmDeleteMoment(momentId, postElement) {
                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除这条动态吗？此操作无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('moments', momentId);
                            postElement.remove();
                            UIManager.hideModal();
                            UIManager.showToast('动态已删除');
                        }}
                    ]
                });
            },

            async getMomentAuthor(authorId, contextId = null) {
                const myProfile = await this.getPlayerProfileForContext(contextId);
                if (authorId === myProfile.id) {
                    return { name: myProfile.name, avatar: myProfile.avatar };
                }
                const contact = await DBHelper.get('contacts', authorId);
                if (contact) {
                    return { name: contact.name, avatar: contact.avatar };
                }
                return { name: authorId, avatar: Utils.createAvatarDataUrl('#ccc') };
            },

            async buildForwardedMomentAIContent(moment, author, targetChatId) {
                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await this.getPlayerProfileForContext(targetChatId);

                let commentsText = '无';
                if (moment.comments && moment.comments.length > 0) {
                    commentsText = '\n' + moment.comments.map(c => {
                        let cAuthorName = '未知';
                        if (c.authorId === myProfile.id) {
                            cAuthorName = myProfile.name;
                        } else {
                            const contact = allContacts.find(con => con.id === c.authorId);
                            cAuthorName = contact ? contact.name : c.authorId;
                        }
                        const replyText = c.replyTo ? ` 回复 ${c.replyTo}` : '';
                        return `${cAuthorName}${replyText}: ${c.content}`;
                    }).join('\n');
                }

                const imageDescription = moment.images && moment.images.length > 0 
                    ? ` [图片：包含${moment.images.length}张图片的动态]`
                    : '';
                
                return `<转发动态>
动态作者：${author.name}
动态内容：${moment.content}${imageDescription}
动态时间：${Utils.formatTimestampSmartly(moment.timestamp)}
点赞情况：${moment.likes && moment.likes.length > 0 ? moment.likes.join(', ') : '无'}
评论区：${commentsText}
</转发动态>`;
            },

            async showForwardedMomentDetail(momentId) {
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) {
                    UIManager.showToast("该动态可能已被删除");
                    return;
                }

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const author = await this.getMomentAuthor(moment.authorId, moment.circleId);

                let likesHtml = '';
                if (moment.likes && moment.likes.length > 0) {
                    likesHtml = `<div class="likes-list"><i class="fas fa-heart"></i> ${moment.likes.join(', ')}</div>`;
                }

                let commentsHtml = '';
                if (moment.comments && moment.comments.length > 0) {
                    commentsHtml = moment.comments.map(comment => {
                        let cAuthorName = '未知用户';
                        if (comment.authorId === myProfile.id) {
                            cAuthorName = myProfile.name;
                        } else {
                            const contact = allContacts.find(c => c.id === comment.authorId);
                            cAuthorName = contact ? contact.name : comment.authorId;
                        }

                        const replyHtml = comment.replyTo 
                            ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${comment.replyTo}</span>` 
                            : '';
                        return `<div class="comment-item"><span class="comment-author">${cAuthorName}</span>${replyHtml}: ${comment.content}</div>`;
                    }).join('');
                }

                const imagesHtml = moment.images && moment.images.length > 0
                    ? `<div class="post-image-grid">${moment.images.map(src => `<img src="${src}" alt="动态图片">`).join('')}</div>`
                    : '';

                const modalBody = `
                    <div class="moment-detail-wrapper">
                        <div class="post-header">
                            <img src="${author.avatar}" alt="${author.name} 头像" class="post-avatar">
                            <div class="post-author-info">
                                <span class="name">${author.name}</span>
                            </div>
                        </div>
                        <div class="post-content-full">${moment.content}</div>
                        ${imagesHtml}
                        <div class="post-footer-full">
                            <span class="timestamp">${Utils.formatTimestampSmartly(moment.timestamp)}</span>
                        </div>
                        ${(likesHtml || commentsHtml) ? `
                        <div class="interactions-section">
                            ${likesHtml}
                            <div class="comments-list">${commentsHtml}</div>
                        </div>
                        ` : ''}
                    </div>
                `;

                UIManager.showModal({
                    title: "朋友圈动态",
                    body: modalBody,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async showCustomForwardDetail(messageId) {
                const msg = await DBHelper.get('messages', messageId);
                if (!msg || !msg.cardData) {
                    UIManager.showToast("无法加载转发内容");
                    return;
                }

                const { title, content } = msg.cardData;

                // 使用 marked.js 解析Markdown内容
                const parsedContent = marked.parse(content);

                const modalBody = `
                    <div class="moment-detail-wrapper" style="padding-top: 10px;">
                        <div class="post-content-full" style="white-space: normal; line-height: 1.7;">
                            ${parsedContent}
                        </div>
                    </div>
                `;

                UIManager.showModal({
                    title: title, // 弹窗标题就是转发的标题
                    body: modalBody,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

handleClickEffect(e) {
    const pos = appContainer.getBoundingClientRect();
    const x = e.clientX - pos.left;
    const y = e.clientY - pos.top;

    // 只保留水波纹效果，移除性能消耗较大的心形动画
    const ripple = document.createElement('div');
    ripple.className = 'ripple';
    clickEffectLayer.appendChild(ripple);

    const rippleSize = 80;
    ripple.style.width = ripple.style.height = `${rippleSize}px`;
    ripple.style.left = `${x - rippleSize / 2}px`;
    ripple.style.top = `${y - rippleSize / 2}px`;
    ripple.addEventListener('animationend', () => {
        ripple.remove();
    });
},

            async handleOpenGroupManagementSidebar(groupId) {
                const group = await DBHelper.get('groups', groupId);
                if (group) {
                    UIManager.showGroupManagementSidebar(group);
                }
            },

            async handleOpenFriendManagementSidebar(contactId) {
                const contact = await DBHelper.get('contacts', contactId);
                if (contact) {
                    UIManager.showFriendManagementSidebar(contact);
                }
            },

            async showEditFriendModal(contactId, onSaveCallback = null) { 
                const contact = await DBHelper.get('contacts', contactId);
                if (!contact) return;

                UIManager.showModal({
                    isPersistent: true, 
                    title: "修改好友信息",
                    body: `
                        <div class="form-group">
                            <label>头像</label>
                            <div class="avatar-uploader">
                                <img src="${contact.avatar}" id="edit-friend-avatar-preview" class="avatar-preview">
                                <input type="file" id="edit-friend-avatar-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('edit-friend-avatar-input').click()">上传新头像</button>
                            </div>
                        </div>
                        <div class="form-group"><label>姓名 (ID, 不可修改)</label><input type="text" value="${contact.name}" disabled></div>
                        <div class="form-group"><label for="edit-friend-remark">备注</label><input type="text" id="edit-friend-remark" value="${contact.remark || ''}"></div>
                        <div class="form-group"><label for="edit-friend-gender">性别</label><select id="edit-friend-gender"><option value="男" ${contact.gender === '男' ? 'selected' : ''}>男</option><option value="女" ${contact.gender === '女' ? 'selected' : ''}>女</option><option value="其他" ${contact.gender === '其他' ? 'selected' : ''}>其他</option></select></div>
                        <div class="form-group">
                            <label for="edit-friend-allow-retraction">允许撤回消息</label>
                            <select id="edit-friend-allow-retraction">
                                <option value="true" ${contact.allowRetraction !== false ? 'selected' : ''}>开启</option>
                                <option value="false" ${contact.allowRetraction === false ? 'selected' : ''}>关闭</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="edit-friend-allow-emoji">允许发送表情包</label>
                            <select id="edit-friend-allow-emoji">
                                <option value="on" ${!contact.allowEmoji || contact.allowEmoji === 'on' ? 'selected' : ''}>开启</option>
                                <option value="off" ${contact.allowEmoji === 'off' ? 'selected' : ''}>关闭</option>
                                <option value="prob" ${contact.allowEmoji === 'prob' ? 'selected' : ''}>概率</option>
                            </select>
                        </div>
                        <div class="form-group"><label for="edit-friend-likes">喜好</label><textarea id="edit-friend-likes">${contact.likes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-dislikes">厌恶</label><textarea id="edit-friend-dislikes">${contact.dislikes || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-habits">习惯</label><textarea id="edit-friend-habits">${contact.habits || ''}</textarea></div>
                        <div class="form-group"><label for="edit-friend-background">背景资料</label><textarea id="edit-friend-background">${contact.background || ''}</textarea></div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const updatedContact = {
                                ...contact,
                                avatar: $('#edit-friend-avatar-preview').src,
                                remark: $('#edit-friend-remark').value.trim(),
                                gender: $('#edit-friend-gender').value,
                                allowRetraction: $('#edit-friend-allow-retraction').value === 'true',
                                allowEmoji: $('#edit-friend-allow-emoji').value,
                                likes: $('#edit-friend-likes').value.trim(),
                                dislikes: $('#edit-friend-dislikes').value.trim(),
                                habits: $('#edit-friend-habits').value.trim(),
                                background: $('#edit-friend-background').value.trim()
                            };
                            await DBHelper.put('contacts', updatedContact);
                            chatTitle.textContent = updatedContact.remark || updatedContact.name;
                            UIManager.hideModal();
                            
                            if (typeof onSaveCallback === 'function') {
                                onSaveCallback(updatedContact);
                            } else {
                                UIManager.showFriendManagementSidebar(updatedContact); 
                            }
                        }}
                    ]
                });
                
                $('#edit-friend-avatar-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) $('#edit-friend-avatar-preview').src = await Utils.fileToBase64(file);
                });
            },
            async importOpeningScenes(scenes, newEntityId, isGroup) {
                if (!scenes || !Array.isArray(scenes) || scenes.length === 0) return;
                for (const scene of scenes) {
                    const newScene = { ...scene, id: Utils.generateId('scene') };
                    if (isGroup) {
                        newScene.groupId = newEntityId;
                        delete newScene.contactId;
                    } else {
                        newScene.contactId = newEntityId;
                        delete newScene.groupId;
                    }
                    await DBHelper.put('openingScenes', newScene);
                }
            },
            handleOpeningSceneSettings(entityId, isGroup) {
                UIManager.showOpeningSceneModal(entityId, isGroup);
            },

handleAutoSummarySettings(entityId, isGroup) {
    UIManager.showAutoSummaryModal(entityId, isGroup);
},

handleImmediateSummary(entityId, isGroup) {
    if (appState.isSummarizing[entityId]) {
        UIManager.showToast("正在总结中，请稍候...");
        return;
    }
    // 先关闭当前弹窗，AI处理函数会自动重新打开并显示加载状态
    UIManager.hideModal(); 
    // 调用AI处理函数
    AIHandler.handleAutoSummaryRequest(entityId);
},
            handleNewOpeningScene(entityId, isGroup) {
                UIManager.showModal({
                    isPersistent: true,
                    title: "新建开场白",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">开场白名称</label>
                            <input type="text" id="scene-name" placeholder="例如：初次见面的问候">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">开场白内容</label>
                            <textarea id="scene-content" rows="6" placeholder="详细描述开场时的情景、角色的状态和第一句对话等..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#scene-name').value.trim();
                            const content = $('#scene-content').value.trim();
                            if (!name || !content) return;
                            const newScene = { id: Utils.generateId('scene'), name, content };
                            if (isGroup) {
                                newScene.groupId = entityId;
                            } else {
                                newScene.contactId = entityId;
                            }
                            await DBHelper.put('openingScenes', newScene);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleEditOpeningScene(scene, isGroup) {
                UIManager.showModal({
                    isPersistent: true, 
                    title: "编辑开场白",
                    body: `
                        <div class="form-group">
                            <label for="scene-name">开场白名称</label>
                            <input type="text" id="scene-name" value="${scene.name}">
                        </div>
                        <div class="form-group">
                            <label for="scene-content">开场白内容</label>
                            <textarea id="scene-content" rows="6">${scene.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const updatedScene = {
                                ...scene,
                                name: $('#scene-name').value.trim(),
                                content: $('#scene-content').value.trim()
                            };
                            await DBHelper.put('openingScenes', updatedScene);
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }}
                    ]
                });
            },

            handleDeleteOpeningScene(sceneId, entityId, isGroup) {
                UIManager.showModal({
                    title: "确认删除",
                    body: `<p>确定要删除这个开场白吗？此操作无法恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.showOpeningSceneModal(entityId, isGroup) },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('openingScenes', sceneId);
                            UIManager.showOpeningSceneModal(entityId, isGroup);
                        }}
                    ]
                });
            },

            handleApplyOpeningScene(scene) {
                UIManager.showModal({
                    title: "应用开场白",
                    body: `<p>应用开场白将会清空当前聊天记录，并由AI根据开场白内容开始新的对话。确定要继续吗？</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => {
                            const isGroup = !!scene.groupId;
                            UIManager.showOpeningSceneModal(isGroup ? scene.groupId : scene.contactId, isGroup);
                        }},
                        { text: '确定应用', class: 'btn-primary', handler: async () => {
                            const chatId = scene.groupId || scene.contactId;
                            
                            UIManager.hideSidebar(); 
                            UIManager.hideModal();

                            
                            await DBHelper.deleteMessagesForChat(chatId);
                            await DBHelper.delete('chatMetadata', chatId);

                            // --- BUG修复：同时清除自动总结 ---
                            const isGroup = !!scene.groupId;
                            const storeName = isGroup ? 'groups' : 'contacts';
                            const entity = await DBHelper.get(storeName, chatId);
                            if (entity) {
                                entity.autoSummary = ''; 
                                if ('totalPlayerTurns' in entity) {
                                    entity.totalPlayerTurns = 0; 
                                }
                                await DBHelper.put(storeName, entity);
                            }
                            // --- 修复结束 ---
                            
                            
                            if (appState.currentChatId === chatId) {
                                await UIManager.refreshChatView();
                            }
                            
                            
                            await AIHandler.handleOpeningSceneRequest(scene);
                        }}
                    ]
                });
            },

            async handleTransferClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact;

                if (msg.type === 'sent') {
                    senderContact = myProfile;
                } else {
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                if (!senderContact) {
                    console.error("无法找到转账发送方信息:", msg);
                    UIManager.showToast("无法加载转账详情，发送方信息丢失。");
                    return;
                }

                const isRecipientPlayer = msg.cardData.recipientName === myProfile.name;
                const canReturn = isRecipientPlayer && !msg.cardData.isClaimed; // 新增：判断是否能退回

                UIManager.showModal({
                    title: "转账详情",
                    body: `
                        <div style="text-align: center;">
                            <img src="${senderContact.avatar}" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; margin-bottom: 10px;">
                            <h4 style="margin-bottom: 5px;">来自 ${senderContact.remark || senderContact.name} 的转账</h4>
                            <p style="font-size: 2rem; font-weight: bold; margin: 15px 0;">${msg.cardData.amount}</p>
                            ${msg.cardData.note ? `<p style="color: #888;">备注：${msg.cardData.note}</p>` : ''}
                        </div>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        {
                            text: '退回',
                            class: `btn-secondary ${!canReturn ? 'disabled' : ''}`, // 修复：根据能否退回动态添加class
                            handler: async () => {
                                // 修复：增加权限判断
                                if (!canReturn) {
                                    UIManager.showToast("只有收款方才能退还未处理的转账");
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true; // 标记为已处理
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const returnMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-return',
                                    content: `[${myProfile.name}|退还转账|${senderContact.name}|${msg.cardData.amount}]`,
                                    cardData: {
                                        recipientName: senderContact.name,
                                        senderName: myProfile.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', returnMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, returnMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(returnMsg, myProfile);
                                UIManager.hideModal();
                            }
                        },
                        {
                            text: '收款',
                            class: `btn-primary ${!isRecipientPlayer || msg.cardData.isClaimed ? 'disabled' : ''}`, // 修复：增加是否已处理的判断
                            handler: async () => {
                                // 修复：增加权限判断
                                if (!isRecipientPlayer) {
                                    UIManager.showToast('你不是该转账的收款对象');
                                    return;
                                }
                                if (msg.cardData.isClaimed) {
                                    UIManager.showToast('该转账已被处理');
                                    return;
                                }

                                const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                                if (msgToUpdate) {
                                    msgToUpdate.cardData.isClaimed = true;
                                    await DBHelper.put('messages', msgToUpdate);
                                }

                                const receiptMsg = {
                                    messageId: Utils.generateId('msg'),
                                    chatId: appState.currentChatId,
                                    timestamp: Date.now(),
                                    type: 'sent',
                                    segmentType: 'transfer-receipt',
                                    content: `${myProfile.name}已收款`,
                                    cardData: {
                                        recipientName: myProfile.name,
                                        senderName: senderContact.name,
                                        amount: msg.cardData.amount
                                    }
                                };
                                await DBHelper.put('messages', receiptMsg);
                                await UIManager.updateChatMetadata(appState.currentChatId, receiptMsg);

                                const originalBubble = $(`#${msg.messageId} .bubble`);
                                if (originalBubble) originalBubble.classList.add('claimed');
                                UIManager.addMessageToDOM(receiptMsg, myProfile);
                                UIManager.hideModal();
                            }
                        }
                    ]
                });
            },

            async handleRedPacketClick(msg) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                let senderContact; 

                
                if (msg.type === 'sent') {
                    
                    senderContact = myProfile;
                } else {
                    
                    senderContact = await DBHelper.get('contacts', msg.senderId);
                }

                
                if (!senderContact) {
                    console.error("无法找到红包发送方信息:", msg);
                    UIManager.showToast("无法加载红包详情，发送方信息丢失。");
                    return;
                }
                
                
                const modalStyle = `
                    <style>
                        .rp-modal-body { text-align: center; padding: 20px 0; }
                        .rp-modal-body img { width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px; }
                        .rp-modal-body h4 { font-size: 1.2rem; margin-bottom: 5px; }
                        .rp-modal-body p { color: var(--text-color-light); margin-bottom: 30px; }
                        .rp-open-btn {
                            width: 80px; height: 80px; border-radius: 50%;
                            background-color: #F8C34A; color: white;
                            border: 3px solid #F5A623; font-size: 2rem;
                            cursor: pointer; animation: rp-pulse 1.5s infinite;
                            box-shadow: 0 4px 10px rgba(248, 195, 74, 0.5);
                        }
                        @keyframes rp-pulse { 0% { transform: scale(0.95); } 70% { transform: scale(1.05); } 100% { transform: scale(0.95); } }
                        .rp-amount { font-size: 2.5rem; font-weight: bold; margin-bottom: 10px; }
                        .rp-claimed-info { font-size: 0.9rem; color: var(--text-color-medium); }
                    </style>
                `;

                
                UIManager.showModal({
                    title: " ", 
                    body: `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-pre-claim">
                            <img src="${senderContact.avatar}" alt="avatar">
                            <h4>${senderContact.remark || senderContact.name} 的红包</h4>
                            <p>${msg.cardData.title}</p>
                            <button class="rp-open-btn">开</button>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }]
                });

                
                modalContentWrapper.querySelector('.rp-open-btn').onclick = async () => {
                    

                    if (msg.type === 'sent') {
                        UIManager.showToast("不能领取自己发的红包哦");
                        return;
                    }
                    
                    const isGroupChat = appState.currentChatId.startsWith('group-');
                    let receivedAmount = 0;
                    
                    if (isGroupChat) {
                        
                        if (msg.cardData.count === 1) {
                            receivedAmount = msg.cardData.amount;
                        } else {
                            
                            const remainingAmount = msg.cardData.amount;
                            const remainingCount = msg.cardData.count - msg.cardData.claimedBy.length;
                            const maxReceive = remainingAmount - (remainingCount - 1) * 0.01;
                            receivedAmount = Math.random() * (maxReceive - 0.01) + 0.01;
                        }
                    } else {
                        receivedAmount = msg.cardData.amount;
                    }

                    // Get the original message from the 'messages' table and update it
                    const msgToUpdate = await DBHelper.get('messages', msg.messageId);
                    if (msgToUpdate) {
                        msgToUpdate.cardData.isClaimedByPlayer = true;
                        if (!Array.isArray(msgToUpdate.cardData.claimedBy)) {
                             msgToUpdate.cardData.claimedBy = [];
                        }
                        msgToUpdate.cardData.claimedBy.push(myProfile.id);
                        await DBHelper.put('messages', msgToUpdate);
                    }

                    
                    const originalBubble = $(`#${msg.messageId} .bubble`);
                    if(originalBubble) originalBubble.classList.add('claimed');

                    
                    const notice = document.createElement('div');
                    notice.className = 'time-divider';
                    notice.textContent = `${myProfile.name} 领取了 ${senderContact.remark || senderContact.name} 的红包`;
                    chatArea.appendChild(notice);
                    chatArea.scrollTop = chatArea.scrollHeight;
                    
                    
                    const modalBody = modalContentWrapper.querySelector('.modal-body');
                    modalBody.innerHTML = `
                        ${modalStyle}
                        <div class="rp-modal-body" id="rp-post-claim">
                            <p class="rp-amount">￥${receivedAmount.toFixed(2)}</p>
                            <p class="rp-claimed-info">已存入零钱，可直接使用</p>
                        </div>
                    `;
                };
            },

            async handleInviteMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');
                
                const availableFriends = allContacts.filter(c => !group.members.includes(c.id));

                if (availableFriends.length === 0) {
                    UIManager.showModal({
                        title: "邀请成员",
                        body: `<p>没有可邀请的好友了，所有好友都已在群聊中。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }

                const memberListHtml = availableFriends.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="invite-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "邀请新成员",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '邀请', class: 'btn-primary', handler: async () => {
                            const newMemberIds = [...$$('input[name="invite-members"]:checked')].map(cb => cb.value);
                            if (newMemberIds.length === 0) return;

                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const invitedNames = (await Promise.all(newMemberIds.map(id => DBHelper.get('contacts', id)))).map(c => c.remark || c.name).join('、');
                            
                            
                            group.members.push(...newMemberIds);
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} 邀请 ${invitedNames} 加入群聊`,
                                timestamp: Date.now(),
                                type: 'received', 
                                segmentType: 'system',
                                forAi: true, 
                            };

                            
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleRemoveMembers(groupId) {
                const group = await DBHelper.get('groups', groupId);
                const allContacts = await DBHelper.getAll('contacts');

                const currentAiMembers = group.members.map(id => allContacts.find(c => c.id === id)).filter(Boolean);

                if (currentAiMembers.length <= 1) {
                    UIManager.showModal({
                        title: "移除成员",
                        body: `<p>群聊中至少需要保留一名好友，无法再移除了。</p>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                    return;
                }
                
                const memberListHtml = currentAiMembers.map(f => `
                    <label class="member-select-item">
                        <input type="checkbox" name="remove-members" value="${f.id}">
                        <img src="${f.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                        <span>${f.remark || f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "移除群成员",
                    body: `<div class="member-select-list">${memberListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '移除', class: 'btn-danger', handler: async () => {
                            const idsToRemove = [...$$('input[name="remove-members"]:checked')].map(cb => cb.value);
                            if (idsToRemove.length === 0) return;

                            if (idsToRemove.length >= currentAiMembers.length) {
                                UIManager.showModal({ title: "操作无效", body: `<p>不能将所有好友都移出群聊，至少要保留一位哦。</p>`, actions: [{ text: '好的', class: 'btn-primary', handler: () => this.handleRemoveMembers(groupId) }] });
                                return;
                            }
                            
                            const myProfile = await DBHelper.get('profile', 'myProfile');
                            const removedNames = currentAiMembers.filter(c => idsToRemove.includes(c.id)).map(c => c.remark || c.name).join('、');

                            
                            group.members = group.members.filter(id => !idsToRemove.includes(id));
                            await DBHelper.put('groups', group);
                            
                            
                            const systemMessage = {
                                messageId: Utils.generateId('msg'),
                                content: `${myProfile.name} 将 ${removedNames} 移出群聊`,
                                timestamp: Date.now(),
                                type: 'received',
                                segmentType: 'system',
                                forAi: true, 
                            };
                            
                             
                            await DBHelper.put('messages', systemMessage);
                            await UIManager.updateChatMetadata(groupId, systemMessage);

                            if (appState.currentChatId === groupId) {
                                UIManager.addMessageToDOM(systemMessage, {});
                            }
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: '未分类', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此文件夹为空</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除文件夹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? '显性' : '隐性'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">查看</button>
                            <button class="action-btn" data-action="edit-prompt">修改</button>
                            <button class="action-btn" data-action="delete-prompt">删除</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },

            

            async renderPromptsPage() {
                const contentArea = $('#prompts-page-content');
                contentArea.innerHTML = ''; 
                const folders = await DBHelper.getAll('promptFolders');
                const prompts = await DBHelper.getAll('prompts');

                
                let unclassifiedFolder = folders.find(f => f.id === 'unclassified');
                if (!unclassifiedFolder) {
                    unclassifiedFolder = { id: 'unclassified', name: '未分类', isActive: true, createdAt: 0 };
                    
                }
                
                const sortedFolders = [unclassifiedFolder, ...folders.filter(f => f.id !== 'unclassified').sort((a,b) => a.createdAt - b.createdAt)];
                
                for (const folder of sortedFolders) {
                    const folderPrompts = prompts.filter(p => p.folderId === folder.id).sort((a,b) => a.createdAt - b.createdAt);
                    const folderElement = this.createFolderElement(folder, folderPrompts);
                    contentArea.appendChild(folderElement);
                }

                this.bindPromptPageEvents();
            },

            createFolderElement(folder, prompts) {
                const folderDiv = document.createElement('div');
                folderDiv.className = 'prompt-folder';
                folderDiv.dataset.folderId = folder.id;

                let promptsHtml = prompts.map((p, index) => this.createPromptCardHtml(p, index + 1)).join('');
                if (prompts.length === 0) {
                    promptsHtml = `<p style="color: #aaa; text-align: center; grid-column: 1 / -1; padding: 15px 0;">此文件夹为空</p>`;
                }

                
                folderDiv.innerHTML = `
                    <div class="prompt-folder-header collapsed">
                        <h3>
                            <i class="fas fa-chevron-right folder-toggle-icon"></i>
                            <i class="fas fa-folder"></i> 
                            ${folder.name}
                        </h3>
                        <div class="prompt-folder-controls">
                            ${folder.id !== 'unclassified' ? `
                            <label class="switch">
                                <input type="checkbox" class="folder-toggle-switch" ${folder.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                            <button class="folder-action-btn" data-action="delete-folder" title="删除文件夹"><i class="fas fa-trash-alt"></i></button>
                            ` : ''}
                        </div>
                    </div>
                    <div class="prompt-folder-content collapsed">${promptsHtml}</div>
                `;
                return folderDiv;
            },

            createPromptCardHtml(prompt, index) {
                let keywordsText = '';
                if (prompt.type === 'implicit') {
                    try {
                        const keywords = JSON.parse(prompt.keywords);
                        keywordsText = `<div class="prompt-tag tag-keywords" title="${keywords.join(', ')}">${keywords.join(', ')}</div>`;
                    } catch(e) {  }
                }
                
                return `
                    <div class="prompt-card ${prompt.isActive ? '' : 'inactive'}" data-prompt-id="${prompt.id}">
                        <div class="prompt-card-header">
                            <div class="prompt-card-name">
                                <span class="prompt-index">${index}</span>
                                <span>${prompt.name}</span>
                            </div>
                             <label class="switch">
                                <input type="checkbox" class="prompt-toggle-switch" ${prompt.isActive ? 'checked' : ''}>
                                <span class="slider"></span>
                            </label>
                        </div>
                        <div class="prompt-card-tags">
                            <div class="prompt-tag ${prompt.type === 'explicit' ? 'tag-explicit' : 'tag-implicit'}">${prompt.type === 'explicit' ? '显性' : '隐性'}</div>
                            ${keywordsText}
                        </div>
                        <div class="prompt-card-actions">
                            <button class="action-btn" data-action="view-prompt">查看</button>
                            <button class="action-btn" data-action="edit-prompt">修改</button>
                            <button class="action-btn" data-action="delete-prompt">删除</button>
                        </div>
                    </div>
                `;
            },
            
            bindPromptPageEvents() {
                
                $('#prompts-back-btn').onclick = () => UIManager.navigateTo('settings');
                $('#add-prompt-folder-btn').onclick = () => this.handleNewPromptFolder();
                $('#add-new-prompt-btn').onclick = () => this.handleNewPrompt();
                
                $('#import-prompts-btn').onclick = () => this.handleImportPrompts();
                $('#export-prompts-btn').onclick = () => this.handleExportPrompts();

                
                $('#prompts-page-content').onclick = async (e) => {
                    const target = e.target;
                    const folderHeader = target.closest('.prompt-folder-header');
                    const folderSwitch = target.closest('.folder-toggle-switch');
                    const deleteFolderBtn = target.closest('[data-action="delete-folder"]');
                    const promptCard = target.closest('.prompt-card');

                    if (folderSwitch) {
                        
                        e.stopPropagation(); 
                        const folderId = folderSwitch.closest('.prompt-folder').dataset.folderId;
                        await this.toggleFolderState(folderId, folderSwitch.checked);
                    } else if (deleteFolderBtn) {
                        
                        e.stopPropagation();
                        const folderId = deleteFolderBtn.closest('.prompt-folder').dataset.folderId;
                        this.confirmDeleteFolder(folderId);
                    } else if (folderHeader) {
                        
                        const content = folderHeader.nextElementSibling;
                        if (content && content.classList.contains('prompt-folder-content')) {
                            folderHeader.classList.toggle('collapsed');
                            content.classList.toggle('collapsed');
                        }
                    } else if (promptCard) {
                        
                        const promptId = promptCard.dataset.promptId;
                        if (target.matches('.prompt-toggle-switch')) {
                            await this.togglePromptState(promptId, target.checked);
                        } else if (target.matches('[data-action="view-prompt"]')) {
                            this.viewPrompt(promptId);
                        } else if (target.matches('[data-action="edit-prompt"]')) {
                            this.handleEditPrompt(promptId);
                        } else if (target.matches('[data-action="delete-prompt"]')) {
                            this.confirmDeletePrompt(promptId);
                        }
                    }
                };
            },


            async handleNewPrompt(folderId = 'unclassified') {
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${folderId === 'unclassified' ? 'selected' : ''}>未分类</option>` +
                    folders.map(f => `<option value="${f.id}" ${folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');

                UIManager.showModal({
                    isPersistent: true,
                    title: "新建提示词",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">名称 (文件夹内唯一)</label>
                            <input type="text" id="prompt-name-input" placeholder="例如：文风-古风">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">所属文件夹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>类型</label>
                            <select id="prompt-type-select">
                                <option value="explicit">显性 (总是触发)</option>
                                <option value="implicit">隐性 (关键词触发)</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:none;">
                            <label for="prompt-keywords-input">关键词 (用中/英文逗号隔开)</label>
                            <input type="text" id="prompt-keywords-input" placeholder="例如：你好,hello,在吗">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">提示词内容</label>
                            <textarea id="prompt-content-input" rows="5" placeholder="输入你的提示词..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) {
                                return UIManager.showToast("提示词名称不能为空");
                            }

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`名称 "${name}" 在该文件夹中已存在`);
                            }
                            
                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|，/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }

                            const newPrompt = {
                                id: Utils.generateId('prompt'),
                                createdAt: Date.now(),
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                                isActive: true,
                            };
                            await DBHelper.put('prompts', newPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async handleEditPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                const folders = await DBHelper.getAll('promptFolders');
                const folderOptions = `<option value="unclassified" ${prompt.folderId === 'unclassified' ? 'selected' : ''}>未分类</option>` +
                    folders.map(f => `<option value="${f.id}" ${prompt.folderId === f.id ? 'selected' : ''}>${f.name}</option>`).join('');
                
                let keywordsString = '';
                if(prompt.type === 'implicit') {
                    try {
                        const keywordsArray = JSON.parse(prompt.keywords);
                        if (Array.isArray(keywordsArray)) keywordsString = keywordsArray.join(', ');
                    } catch(e) {}
                }

                UIManager.showModal({
                    isPersistent: true,
                    title: "修改提示词",
                    body: `
                        <div class="form-group">
                            <label for="prompt-name-input">名称 (文件夹内唯一)</label>
                            <input type="text" id="prompt-name-input" value="${prompt.name}">
                        </div>
                        <div class="form-group">
                            <label for="prompt-folder-select">所属文件夹</label>
                            <select id="prompt-folder-select">${folderOptions}</select>
                        </div>
                        <div class="form-group">
                            <label>类型</label>
                            <select id="prompt-type-select">
                                <option value="explicit" ${prompt.type === 'explicit' ? 'selected' : ''}>显性</option>
                                <option value="implicit" ${prompt.type === 'implicit' ? 'selected' : ''}>隐性</option>
                            </select>
                        </div>
                        <div class="form-group" id="prompt-keywords-group" style="display:${prompt.type === 'implicit' ? 'block' : 'none'};">
                            <label for="prompt-keywords-input">关键词 (用中/英文逗号隔开)</label>
                            <input type="text" id="prompt-keywords-input" value="${keywordsString}" placeholder="例如：你好,hello,在吗">
                        </div>
                        <div class="form-group">
                            <label for="prompt-content-input">提示词内容</label>
                            <textarea id="prompt-content-input" rows="5">${prompt.content}</textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#prompt-name-input').value.trim();
                            const selectedFolderId = $('#prompt-folder-select').value;
                            if (!name) return UIManager.showToast("提示词名称不能为空");

                            
                            const allPrompts = await DBHelper.getAll('prompts');
                            const promptsInFolder = allPrompts.filter(p => p.folderId === selectedFolderId && p.id !== promptId);
                            if (promptsInFolder.some(p => p.name === name)) {
                                return UIManager.showToast(`名称 "${name}" 在该文件夹中已存在`);
                            }

                            let keywords = '[]';
                            if ($('#prompt-type-select').value === 'implicit') {
                                const keywordsInput = $('#prompt-keywords-input').value.trim();
                                if (keywordsInput) {
                                    const keywordsArray = keywordsInput.split(/,|，/).map(kw => kw.trim()).filter(Boolean);
                                    keywords = JSON.stringify(keywordsArray);
                                }
                            }
                            
                            const updatedPrompt = {
                                ...prompt,
                                name: name,
                                folderId: selectedFolderId,
                                type: $('#prompt-type-select').value,
                                keywords: keywords,
                                content: $('#prompt-content-input').value.trim(),
                            };
                            await DBHelper.put('prompts', updatedPrompt);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
                
                $('#prompt-type-select').onchange = (e) => {
                    $('#prompt-keywords-group').style.display = e.target.value === 'implicit' ? 'block' : 'none';
                };
            },
            
            async viewPrompt(promptId) {
                const prompt = await DBHelper.get('prompts', promptId);
                UIManager.showModal({
                    title: `查看: ${prompt.name}`,
                    body: `<div class="details-section" style="margin-top:0;"><p style="max-height: 400px;">${prompt.content}</p></div>`,
                    actions: [{text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
            },
            
            confirmDeletePrompt(promptId) {
                UIManager.showModal({
                    title: '确认删除',
                    body: '<p>确定要删除这个提示词吗？此操作无法恢复。</p>',
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            await DBHelper.delete('prompts', promptId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async togglePromptState(promptId, isActive) {
                const prompt = await DBHelper.get('prompts', promptId);
                prompt.isActive = isActive;
                await DBHelper.put('prompts', prompt);
                
                
                const promptCard = $(`#prompts-page-content .prompt-card[data-prompt-id="${promptId}"]`);
                if (promptCard) {
                    promptCard.classList.toggle('inactive', !isActive);
                }
            },

            handleNewPromptFolder() {
                UIManager.showModal({
                    title: "新建文件夹",
                    body: `
                        <div class="form-group">
                            <label for="folder-name-input">文件夹名称 (不可重复)</label>
                            <input type="text" id="folder-name-input" placeholder="例如：世界观设定">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#folder-name-input').value.trim();
                            if (!name) return;
                            const existing = await DBHelper.getAll('promptFolders', 'name');
                            if (existing.some(f => f.name === name)) return alert('文件夹名称已存在');

                            const newFolder = {
                                id: Utils.generateId('folder'),
                                createdAt: Date.now(),
                                name: name,
                                isActive: true
                            };
                            await DBHelper.put('promptFolders', newFolder);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },
            
            async toggleFolderState(folderId, isActive) {
                const folder = await DBHelper.get('promptFolders', folderId);
                folder.isActive = isActive;
                await DBHelper.put('promptFolders', folder);

                const promptsInFolder = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                for (const prompt of promptsInFolder) {
                    prompt.isActive = isActive;
                    await DBHelper.put('prompts', prompt);
                }
                this.renderPromptsPage();
            },
            
            confirmDeleteFolder(folderId) {
                UIManager.showModal({
                    title: '确认删除文件夹',
                    body: '<p>删除文件夹将同时删除其中所有的提示词，且无法恢复。确定要继续吗？</p>',
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            
                            const prompts = (await DBHelper.getAll('prompts')).filter(p => p.folderId === folderId);
                            for (const prompt of prompts) {
                                await DBHelper.delete('prompts', prompt.id);
                            }
                            
                            await DBHelper.delete('promptFolders', folderId);
                            UIManager.hideModal();
                            this.renderPromptsPage();
                        }}
                    ]
                });
            },

            
            
            async showBindingModal(chatId) {
                const isGroup = chatId.startsWith('group-');
                const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                const boundFolderIds = chatEntity.boundPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');
                
                const boundFolders = allFolders.filter(f => boundFolderIds.includes(f.id));
                let boundFoldersHtml = boundFolders.map(f => `
                    <div class="bound-folder-card">
                        <i class="fas fa-folder-open"></i>
                        <span>${f.name}</span>
                    </div>
                `).join('');
                if (boundFolders.length === 0) {
                    boundFoldersHtml = `<p style="text-align:center; color:#aaa; padding: 20px 0;">未绑定任何提示词文件夹</p>`;
                }
                
                const modalBody = `
                    <div class="binding-modal-header">
                        <h2>已绑定文件夹</h2>
                        <button id="open-folder-selection-btn" title="管理绑定"><i class="fas fa-link"></i></button>
                    </div>
                    <div id="bound-folders-list">${boundFoldersHtml}</div>
                `;

                UIManager.showModal({
                    title: "绑定提示词",
                    body: modalBody,
                    actions: [{text: '完成', class: 'btn-primary', handler: () => UIManager.hideModal()}]
                });
                
                
                modalContentWrapper.classList.add('binding-modal-content');
                
                $('#open-folder-selection-btn').onclick = () => this.showFolderSelectionModal(chatId, boundFolderIds);

                
                const originalHide = UIManager.hideModal;
                UIManager.hideModal = () => {
                    modalContentWrapper.classList.remove('binding-modal-content');
                    originalHide.call(UIManager);
                    UIManager.hideModal = originalHide; 
                };
            },

            async showFolderSelectionModal(chatId, currentlyBoundIds) {
                const allFolders = await DBHelper.getAll('promptFolders');
                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-folder" value="${f.id}" ${currentlyBoundIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要绑定的文件夹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => this.showBindingModal(chatId) },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-folder"]:checked')].map(cb => cb.value);
                            const isGroup = chatId.startsWith('group-');
                            const chatEntity = await DBHelper.get(isGroup ? 'groups' : 'contacts', chatId);
                            chatEntity.boundPromptFolderIds = selectedIds;
                            await DBHelper.put(isGroup ? 'groups' : 'contacts', chatEntity);
                            this.showBindingModal(chatId); 
                        }}
                    ]
                });
            },
            handleSimulatedImageSend() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                const networkFallbackImage = 'https://z.wiki/autoupload/20240328/LV9Y.iShot_2024-03-28_22.38.16.png'; 
                
                UIManager.showModal({
                    isPersistent: true,
                    title: "发送图文消息",
                    body: `
                        <div class="form-group">
                            <label>上传图片 (选填)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="sim-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="sim-image-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('sim-image-input').click()">选择图片</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="sim-image-desc">图片描述 (必填, AI会看到)</label>
                            <textarea id="sim-image-desc" rows="3" placeholder="请详细描述图片内容，AI将根据此描述进行回应..."></textarea>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const description = $('#sim-image-desc').value.trim();
                            if (!description) {
                                return UIManager.showToast('图片描述不能为空');
                            }
                            
                            let finalImageSrc = $('#sim-image-preview').src;
                            
                            if (finalImageSrc === defaultPlaceholderSvg) {
                                finalImageSrc = networkFallbackImage;
                            }
                            
                            const message = {
                                messageId: Utils.generateId('msg'),
                                content: `[图文] ${description}`,
                                type: 'sent',
                                segmentType: 'image_simulated',
                                cardData: {
                                    imageSrc: finalImageSrc,
                                    description: description
                                }
                            };

                            await this.handlePlayerSendMessage(message);
                            UIManager.hideModal();
                        }}
                    ]
                });
                
                $('#sim-image-input').addEventListener('change', async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#sim-image-preview').src = await Utils.fileToBase64(file);
                    }
                });
            },

            handlePlayerCardSend() {
                const cardCoverLibrary = appState.cardCoverLibrary || [];
                const defaultCover = cardCoverLibrary.length > 0 ? cardCoverLibrary[Math.floor(Math.random() * cardCoverLibrary.length)] : '';
                
                UIManager.showModal({
                    title: "发送卡片消息",
                    body: `
                        <div class="form-group" style="display: flex; justify-content: space-between; align-items: center;">
                            <label style="margin: 0;">使用“转发”样式</label>
                            <label class="switch">
                                <input type="checkbox" id="card-style-toggle">
                                <span class="slider"></span>
                            </label>
                        </div>

                        <!-- Detailed Card Form -->
                        <div id="detailed-card-form">
                            <div class="form-group">
                                <label>上传图片 (可选)</label>
                                <div class="avatar-uploader">
                                    <img src="${defaultCover}" id="card-image-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                    <input type="file" id="card-image-input" accept="image/*" style="display:none;">
                                    <button class="upload-btn" onclick="document.getElementById('card-image-input').click()">选择图片</button>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="card-share-type">分享类型 (可选)</label>
                                <input type="text" id="card-share-type" placeholder="例如：地点分享, 文件分享">
                            </div>
                            <div class="form-group">
                                <label for="card-title">标题 (必填)</label>
                                <input type="text" id="card-title" placeholder="卡片标题">
                            </div>
                            <div class="form-group">
                                <label for="card-summary">简介 (可选, 35字以内)</label>
                                <input type="text" id="card-summary" placeholder="卡片简介" maxlength="35">
                            </div>
                            <div class="form-group">
                                <label for="card-details">详细内容 (可选, 100字以内)</label>
                                <textarea id="card-details" rows="3" placeholder="点击卡片后显示的详细内容" maxlength="100"></textarea>
                            </div>
                        </div>

                        <!-- Forward Style Form -->
                        <div id="forward-style-form" style="display: none;">
                            <div class="form-group">
                                <label for="forward-title">标题 (必填, 30字以内)</label>
                                <input type="text" id="forward-title" placeholder="转发的标题" maxlength="30">
                            </div>
                            <div class="form-group">
                                <label for="forward-content">内容 (必填, 400字以内)</label>
                                <textarea id="forward-content" rows="4" placeholder="转发的内容" maxlength="400"></textarea>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发送', class: 'btn-primary', handler: async () => {
                            const isForwardStyle = $('#card-style-toggle').checked;
                            const myProfile = await this.getPlayerProfileForContext(appState.currentChatId);
                            let message;
                            let exceededFields = [];

                            if (isForwardStyle) {
                                let title = $('#forward-title').value;
                                let content = $('#forward-content').value;

                                if (title.length > 30) {
                                    title = title.slice(0, 30);
                                    exceededFields.push('转发标题');
                                }
                                if (content.length > 300) {
                                    content = content.slice(0, 300);
                                    exceededFields.push('转发内容');
                                }
                                
                                title = title.trim();
                                content = content.trim();

                                if (!title || !content) return UIManager.showToast("标题和内容不能为空");
                                
                                message = {
                                    segmentType: 'forward_custom',
                                    content: `<转发>\n标题：${title}\n内容：${content}\n</转发>`,
                                    cardData: { title, content }
                                };

                            } else {
                                const title = $('#card-title').value.trim();
                                if (!title) return UIManager.showToast("标题不能为空");
                                
                                let summary = $('#card-summary').value;
                                let details = $('#card-details').value;

                                if (summary.length > 35) {
                                    summary = summary.slice(0, 35);
                                    exceededFields.push('简介');
                                }
                                if (details.length > 100) {
                                    details = details.slice(0, 100);
                                    exceededFields.push('详细内容');
                                }

                                summary = summary.trim();
                                details = details.trim();
                                
                                const shareType = $('#card-share-type').value.trim() || '分享';
                                const imageSrc = $('#card-image-preview').src;

                                message = {
                                    segmentType: 'card',
                                    content: `『${myProfile.name}|${shareType}|${title}|${summary}|${details}』`,
                                    cardData: {
                                        shareType, title, summary, details, imageSrc
                                    }
                                };
                            }
                            
                            if (exceededFields.length > 0) {
                                UIManager.showToast(`${exceededFields.join('、')}超出字数限制，已自动截断。`);
                            }

                            const finalMessage = {
                                messageId: Utils.generateId('msg'),
                                ...message,
                                type: 'sent',
                            };
                            
                            await this.handlePlayerSendMessage(finalMessage);
                            UIManager.hideModal();
                        }}
                    ]
                });

                $('#card-style-toggle').onchange = (e) => {
                    const isForward = e.target.checked;
                    $('#detailed-card-form').style.display = isForward ? 'none' : 'block';
                    $('#forward-style-form').style.display = isForward ? 'block' : 'none';
                };
                
                $('#card-image-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        $('#card-image-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async handleNewMoment() {
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';
                 UIManager.showModal({
                    isPersistent: true,
                    title: "发布动态",
                    body: `
                        <div class="form-group">
                            <label for="new-moment-content">此刻的想法...</label>
                            <textarea id="new-moment-content" rows="5"></textarea>
                        </div>
                        <div class="form-group">
                            <label>上传图片 (可选, 最多9张)</label>
                             <div class="avatar-uploader">
                                <div id="new-moment-images-preview" style="display:flex; flex-wrap:wrap; gap:10px;"></div>
                                <input type="file" id="new-moment-images-input" accept="image/*" multiple style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('new-moment-images-input').click()">选择图片</button>
                            </div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '发布', class: 'btn-primary', handler: async () => {
                            const content = $('#new-moment-content').value.trim();
                            const imagesPreview = $$('#new-moment-images-preview img');
                            const images = Array.from(imagesPreview).map(img => img.src);

                            if (!content && images.length === 0) {
                                return UIManager.showToast("动态内容和图片不能都为空哦");
                            }
                            
                            const myProfile = await this.getPlayerProfileForContext(appState.currentCircleId);
                            const newMoment = {
                                id: Utils.generateId('moment'),
                                circleId: appState.currentCircleId,
                                authorId: myProfile.id,
                                content: content,
                                images: images,
                                timestamp: Date.now(),
                                comments: []
                            };

                            await DBHelper.put('moments', newMoment);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage(); 
                            
                            
                            AIHandler.handleMomentsCommentRequest(newMoment.id);
                        }}
                    ]
                });
                
                $('#new-moment-images-input').addEventListener('change', async (e) => {
                    const files = Array.from(e.target.files).slice(0, 9); 
                    const previewContainer = $('#new-moment-images-preview');
                    previewContainer.innerHTML = '';
                    for (const file of files) {
                        const base64 = await Utils.fileToBase64(file);
                        const img = document.createElement('img');
                        img.src = base64;
                        img.style.width = '60px';
                        img.style.height = '60px';
                        img.style.objectFit = 'cover';
                        img.style.borderRadius = '8px';
                        previewContainer.appendChild(img);
                    }
                });
            },

            async handlePlayerLike(momentId) {
                const myProfile = await this.getPlayerProfileForContext(appState.currentCircleId);
                const moment = await DBHelper.get('moments', momentId);
                if (!moment) return;

                
                if (!moment.likes) {
                    moment.likes = [];
                }

                const playerLikeIndex = moment.likes.indexOf(myProfile.name);

                if (playerLikeIndex > -1) {
                    
                    moment.likes.splice(playerLikeIndex, 1);
                } else {
                    
                    moment.likes.push(myProfile.name);
                }

                await DBHelper.put('moments', moment);

                
                const postElement = $(`[data-moment-id="${momentId}"]`);
                if (!postElement) return;

                const likeBtn = postElement.querySelector('[data-action="like"]');
                const interactionsContainer = postElement.querySelector('.post-interactions');
                const likesContainer = postElement.querySelector('.post-likes');
                const playerHasLiked = playerLikeIndex === -1; 

                
                likeBtn.classList.toggle('liked', playerHasLiked);

                
                if (moment.likes.length > 0) {
                    likesContainer.innerHTML = `<i class="fas fa-heart"></i> ${moment.likes.join(', ')}`;
                    interactionsContainer.style.display = 'block';
                } else {
                    likesContainer.innerHTML = '';
                    
                    if (moment.comments.length === 0) {
                        interactionsContainer.style.display = 'none';
                    }
                }
            },

            toggleCommentInput(postElement, replyToAuthorName = null) {
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const inputField = inputWrapper.querySelector('input');
                
                
                if (inputWrapper.classList.contains('active') && inputWrapper.dataset.replyTo === (replyToAuthorName || '')) {
                    inputWrapper.classList.remove('active');
                    inputWrapper.dataset.replyTo = '';
                    inputField.placeholder = '评论...';
                    return;
                }

                inputWrapper.classList.add('active');
                postElement.querySelector('.post-interactions').style.display = 'block';
                
                if (replyToAuthorName) {
                    inputField.placeholder = `回复 @${replyToAuthorName}:`;
                    inputWrapper.dataset.replyTo = replyToAuthorName;
                } else {
                    inputField.placeholder = '评论...';
                    inputWrapper.dataset.replyTo = '';
                }
                
                inputField.focus();
            },

            async handlePlayerComment(momentId) {
                const postElement = $(`[data-moment-id="${momentId}"]`);
                const inputWrapper = postElement.querySelector('.comment-input-wrapper');
                const input = inputWrapper.querySelector('input');
                const content = input.value.trim();

                if (!content) return;

                const myProfile = await this.getPlayerProfileForContext(appState.currentCircleId);
                const moment = await DBHelper.get('moments', momentId);

                const newComment = {
                    authorId: myProfile.id,
                    content: content,
                    timestamp: Date.now()
                };

                
                const replyTo = inputWrapper.dataset.replyTo;
                if (replyTo) {
                    newComment.replyTo = replyTo;
                }

                if (!moment.comments) moment.comments = [];
                moment.comments.push(newComment);
                await DBHelper.put('moments', moment);

                
                const commentsList = postElement.querySelector('.post-comments-list');
                const commentDiv = document.createElement('div');
                commentDiv.className = 'post-comment-item';
                const replyHtml = replyTo ? `<span class="comment-reply-to"> 回复 </span><span class="comment-author">${replyTo}:</span>` : ':';
                commentDiv.innerHTML = `<span class="comment-author" style="color: #EDD4D8;">${myProfile.name}</span>${replyHtml} ${content}`;
                commentsList.appendChild(commentDiv);

                
                input.value = '';
                input.placeholder = '评论...';
                inputWrapper.dataset.replyTo = '';
                inputWrapper.classList.remove('active');

                
                AIHandler.handleMomentsPlayerCommentResponse(momentId, newComment);
            },

            handleMomentCommentInteractionStart(e, type) {
                const commentItem = e.target.closest('.post-comment-item');
                if (!commentItem) return;

                clearTimeout(appState.longPressTimer);

                const startAction = () => {
                    const existingButton = $('.retract-button-wrapper.show');
                    if (existingButton) existingButton.remove();
                    this.showCommentOptions(commentItem);
                };

                appState.longPressTimer = setTimeout(startAction, 500);

                const clearLongPress = () => {
                    clearTimeout(appState.longPressTimer);
                    document.removeEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                    document.removeEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
                };
                document.addEventListener(type === 'mouse' ? 'mouseup' : 'touchend', clearLongPress);
                document.addEventListener(type === 'mouse' ? 'mouseleave' : 'touchcancel', clearLongPress);
            },

            showCommentOptions(commentItem) {
                const wrapper = document.createElement('div');
                wrapper.className = 'retract-button-wrapper';
                wrapper.style.bottom = 'auto';
                wrapper.style.top = 'calc(100% + 2px)';

                wrapper.innerHTML = `<button class="retract-btn" data-action="delete-comment"><i class="fas fa-trash"></i> 删除</button>`;
                
                wrapper.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const button = e.target.closest('.retract-btn');
                    if (!button) return;

                    const action = button.dataset.action;
                    if (action === 'delete-comment') {
                        const momentId = commentItem.closest('.moments-post').dataset.momentId;
                        const commentIndex = Array.from(commentItem.parentNode.children).indexOf(commentItem);
                        this.confirmDeleteComment(momentId, commentIndex, commentItem);
                    }
                    wrapper.remove();
                });

                commentItem.style.position = 'relative';
                commentItem.appendChild(wrapper);
                setTimeout(() => wrapper.classList.add('show'), 10);
                
                const hideOnClickOutside = (event) => {
                    if (!wrapper.contains(event.target)) {
                        wrapper.remove();
                        document.removeEventListener('click', hideOnClickOutside, true);
                    }
                };
                document.addEventListener('click', hideOnClickOutside, true);
            },

            async confirmDeleteComment(momentId, commentIndex, commentElement) {
                const moment = await DBHelper.get('moments', momentId);
                const comment = moment?.comments?.[commentIndex];
                if (!comment) return;

                const myProfile = await DBHelper.get('profile', 'myProfile');
                const allContacts = await DBHelper.getAll('contacts');
                let authorName = "未知用户";
                if(comment.authorId === myProfile.id) {
                    authorName = myProfile.name;
                } else {
                    const contact = allContacts.find(c => c.id === comment.authorId);
                    authorName = contact ? (contact.remark || contact.name) : (comment.authorId || '未知用户');
                }

                UIManager.showModal({
                    title: "确认删除",
                    body: `
                        <p>确定要删除这条评论吗？</p>
                        <div style="background: rgba(0,0,0,0.05); padding: 10px; border-radius: 8px; margin-top: 10px; font-size: 0.9rem; color: var(--text-color-medium);">
                            <strong>${authorName}:</strong> ${comment.content}
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            moment.comments.splice(commentIndex, 1);
                            await DBHelper.put('moments', moment);
                            commentElement.remove();
                            UIManager.showToast("评论已删除");
                            UIManager.hideModal();
                        }}
                    ]
                });
            },

            async handleSwitchCircle() {
                const circles = await DBHelper.getAll('circles');
                if (circles.length <= 1) {
                    return UIManager.showToast("没有其他圈子可以切换");
                }
                UIManager.showBottomSheet({
                    title: '切换圈子',
                    items: circles.map(c => ({ value: c.id, text: c.name })),
                    onSelect: async (value, text) => {
                        await UIManager.renderMomentsPage(value);
                        UIManager.hideSidebar();
                    }
                });
            },

            async handleViewCircleInfo() {
                const circle = await DBHelper.get('circles', appState.currentCircleId);
                if (!circle) return;

                const allContacts = await DBHelper.getAll('contacts');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                const memberNames = circle.memberIds.map(id => allContacts.find(c => c.id === id)?.name || '未知好友').join('、');
                const extraNames = circle.extraMembers || '无';
                const boundFolders = (await DBHelper.getAll('promptFolders')).filter(f => circle.boundPromptFolderIds && circle.boundPromptFolderIds.includes(f.id));
                const boundFolderNames = boundFolders.map(f => f.name).join('、') || '无';
                
                let boundPersonaName = '未绑定';
                if (circle.boundPersonaPresetIndex !== null && circle.boundPersonaPresetIndex !== undefined && presets[circle.boundPersonaPresetIndex]) {
                    boundPersonaName = presets[circle.boundPersonaPresetIndex].name;
                }

                UIManager.showModal({
                    title: "圈子信息",
                    body: `
                        <div class="details-card">
                            <div class="details-header">
                                <img src="${circle.backgroundImage || 'https://z.wiki/autoupload/20240706/3g0x.250-1_2_0.png'}" class="avatar" style="border-radius: 8px;">
                                <div class="details-info">
                                    <div class="name">${circle.name}</div>
                                </div>
                            </div>
                        </div>
                        <div class="details-card">
                            <div class="details-section">
                                <div class="details-section-title">圈内好友</div>
                                <p style="max-height: 80px;">${memberNames}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">额外好友</div>
                                <p>${extraNames}</p>
                            </div>
                            <div class="details-section">
                                <div class="details-section-title">绑定玩家人设</div>
                                <p>${boundPersonaName}</p>
                            </div>
                             <div class="details-section">
                                <div class="details-section-title">绑定提示词</div>
                                <p>${boundFolderNames}</p>
                            </div>
                        </div>
                    `,
                    actions: [{ text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleAddCircle() {
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                if (allContacts.length === 0) {
                    return UIManager.showToast("通讯录中还没有好友，无法创建圈子。");
                }
                
                let selectedPersonaIndex = null;

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}"><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}"><span>${f.name}</span></label>`).join('');

                UIManager.showModal({
                    title: "新增圈子",
                    body: `
                        <div class="form-group"><label for="circle-name-input">圈子名称</label><input type="text" id="circle-name-input"></div>
                        <div class="form-group"><label>圈内好友 (至少选1个)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">额外好友 (选填, 逗号隔开)</label><input type="text" id="circle-extra-input" placeholder="三三,入入,vv"></div>
                        <div class="form-group"><label>绑定提示词文件夹 (可选)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>绑定玩家人设 (可选)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">未绑定 (使用当前人设)</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '创建', class: 'btn-primary', handler: async () => {
                            const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("圈子名称不能为空");
                            
                            const existing = await DBHelper.getAll('circles', 'name');
                            if(existing.some(c => c.name === name)) return UIManager.showToast("该圈子名称已存在");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("至少选择一名好友");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const newCircle = {
                                id: Utils.generateId('circle'),
                                name: name,
                                memberIds: memberIds,
                                extraMembers: $('#circle-extra-input').value.trim(),
                                boundPromptFolderIds: boundPromptFolderIds,
                                boundPersonaPresetId: selectedPersonaIndex, // 改为ID
                                backgroundImage: null,
                                createdAt: Date.now(),
                                lastRefreshed: 0
                            };

                            await DBHelper.put('circles', newCircle);
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage(newCircle.id); 
                        }}
                    ]
                });

                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const myProfile = await DBHelper.get('profile', 'myProfile');
                    const presets = myProfile.presets || [];
                    const items = [
                        { value: 'null', text: '不绑定 (使用当前人设)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, // 使用 presetId
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: '选择玩家人设',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaIndex = (value === 'null') ? null : value;
                            if (selectedPersonaIndex === null) {
                                $('#circle-persona-name').textContent = '未绑定 (使用当前人设)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleEditCircle(circleId) {
                if (!circleId) return UIManager.showToast("请先选择一个圈子");
                const circle = await DBHelper.get('circles', circleId);
                const allContacts = await DBHelper.getAll('contacts');
                const allFolders = await DBHelper.getAll('promptFolders');
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = myProfile.presets || [];

                let selectedPersonaIndex = circle.boundPersonaPresetIndex;
                let personaName = '未绑定 (使用当前人设)';
                if (selectedPersonaIndex !== null && presets[selectedPersonaIndex]) {
                    personaName = presets[selectedPersonaIndex].name;
                }

                const membersHtml = allContacts.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-members" value="${f.id}" ${circle.memberIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');
                const foldersHtml = allFolders.map(f => `<label class="member-select-item"><input type="checkbox" name="circle-folders" value="${f.id}" ${circle.boundPromptFolderIds.includes(f.id) ? 'checked' : ''}><span>${f.name}</span></label>`).join('');

                 UIManager.showModal({
                    title: "修改圈子",
                    body: `
                        <div class="form-group"><label for="circle-name-input">圈子名称</label><input type="text" id="circle-name-input" value="${circle.name}"></div>
                        <div class="form-group"><label>圈内好友 (至少选1个)</label><div class="member-select-list">${membersHtml}</div></div>
                        <div class="form-group"><label for="circle-extra-input">额外好友 (选填, 逗号隔开)</label><input type="text" id="circle-extra-input" value="${circle.extraMembers || ''}"></div>
                        <div class="form-group"><label>绑定提示词文件夹 (可选)</label><div class="member-select-list" style="max-height:150px;">${foldersHtml}</div></div>
                        <div class="form-group">
                            <label>绑定玩家人设 (可选)</label>
                            <button id="circle-persona-bind-btn" class="modal-btn btn-secondary" style="width: 100%; text-align: left; padding: 12px 15px;">
                                <i class="fas fa-user-tag" style="margin-right: 10px;"></i>
                                <span id="circle-persona-name">${personaName}</span>
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                             const name = $('#circle-name-input').value.trim();
                            if (!name) return UIManager.showToast("圈子名称不能为空");
                            
                            const existing = (await DBHelper.getAll('circles', 'name')).filter(c => c.id !== circleId);
                            if(existing.some(c => c.name === name)) return UIManager.showToast("该圈子名称已存在");

                            const memberIds = [...$$('input[name="circle-members"]:checked')].map(cb => cb.value);
                            if (memberIds.length === 0) return UIManager.showToast("至少选择一名好友");

                            const boundPromptFolderIds = [...$$('input[name="circle-folders"]:checked')].map(cb => cb.value);
                            
                            const updatedCircle = { 
                                ...circle, 
                                name, 
                                memberIds, 
                                boundPromptFolderIds, 
                                boundPersonaPresetId: selectedPersonaIndex, // 改为ID
                                extraMembers: $('#circle-extra-input').value.trim() 
                            };
                            await DBHelper.put('circles', updatedCircle);
                            UIManager.hideModal();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                });
                
                $('#circle-persona-bind-btn').addEventListener('click', async () => {
                    const items = [
                        { value: 'null', text: '不绑定 (使用当前人设)' },
                        ...presets.map(preset => ({
                            value: preset.presetId, // 使用 presetId
                            text: preset.name
                        }))
                    ];
                    UIManager.showBottomSheet({
                        title: '选择玩家人设',
                        items: items,
                        onSelect: (value, text) => {
                            selectedPersonaIndex = (value === 'null') ? null : value;
                            if (selectedPersonaIndex === null) {
                                $('#circle-persona-name').textContent = '不绑定 (使用当前人设)';
                            } else {
                                $('#circle-persona-name').textContent = text;
                            }
                        }
                    });
                });
            },

            async handleDeleteCircle() {
                const circles = await DBHelper.getAll('circles');
                 if (circles.length === 0) return UIManager.showToast("没有可删除的圈子");

                const circlesHtml = circles.map(c => `<label class="member-select-item"><input type="checkbox" name="delete-circle" value="${c.id}"><span>${c.name}</span></label>`).join('');
                 UIManager.showModal({
                    title: "删除圈子",
                    body: `<p style="margin-bottom:10px;">选择要删除的圈子（将同时删除圈子下的所有动态）：</p><div class="member-select-list">${circlesHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '删除', class: 'btn-danger', handler: async () => {
                            const idsToDelete = [...$$('input[name="delete-circle"]:checked')].map(cb => cb.value);
                            if (idsToDelete.length === 0) return;

                            for (const id of idsToDelete) {
                                await DBHelper.delete('circles', id);
                                const momentsToDelete = (await DBHelper.getAll('moments')).filter(m => m.circleId === id);
                                for (const moment of momentsToDelete) {
                                    await DBHelper.delete('moments', moment.id);
                                }
                            }
                            
                            if (idsToDelete.includes(appState.currentCircleId)) {
                                appState.currentCircleId = null; 
                            }
                            
                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                        }}
                    ]
                 });
            },

            async handleClearCircleHistory() {
                const circleId = appState.currentCircleId;
                if (!circleId) return;

                const circle = await DBHelper.get('circles', circleId);

                UIManager.showModal({
                    title: `清空"${circle.name}"动态`,
                    body: `<p>确定要清空此朋友圈的所有动态吗？此操作不可恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认清空', class: 'btn-danger', handler: async () => {
                            const allMoments = await DBHelper.getAll('moments');
                            const momentsToDelete = allMoments.filter(m => m.circleId === circleId);

                            for (const moment of momentsToDelete) {
                                await DBHelper.delete('moments', moment.id);
                            }

                            UIManager.hideModal();
                            UIManager.hideSidebar();
                            await UIManager.renderMomentsPage();
                            UIManager.showToast(`"${circle.name}" 的动态已清空。`);
                        }}
                    ]
                });
            },

            async handleExportPrompts() {
                const folders = await DBHelper.getAll('promptFolders');
                if (folders.length === 0) {
                    return UIManager.showToast("没有可导出的文件夹");
                }
                const folderListHtml = folders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="export-folder" value="${f.id}">
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "选择要导出的文件夹",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '生成文件', class: 'btn-primary', handler: async () => {
                            const selectedFolderIds = [...$$('input[name="export-folder"]:checked')].map(cb => cb.value);
                            if (selectedFolderIds.length === 0) {
                                return UIManager.showToast("请至少选择一个文件夹");
                            }

                            const allPrompts = await DBHelper.getAll('prompts');
                            
                            
                            let filenamePart;
                            if (selectedFolderIds.length === 1) {
                                const folder = folders.find(f => f.id === selectedFolderIds[0]);
                                filenamePart = folder ? folder.name : '未知文件夹';
                            } else {
                                filenamePart = '多个文件夹_提示词导出';
                            }
                            const finalFilename = `${filenamePart}_${new Date().toISOString().slice(0,10)}.json`;
                            
                            
                            const foldersToExport = folders.filter(f => selectedFolderIds.includes(f.id));
                            const promptsToExport = allPrompts.filter(p => selectedFolderIds.includes(p.folderId));
                            
                            const exportData = {
                                folders: foldersToExport,
                                prompts: promptsToExport
                            };
                            
                            const jsonString = JSON.stringify(exportData, null, 2);
                            const blob = new Blob([jsonString], {type: "application/json"});
                            const url = URL.createObjectURL(blob);
                            
                            UIManager.showModal({
                                title: '文件已生成',
                                body: `
                                    <p>请点击下面的链接下载文件。</p>
                                    <a href="${url}" download="${finalFilename}" class="modal-btn btn-primary" style="display: block; text-align: center; margin-top: 20px;">
                                        点击下载 ${finalFilename}
                                    </a>
                                    <p style="font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 15px;">(下载后此链接将失效)</p>
                                `,
                                actions: [{
                                    text: '关闭',
                                    class: 'btn-secondary',
                                    handler: () => {
                                        URL.revokeObjectURL(url);
                                        UIManager.hideModal();
                                    }
                                }]
                            });
                        }}
                    ]
                });
            },

            async handleWishPool() {
                UIManager.showModal({
                    title: "角色许愿池",
                    body: `
                        <div class="details-actions" style="flex-direction: column; gap: 15px;">
                            <button class="details-btn" data-action="buyable" style="border-color: var(--accent-color); color: var(--accent-color-deep);">
                                <i class="fas fa-shopping-cart" style="margin-right: 8px;"></i>可购角色卡
                            </button>
                            <button class="details-btn" data-action="wishlist" style="border-color: var(--theme-color-2);">
                                <i class="fas fa-list-alt" style="margin-right: 8px;"></i>许愿池清单
                            </button>
                        </div>
                    `,
                    actions: [
                        { text: '关闭', class: 'btn-secondary', handler: () => UIManager.hideModal() }
                    ]
                });
                
                modalContentWrapper.querySelector('[data-action="buyable"]').addEventListener('click', () => {
                    window.open('https://kdocs.cn/l/cdeUgNwxlWKR', '_blank');
                });
                modalContentWrapper.querySelector('[data-action="wishlist"]').addEventListener('click', () => {
                    window.open('https://docs.qq.com/form/page/DUG5yVWFEZGFxRXd1', '_blank');
                });
            },

            handleImportPrompts() {
                const fileInput = $('#import-prompts-input');
                fileInput.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const importedData = JSON.parse(event.target.result);
                            
                            if (!importedData.folders || !importedData.prompts) {
                                return UIManager.showToast("文件格式不正确");
                            }
                            
                            const existingFolders = await DBHelper.getAll('promptFolders');
                            let importedCount = 0;

                            for (const importedFolder of importedData.folders) {
                                if (existingFolders.some(f => f.name === importedFolder.name)) {
                                    UIManager.showToast(`已跳过：文件夹 "${importedFolder.name}" 已存在`);
                                    continue;
                                }
                                
                                const oldFolderId = importedFolder.id;
                                const newFolder = {
                                    ...importedFolder,
                                    id: Utils.generateId('folder'), 
                                    createdAt: Date.now()
                                };
                                await DBHelper.put('promptFolders', newFolder);
                                
                                
                                const promptsToImport = importedData.prompts.filter(p => p.folderId === oldFolderId);
                                for (const importedPrompt of promptsToImport) {
                                    const newPrompt = {
                                        ...importedPrompt,
                                        id: Utils.generateId('prompt'), 
                                        folderId: newFolder.id, 
                                        createdAt: Date.now()
                                    };
                                    await DBHelper.put('prompts', newPrompt);
                                    importedCount++;
                                }
                            }
                            
                            UIManager.showToast(`导入完成，共导入 ${importedCount} 条提示词`);
                            this.renderPromptsPage();

                        } catch (error) {
                            console.error("导入失败: ", error);
                            UIManager.showToast("导入失败，文件可能已损坏");
                        } finally {
                            
                            fileInput.value = '';
                        }
                    };
                    reader.readAsText(file);
                };
                fileInput.click();
            },

            async showAddEditFriendFolderModal(folderId = null) {
                const isEditing = folderId !== null;
                const folder = isEditing ? await DBHelper.get('friendFolders', folderId) : null;
                const allContacts = await DBHelper.getAll('contacts');
                const allFriendFolders = await DBHelper.getAll('friendFolders');
                const folderMap = allFriendFolders.reduce((map, f) => {
                    map[f.id] = f.name;
                    return map;
                }, {});

                let membersHtml = allContacts.map(contact => {
                    const isChecked = isEditing && folder.memberIds.includes(contact.id);
                    let groupInfo = '';
                    if (contact.folderId && (!isEditing || contact.folderId !== folderId)) {
                        groupInfo = ` (在分组: ${folderMap[contact.folderId] || '未知'})`;
                    }
                    return `
                        <label class="member-select-item" data-friend-name="${(contact.remark || contact.name).toLowerCase()}" data-friend-id="${contact.name.toLowerCase()}">
                            <input type="checkbox" name="friend-folder-members" value="${contact.id}" ${isChecked ? 'checked' : ''}>
                            <img src="${contact.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${contact.remark || contact.name}${groupInfo}</span>
                        </label>
                    `;
                }).join('');

                UIManager.showModal({
                    title: isEditing ? '编辑好友分组' : '新建好友分组',
                    body: `
                        <div class="form-group">
                            <label for="friend-folder-name">分组名称</label>
                            <input type="text" id="friend-folder-name" value="${isEditing ? folder.name : ''}">
                        </div>
                        <div class="form-group">
                            <label for="friend-folder-search">搜索好友 (备注/ID)</label>
                            <input type="text" id="friend-folder-search" placeholder="输入以筛选列表...">
                        </div>
                        <div class="form-group">
                            <label>选择好友</label>
                            <div class="member-select-list" id="friend-folder-member-list">${membersHtml}</div>
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const name = $('#friend-folder-name').value.trim();
                            if (!name) return UIManager.showToast("分组名称不能为空");

                            const existingFolders = (await DBHelper.getAll('friendFolders')).filter(f => f.id !== folderId);
                            if (existingFolders.some(f => f.name === name)) {
                                return UIManager.showToast("该分组名称已存在");
                            }

                            const selectedMemberIds = [...$$('input[name="friend-folder-members"]:checked')].map(cb => cb.value);
                            const updatedFolder = isEditing ? { ...folder, name, memberIds: selectedMemberIds } : {
                                id: Utils.generateId('friendFolder'),
                                name,
                                memberIds: selectedMemberIds,
                                boundPersonaPresetIndex: null,
                                createdAt: Date.now()
                            };

                            await DBHelper.put('friendFolders', updatedFolder);

                            const contactsToUpdate = await Promise.all(
                                allContacts.map(c => DBHelper.get('contacts', c.id))
                            );

                            for (const contact of contactsToUpdate) {
                                const isInNewSelection = selectedMemberIds.includes(contact.id);
                                
                                if (isInNewSelection && contact.folderId !== updatedFolder.id) {
                                    contact.folderId = updatedFolder.id;
                                    await DBHelper.put('contacts', contact);
                                } else if (!isInNewSelection && contact.folderId === updatedFolder.id) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                        }}
                    ]
                });
                
                $('#friend-folder-search').addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    $$('#friend-folder-member-list .member-select-item').forEach(item => {
                        const name = item.dataset.friendName;
                        const id = item.dataset.friendId;
                        item.style.display = (name.includes(searchTerm) || id.includes(searchTerm)) ? 'flex' : 'none';
                    });
                });
            },

            async confirmDeleteFriendFolder(folderId) {
                const folder = await DBHelper.get('friendFolders', folderId);
                if (!folder) return;

                const allGroups = await DBHelper.getAll('groups');
                const problematicMembers = [];
                for (const memberId of folder.memberIds) {
                    const groupsIn = allGroups.filter(g => g.members.includes(memberId));
                    if (groupsIn.length > 0) {
                        const contact = await DBHelper.get('contacts', memberId);
                        problematicMembers.push({
                            name: contact.remark || contact.name,
                            groups: groupsIn.map(g => g.name).join(', ')
                        });
                    }
                }

                if (problematicMembers.length > 0) {
                    const errorMsg = problematicMembers.map(p => `<strong>${p.name}</strong> 仍在群聊: ${p.groups}`).join('<br>');
                    return UIManager.showModal({
                        title: "无法删除分组",
                        body: `<p>以下好友因仍在群聊中而无法删除此好友分组，请先将其移出群聊：</p><div style="text-align:left; max-height: 150px; overflow-y: auto; background: #f0f0f0; padding: 10px; border-radius: 8px;">${errorMsg}</div>`,
                        actions: [{ text: '好的', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                    });
                }

                UIManager.showModal({
                    title: '确认删除分组',
                    body: `<p>确定要删除分组 <strong>"${folder.name}"</strong> 吗？分组内的好友将被移至“未分组”。此操作不可恢复。</p>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认删除', class: 'btn-danger', handler: async () => {
                            for (const memberId of folder.memberIds) {
                                const contact = await DBHelper.get('contacts', memberId);
                                if (contact && contact.folderId === folderId) {
                                    delete contact.folderId;
                                    await DBHelper.put('contacts', contact);
                                }
                            }
                            await DBHelper.delete('friendFolders', folderId);
                            
                            UIManager.hideModal();
                            await UIManager.renderFriendFoldersPage();
                            UIManager.showToast(`分组 "${folder.name}" 已删除。`);
                        }}
                    ]
                });
            },
            
            async showPersonaBindingModal(entityId, isGroupChat) {
                const myProfile = await DBHelper.get('profile', 'myProfile');
                const presets = (myProfile.presets || []).filter(p => p); // 过滤掉可能的 null 值

                let entity, storeName;
                if (isGroupChat) {
                    entity = await DBHelper.get('groups', entityId);
                    storeName = 'groups';
                } else {
                    entity = await DBHelper.get('contacts', entityId);
                    if (entity) {
                        storeName = 'contacts';
                    } else {
                        entity = await DBHelper.get('friendFolders', entityId);
                        storeName = 'friendFolders';
                    }
                }

                if (!entity) return;

                const boundId = entity.boundPersonaPresetId; // 使用 ID

                let presetsHtml = presets.map(preset => {
                    return `
                        <label class="member-select-item">
                            <input type="radio" name="persona-preset" value="${preset.presetId}" ${boundId === preset.presetId ? 'checked' : ''}>
                            <img src="${preset.avatar}" class="contact-item-avatar" style="width:30px;height:30px;margin-right:10px;">
                            <span>${preset.name}</span>
                        </label>
                    `;
                }).join('');

                let boundInfo = '';
                if (boundId && !presets.some(p => p.presetId === boundId)) {
                    boundInfo = `<p style="color: #e74c3c; text-align: center; margin-bottom: 10px;">注意：已绑定的预设已被删除，将自动使用当前玩家人设。</p>`;
                }
                
                const hint = `<p style="font-size: 0.8rem; color: var(--text-color-medium); text-align: center; margin-top: 15px;">提示：好友分组和群聊的人设绑定是分开的，不要忘记啦。</p>`;

                UIManager.showModal({
                    title: '绑定玩家人设',
                    body: `
                        ${boundInfo}
                        <div class="member-select-list" style="max-height: 40vh;">
                            <label class="member-select-item">
                                <input type="radio" name="persona-preset" value="null" ${!boundId ? 'checked' : ''}>
                                <span>不绑定 (使用当前人设)</span>
                            </label>
                            ${presetsHtml}
                        </div>
                        ${hint}
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedRadio = document.querySelector('input[name="persona-preset"]:checked');
                            if (!selectedRadio) return;

                            const selectedId = selectedRadio.value;
                            entity.boundPersonaPresetId = (selectedId === 'null') ? null : selectedId;

                            // 同时清除旧的索引式绑定，以防万一
                            delete entity.boundPersonaPresetIndex;

                            await DBHelper.put(storeName, entity);
                            
                            UIManager.hideModal();
                            UIManager.showToast('人设绑定已更新！');
                        }}
                    ]
                });
            },

            startPomodoro() {
                const goal = $('#pomodoro-goal-input').value.trim();
                if (!goal) {
                    UIManager.showToast("先为你的专注时段定一个目标吧！");
                    return;
                }

                appState.pomodoro.isActive = true;
                appState.pomodoro.goal = goal;
                appState.pomodoro.totalSeconds = 1500; // 确保每次开始都是完整的25分钟
                appState.pomodoro.endTime = Date.now() + appState.pomodoro.totalSeconds * 1000;
                appState.pomodoro.timerId = setInterval(() => this.updatePomodoroTimer(), 1000);

                // 新增：保存状态到本地存储
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            stopPomodoro(isCompleted = false) {
                if (!appState.pomodoro.isActive) return;

                clearInterval(appState.pomodoro.timerId);

                if (isCompleted) {
                    UIManager.showPomodoroEndNotification(appState.pomodoro.goal);
                }

                appState.pomodoro.isActive = false;
                appState.pomodoro.goal = '';
                appState.pomodoro.endTime = null;
                appState.pomodoro.timerId = null;
                
                // 新增：更新或清除本地存储的状态
                localStorage.setItem('pomodoroState', JSON.stringify(appState.pomodoro));

                UIManager.renderPomodoroPage();
                this.updateFloatingBallVisibility();
            },

            updatePomodoroTimer() {
                if (!appState.pomodoro.isActive || !appState.pomodoro.endTime) {
                    this.stopPomodoro();
                    return;
                }

                const now = Date.now();
                const remainingSeconds = Math.round((appState.pomodoro.endTime - now) / 1000);

                if (remainingSeconds <= 0) {
                    this.stopPomodoro(true);
                    return;
                }

                const minutes = Math.floor(remainingSeconds / 60);
                const seconds = remainingSeconds % 60;
                const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                if (appState.currentPage === 'pomodoro') {
                    $('#pomodoro-timer-display').textContent = timeString;
                }
                
                const floatBall = $('#pomodoro-float-ball');
                if (floatBall) {
                    floatBall.querySelector('.time-left').textContent = timeString;
                    const progress = (appState.pomodoro.totalSeconds - remainingSeconds) / appState.pomodoro.totalSeconds;
                    floatBall.querySelector('.progress-ring').style.background = `conic-gradient(var(--accent-color) ${progress * 360}deg, #e0e0e0 0deg)`;
                }
            },

            updateFloatingBallVisibility() {
                const floatBall = $('#pomodoro-float-ball');
                if (appState.pomodoro.isActive && appState.currentPage !== 'pomodoro') {
                    floatBall.classList.remove('hidden');
                } else {
                    floatBall.classList.add('hidden');
                }
            },



            createGiftCard(giftData) {
                const card = document.createElement('div');
                card.className = 'gift-card';
                card.innerHTML = `
                    <img src="${giftData.image || giftData.url}" alt="${giftData.name}">
                    <div class="gift-card-info">
                        <div class="name">${giftData.name}</div>
                        <div class="price">￥${giftData.price.toFixed(2)}</div>
                    </div>
                `;
                return card;
            },

            showGiftHelpModal() {
                UIManager.showModal({
                    title: "礼物搜索帮助",
                    body: `
                        <p>礼物搜索功能通过AI生成，因此在使用前需要正确配置API，此功能仅供娱乐搜索。除了AI搜索，你还可以选择<strong>自定义</strong>手动填入自己想要赠送的礼物</p>
                        <p><strong>1. API配置：</strong> 点击页面上的“API配置”按钮，填入你的API信息。由于礼物搜索功能相对简单，你可以选择一些免费或价格较低的模型。</p>
                        <p><strong>2. 推荐模型：</strong></p>
                        <ul>
                            <li><strong>SiliconFlow (硅基流动):</strong> <code>deepseek-ai/DeepSeek-R1-0528-Qwen3-8B</code>(在硅基流动官网上,该模型目前是免费模型,但使用时依然需要填写正确的API key)</li>
                        </ul>
                        <p><strong>3. 绑定提示词：</strong> 你还可以通过“绑定”功能，选择一个或多个自定义提示词文件夹。这些提示词将在每次搜索时附加，用于影响AI生成礼物的风格和类型，实现更个性化的搜索结果。</p>
                    `,
                    actions: [{ text: '我明白了', class: 'btn-primary', handler: () => UIManager.hideModal() }]
                });
            },

            async handleGiftPromptBinding() {
                const giftApiConfig = await DBHelper.get('giftApiConfig', 'mainConfig') || {};
                const boundFolderIds = giftApiConfig.giftPromptFolderIds || [];
                const allFolders = await DBHelper.getAll('promptFolders');

                if (allFolders.length === 0) {
                    return UIManager.showToast("你还没有创建任何提示词文件夹。");
                }

                const folderListHtml = allFolders.map(f => `
                    <label class="folder-selection-item">
                        <input type="checkbox" name="bind-gift-folder" value="${f.id}" ${boundFolderIds.includes(f.id) ? 'checked' : ''}>
                        <i class="fas fa-folder"></i>
                        <span>${f.name}</span>
                    </label>
                `).join('');

                UIManager.showModal({
                    title: "绑定礼物搜索提示词",
                    body: `<div class="folder-selection-list">${folderListHtml}</div>`,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const selectedIds = [...$$('input[name="bind-gift-folder"]:checked')].map(cb => cb.value);
                            const configToSave = await DBHelper.get('giftApiConfig', 'mainConfig') || { id: 'mainConfig' };
                            configToSave.giftPromptFolderIds = selectedIds;
                            await DBHelper.put('giftApiConfig', configToSave);
                            UIManager.hideModal();
                            UIManager.showToast("绑定已更新！");
                        }}
                    ]
                });
            },

            async showSendGiftModal(giftData) {
                const isGroup = appState.currentChatId.startsWith('group-');

                const displayFinalModal = (recipient) => {
                    UIManager.showModal({
                        title: `送给 ${recipient.remark || recipient.name}`,
                        body: `
                            <div style="text-align: center; margin-bottom: 20px;">
                                <img src="${giftData.image || giftData.url}" alt="${giftData.name}" style="width: 100px; height: 100px; object-fit: cover; border-radius: 12px;">
                                <h4 style="margin: 10px 0 5px;">${giftData.name}</h4>
                                <p style="color: var(--text-color-medium); font-size: 0.9rem; margin-bottom: 10px;">${giftData.description || giftData.message || '一份特别的礼物'}</p>
                                <p style="color: var(--accent-color-deep); font-weight: bold;">￥${giftData.price.toFixed(2)}</p>
                            </div>
                            <div class="form-group">
                                <label for="gift-final-message">寄语 (选填)</label>
                                <input type="text" id="gift-final-message" value="" placeholder="送你一份心意。">
                            </div>
                        `,
                        actions: [
                            { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                            { text: '赠送', class: 'btn-primary', handler: async () => {
                                const message = $('#gift-final-message').value.trim();
                                
                                const giftMessage = {
                                    messageId: Utils.generateId('msg'),
                                    content: `[礼物] ${giftData.name}`,
                                    type: 'sent',
                                    segmentType: 'gift',
                                    cardData: {
                                        recipientName: recipient.name, // Use the correct recipient name
                                        name: giftData.name,
                                        price: giftData.price.toFixed(2),
                                        image: giftData.image || giftData.url,
                                        message: message || '送你一份心意。',
                                        description: giftData.description || ''
                                    }
                                };
                                
                                await this.handlePlayerSendMessage(giftMessage);
                                UIManager.hideModal();
                                UIManager.navigateTo('chat');
                            }}
                        ]
                    });
                };

                if (isGroup) {
                    const group = await DBHelper.get('groups', appState.currentChatId);
                    const allContacts = await DBHelper.getAll('contacts');
                    const members = group.members
                        .map(id => allContacts.find(c => c.id === id))
                        .filter(Boolean);

                    if (members.length === 0) {
                        return UIManager.showToast("群聊中没有可以赠送礼物的成员。");
                    }

                    UIManager.showBottomSheet({
                        title: '选择要赠送的成员',
                        customClass: 'compact-list',
                        items: members.map(m => ({ value: m.id, text: m.remark || m.name })),
                        onSelect: async (selectedMemberId) => {
                            const selectedMember = members.find(m => m.id === selectedMemberId);
                            if (selectedMember) {
                                displayFinalModal(selectedMember);
                            }
                        }
                    });

                } else {
                    const recipient = await DBHelper.get('contacts', appState.currentChatId);
                    if (recipient) {
                        displayFinalModal(recipient);
                    }
                }
            },

async showGiftDetailsModal(messageId) {
    const msg = await DBHelper.get('messages', messageId);
    if (!msg || !msg.cardData) return;

    const myProfile = await this.getPlayerProfileForContext(msg.chatId);
    let sender, recipient;

    if (msg.type === 'sent') {
        sender = myProfile;
        const isGroupChat = msg.chatId.startsWith('group-');
        if (isGroupChat) {
            // 在群聊中，接收方是存储在cardData里的特定成员
            const allContacts = await DBHelper.getAll('contacts');
            recipient = allContacts.find(c => c.name === msg.cardData.recipientName) || { name: msg.cardData.recipientName };
        } else {
            // 在私聊中，接收方就是对方
            recipient = await DBHelper.get('contacts', msg.chatId);
        }
    } else {
        // 如果是收到的礼物，发送方是AI，接收方是我
        sender = await DBHelper.get('contacts', msg.senderId) || { name: '未知发件人' };
        recipient = myProfile;
    }

    UIManager.showModal({
        title: "礼物详情",
        body: `
            <div style="text-align: center; margin-bottom: 20px;">
                <img src="${msg.cardData.image}" alt="${msg.cardData.name}" style="width: 120px; height: 120px; object-fit: cover; border-radius: 12px; box-shadow: var(--shadow-light);">
                <h3 style="margin: 15px 0 5px;">${msg.cardData.name}</h3>
                <p style="color: var(--accent-color-deep); font-weight: bold; margin-bottom: 15px;">￥${msg.cardData.price}</p>
            </div>
            <div class="details-card" style="padding: 15px;">
                <div class="details-field"><span class="label">赠送方</span><span class="value">${sender.name}</span></div>
                <div class="details-field"><span class="label">接收方</span><span class="value">${recipient.name}</span></div>
                ${msg.cardData.description ? `
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">礼物介绍</div>
                    <p>${msg.cardData.description}</p>
                </div>` : ''}
                <div class="details-section" style="margin-top: 15px;">
                    <div class="details-section-title">寄语</div>
                    <p>${msg.cardData.message}</p>
                </div>
            </div>
        `,
        actions: [
            { text: '关闭', class: 'btn-primary', handler: () => UIManager.hideModal() }
        ]
    });
},
            
            showCustomGiftModal() {
                const giftImageLibrary = [
                    'https://cfimg.200996.xyz/file/1752744399723_retouch_2025071717250175.png',
                    'https://cfimg.200996.xyz/file/1752744402256_retouch_2025071717245049.png',
                    'https://cfimg.200996.xyz/file/1752744401540_retouch_2025071717242531.png',
                    'https://cfimg.200996.xyz/file/1752744403509_retouch_2025071717243405.png',
                    'https://cfimg.200996.xyz/file/1752744399889_retouch_2025071717244351.png'
                ];
                const defaultPlaceholderSvg = 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAiIGhlaWdodD0iMTAwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHJlY3Qgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiIGZpbGw9IiNlYWVhZWEiLz48dGV4dCB4PSI1MCUiIHk9IjUwJSIgZm9uLXNpemU9IjEyIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSIgZmlsbD0iI2FhYSI+6YCa6K6v5Zu+54mHPC90ZXh0Pjwvc3ZnPg==';

                UIManager.showModal({
                    title: "自定义礼物",
                    body: `
                        <div class="form-group">
                            <label>上传礼物图片 (可选)</label>
                            <div class="avatar-uploader">
                                <img src="${defaultPlaceholderSvg}" id="custom-gift-preview" style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;">
                                <input type="file" id="custom-gift-input" accept="image/*" style="display:none;">
                                <button class="upload-btn" onclick="document.getElementById('custom-gift-input').click()">选择图片</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-name">礼物名称</label>
                            <input type="text" id="custom-gift-name" placeholder="例如：永恒的爱">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-description">礼物介绍 (选填)</label>
                            <textarea id="custom-gift-description" rows="2" placeholder="描述一下这个礼物..."></textarea>
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-price">礼物价格</label>
                            <input type="number" id="custom-gift-price" placeholder="0.00">
                        </div>
                        <div class="form-group">
                            <label for="custom-gift-message">寄语 (选填)</label>
                            <input type="text" id="custom-gift-message" placeholder="一点心意...">
                        </div>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '确认', class: 'btn-primary', handler: () => {
                            let imageUrl = $('#custom-gift-preview').src;
                            // 如果用户没有上传图片，则从库中随机选择一个
                            if (imageUrl === defaultPlaceholderSvg) {
                                imageUrl = giftImageLibrary[Math.floor(Math.random() * giftImageLibrary.length)];
                            }

                            const customGift = {
                                name: $('#custom-gift-name').value.trim(),
                                price: parseFloat($('#custom-gift-price').value) || 0,
                                image: imageUrl,
                                message: $('#custom-gift-message').value.trim(),
                                description: $('#custom-gift-description').value.trim(),
                            };

                            if (!customGift.name) {
                                return UIManager.showToast("礼物名称不能为空哦");
                            }
                            UIManager.hideModal();
                            this.showSendGiftModal(customGift);
                        }}
                    ]
                });
                
                $('#custom-gift-input').onchange = async (e) => {
                    const file = e.target.files[0];
                    if(file) {
                         $('#custom-gift-preview').src = await Utils.fileToBase64(file);
                    }
                };
            },

            async showGiftApiConfigModal() {
                let config = await DBHelper.get('giftApiConfig', 'mainConfig');
                if (!config) {
                    // 默认配置
                    config = { id: 'mainConfig', provider: 'siliconflow', url: '', key: '', model: '' };
                }

                 UIManager.showModal({
                    title: '礼物搜索 API 配置',
                    body: `
                        <div class="form-group">
                            <label for="gift-api-provider">API提供商</label>
                            <select id="gift-api-provider">
                                <option value="siliconflow" ${config.provider === 'siliconflow' ? 'selected' : ''}>SiliconFlow (硅基流动)</option>
                                <option value="gemini" ${config.provider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                                <option value="paioupu" ${config.provider === 'paioupu' ? 'selected' : ''}>派欧云</option>
                                <option value="custom" ${config.provider === 'custom' ? 'selected' : ''}>自定义</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-url">API URL</label>
                            <input type="text" id="gift-api-url" value="${config.url}" placeholder="输入API URL">
                        </div>
                        <div class="form-group">
                            <label for="gift-api-key">API Key</label>
                            <div style="position: relative; display: flex; align-items: center;">
                                <input type="password" id="gift-api-key" value="${config.key}" placeholder="输入API密钥" style="width: 100%; padding-right: 40px;">
                                <i class="fas fa-eye" id="toggle-gift-api-key-visibility" style="position: absolute; right: 15px; cursor: pointer; color: #aaa;"></i>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="gift-api-model-select">模型</label>
                            <select id="gift-api-model-select"></select>
                            <input type="text" id="gift-api-model-input" value="${config.model}" placeholder="输入自定义模型名称" style="display:none;">
                        </div>
                        <button id="use-default-api-btn" class="modal-btn btn-secondary" style="width: 100%; margin-top: 10px;">使用主API配置</button>
                    `,
                    actions: [
                        { text: '取消', class: 'btn-secondary', handler: () => UIManager.hideModal() },
                        { text: '保存', class: 'btn-primary', handler: async () => {
                            const newConfig = {
                                id: 'mainConfig',
                                provider: $('#gift-api-provider').value,
                                url: $('#gift-api-url').value.trim(),
                                key: $('#gift-api-key').value.trim(),
                                temperature: 0.5 // 固定一个较低的温度以保证格式稳定
                            };
                            
                            const modelSelect = $('#gift-api-model-select');
                            const modelInput = $('#gift-api-model-input');
                            if (modelInput.style.display !== 'none') {
                                newConfig.model = modelInput.value.trim();
                            } else {
                                newConfig.model = modelSelect.value;
                            }

                            await DBHelper.put('giftApiConfig', newConfig);
                            UIManager.hideModal();
                        }}
                    ]
                });

                const updateGiftApiFields = () => {
                const giftToggleBtn = $('#toggle-gift-api-key-visibility');
                const giftApiKeyInput = $('#gift-api-key');
                giftToggleBtn.addEventListener('click', () => {
                    if (giftApiKeyInput.type === 'password') {
                        giftApiKeyInput.type = 'text';
                        giftToggleBtn.classList.remove('fa-eye');
                        giftToggleBtn.classList.add('fa-eye-slash');
                    } else {
                        giftApiKeyInput.type = 'password';
                        giftToggleBtn.classList.remove('fa-eye-slash');
                        giftToggleBtn.classList.add('fa-eye');
                    }
                });
                    const provider = $('#gift-api-provider').value;
                    const apiUrlInput = $('#gift-api-url');
                    const modelSelect = $('#gift-api-model-select');
                    const modelInput = $('#gift-api-model-input');
                    const currentModel = config.model;
                    
                    modelSelect.innerHTML = '';
                    
                    const modelOptions = {
                        gemini: [ "gemini-2.5-flash", "gemini-2.5-pro", "gemini-1.5-flash-latest", "gemini-1.5-pro-latest" ],
                        siliconflow: [ "deepseek-ai/DeepSeek-V3", "deepseek-ai/DeepSeek-R1-0528-Qwen3-8B", "Qwen/Qwen2-7B-Instruct", "01-ai/Yi-1.5-34B-Chat" ],
                        paioupu: [ "deepseek/deepseek-v3" ],
                        custom: [] // 自定义时为空
                    };

                    const setOptions = (options, defaultModel) => {
                        if (options.length === 0) {
                            modelSelect.style.display = 'none';
                            modelInput.style.display = 'block';
                            modelInput.value = currentModel || defaultModel;
                        } else {
                            modelSelect.style.display = 'block';
                            modelInput.style.display = 'none';
                            const finalOptions = [...options, "其他"];
                            modelSelect.innerHTML = finalOptions.map(opt => `<option value="${opt}">${opt}</option>`).join('');
                            
                            if (finalOptions.includes(currentModel)) {
                                modelSelect.value = currentModel;
                            } else if (currentModel) {
                                modelSelect.value = "其他";
                                modelInput.style.display = 'block';
                                modelInput.value = currentModel;
                            } else {
                                modelSelect.value = options[0];
                            }
                        }
                    };
                    
                    const providerData = {
                        siliconflow: { url: 'https://api.siliconflow.cn/v1/chat/completions', models: modelOptions.siliconflow, defaultModel: 'deepseek-ai/DeepSeek-R1-0528-Qwen3-8B' },
                        gemini: { url: 'https://generativelanguage.googleapis.com/v1beta/models/', models: modelOptions.gemini, defaultModel: 'gemini-2.5-flash' },
                        paioupu: { url: 'https://api.ppinfra.com/v3/openai', models: modelOptions.paioupu, defaultModel: 'deepseek/deepseek-v3' },
                        custom: { url: '', models: [], defaultModel: '' }
                    };

                    const data = providerData[provider] || providerData.custom;
                    apiUrlInput.value = config.url || data.url;
                    setOptions(data.models, data.defaultModel);
                };

                $('#gift-api-provider').addEventListener('change', () => {
                    config.url = ''; // 切换提供商时清空URL以使用默认值
                    config.model = ''; // 清空模型
                    updateGiftApiFields();
                });
                
                $('#gift-api-model-select').addEventListener('change', (e) => {
                    const modelInput = $('#gift-api-model-input');
                    if (e.target.value === '其他') {
                        modelInput.style.display = 'block';
                        modelInput.value = '';
                        modelInput.focus();
                    } else {
                        modelInput.style.display = 'none';
                    }
                });
                
                updateGiftApiFields();
                
                $('#use-default-api-btn').onclick = async () => {
                    const mainApiConfig = await DBHelper.get('apiConfig', 'mainConfig');
                    if (mainApiConfig) {
                        $('#gift-api-provider').value = mainApiConfig.provider;
                        config.url = mainApiConfig.url;
                        config.key = mainApiConfig.key;
                        config.model = mainApiConfig.model;
                        updateGiftApiFields(); // 更新UI
                        $('#gift-api-key').value = mainApiConfig.key;
                        UIManager.showToast("已载入主API配置");
                    }
                };
            },
        };
        
        async function loadFontsAfterSplash() {
            try {
                
                await EventManager.loadCustomFontsOnStartup();
                console.log("自定义字体文件已在后台准备就绪。");
            } catch (error) {
                console.error("后台自定义字体加载失败:", error);
            }
        }

        
        async function initApp() {
            
            setTimeout(() => {
                const splash = $('#splash-screen');
                if (splash) {
                    splash.classList.add('hidden');
                    
                    setTimeout(() => {
                        splash.style.display = 'none';
                    }, 500);
                }
            }, 1500);

            try {
                
                await DBHelper.init();
                await AIHandler.loadApiConfig();

                
                let profile = await DBHelper.get('profile', 'myProfile');
                let needsDbUpdate = false;
                if (!profile) {
                    profile = {
                        id: 'myProfile',
                        name: '商时序',
                        gender: '女',
                        avatar: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MCIgaGVpZ2h0PSI1MCIgdmlld0JveD0iMCAwIDUwIDUwIj48cmVjdCB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiMwMDAiLz48L3N2Zz4=',
                        background: '',
                        presets: [] // 初始化为空数组
                    };
                    needsDbUpdate = true;
                }

                // 确保 presets 数组存在且有效
                if (!profile.presets || !Array.isArray(profile.presets)) {
                    profile.presets = [];
                    needsDbUpdate = true;
                }

                // 移除任何可能的 null 值
                const validPresets = profile.presets.filter(p => p !== null && typeof p === 'object');
                if (validPresets.length !== profile.presets.length) {
                    profile.presets = validPresets;
                    needsDbUpdate = true;
                }

                // 为所有现有预设添加唯一的 presetId (如果它们没有)
                profile.presets.forEach(p => {
                    if (!p.presetId) {
                        p.presetId = Utils.generateId('persona');
                        needsDbUpdate = true;
                    }
                });
                
                // 如果处理后预设数组为空，则从主配置创建一个默认预设
                if (profile.presets.length === 0) {
                    profile.presets.push({
                        presetId: Utils.generateId('persona'), // 给予一个唯一的ID
                        name: profile.name,
                        avatar: profile.avatar,
                        gender: profile.gender,
                        background: profile.background || '',
                    });
                    needsDbUpdate = true;
                }

                
                if (needsDbUpdate) {
                    await DBHelper.put('profile', profile);
                }
                $('#my-avatar').src = profile.avatar;
                appState.favoriteEmojis = profile.favoriteEmojis || [];

                // Check and initialize default prompt folders and prompts
                const existingFolders = await DBHelper.getAll('promptFolders');
                const existingContacts = await DBHelper.getAll('contacts');
                if (existingFolders.length === 0 && existingContacts.length === 0) {
                    console.log("No prompts or contacts found, assuming fresh start. Initializing default writing style folder.");

                    const folderId = 'default-style-folder-01';
                    const newFolder = {
                        id: folderId,
                        name: '文风设定',
                        isActive: false, // 默认关闭
                        createdAt: Date.now()
                    };
                    await DBHelper.put('promptFolders', newFolder);

                    const defaultPrompts = [
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 1,
                            name: '“日系轻小说”欢乐跳脱',
                            folderId: folderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**# 核心指令**

你现在是一名专写“校园/日常欢乐喜剧”的日本轻小说家。你的任务是创作充满活力、幽默感十足、对话轻松有趣的日常故事。请严格遵循以下文风特点，并将其内化为你的创作核心。

**# 文风要素拆解**

**1. 叙事视角与内心独白 (吐槽役担当):**
   - **第二人称视角：** 故事主要以玩家“你”也就是主角的视角展开。
   - **内心戏超多：** 主角是全书的“吐槽役”担当。他对周围人（尤其是女主角）的奇葩行为、不合常理的展开，总会在内心进行光速吐槽和评论。
   - **常用句式：** “喂喂，这展开是不是有点离谱了？”、“不，我为什么要在这里陪她胡闹啊！”、“这家伙的脑回路到底是怎么长的……”、“从某种意义上说，她也算是个天才吧。”、“我的青春恋爱喜剧果然有问题。”

**2. 对话风格 (装傻与吐槽的交锋):**
   - **节奏明快，一来一回：** 对话简短、快速，充满生活气息和互动感。角色之间经常互相打断、调侃、抬杠。
   - **装傻役 (ボケ) vs 吐槽役 (ツッコミ):** 至少有一个核心角色是“天然呆”或“元气笨蛋”，负责提出不合常理的观点或做出惊人举动（装傻役）。而主角则负责精准地指出其中的荒谬之处（吐槽役）。
   - **幽默感：** 幽默并非来自段子，而是来自角色性格的碰撞、误解、以及对日常小事夸张化的反应。
   - **口头禅与语气词：** 大量使用语气词和感叹词来增强情绪。“欸？！”、“哈——？！”、“唔……”、“真是的……”、“可恶！”、“哼、哼，别、别误会了！”

**3. 氛围与节奏:**
   - **轻松明快：** 整体基调是阳光、温暖、略带一丝傻气的。即使有矛盾，也绝不沉重，通常会以喜剧形式解决。
   - **小题大做：** 将一件非常普通的小事（比如做饭、打扫卫生、期末考试、逛便利店）描绘成一场惊天动地的大冒险或大灾难，从中营造笑点。
   - **细节描写：** 专注于描写角色的微表情、小动作，例如“她鼓起了脸颊，像一只仓鼠”、“他无奈地扶住额头”、“她‘啪’地一下把书拍在桌上”。

**4. 语言与标点符号:**
   - **标点符号的活用：**
     - **省略号 (...)：** 用于表示迟疑、无语、或话语的延续。
     - **破折号 (——)：** 用于表示声音的拉长、话题的突然转变或补充说明。
     - **感叹号与问号的叠加 (？！)：** 用于表达极度的震惊和不敢相信。`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 2,
                            name: '“低温慢煮”日常风',
                            folderId: folderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: `**核心原则：克制、留白、张力**  你需要扮演一位冷静、耐心且观察入微的叙事者。你的镜头始终对准人物最细微的互动，捕捉那些被日常琐碎掩盖，却在缝隙中不断泄露的真实情感。叙事的魅力不在于宣告情感，而在于**展示情感发生的证据**。  ---  **一、 叙事视角与基调 (Narrative Perspective & Tone)**  1. **视角锁定：** 严格采用**第三人称有限视角（以女主为主）**。我们可以深入女主的内心感受、她的困惑、猜测和细微的情绪波动。但对于男主，我们是和女主一样的“局外人”。 2. **男主塑造的铁律：【绝对禁止】直接描写男主角的任何心理活动、内心独白或情感状态。** 他的所有情绪、意图和挣扎，都必须且只能通过以下方式“泄露”出来： * **动作 (Action):** 他倒水的动作是流畅还是停顿？他递东西时指尖是否触碰？关门的声音是轻是重？ * **语言 (Dialogue):** 话语的节奏、用词的选择、未说完的话、突然的沉默。 * **神态/微表情 (Expression/Micro-expression):** 眼神的流转与闪躲、嘴角稍纵即逝的弧度、喉结的滚动、眉头的微蹙。 3. **叙事基调：** 冷静、客观，甚至带一丝疏离感。像在观看一部纪录片。语言风格追求**朴素、精准、洗练**，摒弃一切华丽、浮夸、煽情的形容词。每一个字都应服务于场景和氛围的构建，力求达到“一字一句，回味无穷”的效果。---  **三、 对话风格 (Dialogue Style)**  1. **简洁与留白：** 对话要生活化，避免大段的抒情和哲学辩论。多用短句。对话的重点不在于说了什么，而在于**没说什么**。 2. **潜台词与沉默：** 对话间的沉默和停顿与台词本身同等重要。必须描写沉默时的空气、人物的视线、无意识的小动作。 * **示例：** 她问：“你周末……有安排吗？” 他手上的动作停顿了一下，过了足有两秒，才重新拿起那本书，翻过一页。纸张发出轻微的摩擦声。 “嗯，”他应道，“有点事。” 他没有说是何事。空气仿佛凝滞了一瞬，只剩下窗外微弱的风声。  ---  **四、 动作与神态描写 (Action & Expression Description)**  1. **细节的信徒：** 成为细节的信徒。专注于感官描写：视觉、听觉、触觉、嗅觉。 * **视觉：** 他衬衫袖口卷起的褶皱，她发梢滴落的水珠，灯光下尘埃的浮动。 * **听觉：** 钥匙插入锁孔的声音，他略带沙哑的声线，雨点击打窗户的节奏。 * **触觉：** 他递来的外套上残留的温度，微风拂过皮肤的凉意，她指尖的冰冷。 2. **“矛盾”的动作：** 设计一些人物言行不一的细节，以体现其内心的矛盾与张力。 * **示例：** 他嘴上说着“你早点休息”，但人却没有要离开的意思，只是站在门口，手指无意识地摩挲着门框的边缘。  ---  **五、 严禁事项 (What to Avoid)**  1. **禁止滥用情感浓烈的词汇：** 严格避免“心碎”、“绝望”、“撕心裂肺”、“空洞”、“救赎”等词语。用“微涩”、“滞涩”、“僵持”、“无言”等更具克制感和质感的词汇替代。 2. **禁止大开大合的情节：** 杜绝车祸、失忆、绝症、身世之谜等强戏剧性桥段。 3. **禁止华丽的修辞：** 避免复杂的比喻和象征，除非它能极其精准地服务于当下的情景。文字的美感来源于其**准确性**，而非装饰性。 4. **禁止上帝视角的全知全能：** 叙事者不是上帝，而是一个在场的观察者。不要做出任何超越角色认知范围的评判和总结。  ---  **总结：** 你的任务是创造一个“空气中都充满着未说出口的话”的世界。让读者像侦探一样，通过你提供的线索（动作、眼神、沉默），去拼凑和感受男主角那隐藏在冰山之下的、汹涌而克制的情感。最终，当情感的张力积累到顶点时，一个极小的动作或一句话，就能产生核爆级的效果。`,
                            isActive: false,
                        },
                        {
                            id: Utils.generateId('prompt'),
                            createdAt: Date.now() + 3,
                            name: '文风来源',
                            folderId: folderId,
                            type: 'explicit',
                            keywords: '[]',
                            content: '（此提示词为来源标注）日系轻小说与低温慢煮文风设定，来源于 xhs @DD老师的分享。',
                            isActive: false,
                        }
                    ];

                    for (const prompt of defaultPrompts) {
                        await DBHelper.put('prompts', prompt);
                    }
                    console.log("Default writing style folder and prompts created.");
                }

// --- 新增：恢复番茄钟状态的函数 ---
                const restorePomodoroState = () => {
                    const savedStateJSON = localStorage.getItem('pomodoroState');
                    if (!savedStateJSON) return;
                    
                    try {
                        const savedState = JSON.parse(savedStateJSON);
                        if (savedState && savedState.isActive && savedState.endTime) {
                            const now = Date.now();
                            if (savedState.endTime > now) {
                                // 计时器仍在进行中
                                appState.pomodoro = savedState;
                                appState.pomodoro.timerId = setInterval(() => EventManager.updatePomodoroTimer(), 1000);
                                EventManager.updatePomodoroTimer(); // 立即更新一次显示
                                EventManager.updateFloatingBallVisibility();
                                console.log("Pomodoro state restored and timer restarted.");
                            } else {
                                // 计时器已在离线时结束
                                UIManager.showPomodoroEndNotification(savedState.goal);
                                localStorage.removeItem('pomodoroState');
                            }
                        }
                    } catch (e) {
                        console.error("Failed to parse pomodoro state:", e);
                        localStorage.removeItem('pomodoroState');
                    }
                };

                await EventManager.setupEmojiMaps();
                EventManager.init();
                restorePomodoroState(); // --- 新增调用 ---

                const defaults = {
                    id: 'chatSettings',
                    memoryInterconnection: false,
                    historyCharLimit: 5000,
                    showMyNameInGroup: true,
                    showNamesInPrivate: false,
                    bottomBarOffset: false,
                    enterToSend: false,
                    theme: 'neumorphic',
                };
                const savedSettings = await DBHelper.get('apiConfig', 'chatSettings');
                const initialChatSettings = { ...defaults, ...savedSettings };
                appState.theme = initialChatSettings.theme;
                EventManager.applyChatSettings(initialChatSettings);
                await EventManager.applyBackgroundSettings(); 
                await EventManager.applyBubbleSettings(); 
                await EventManager.applyBubbleFontSize(); 

                EventManager.loadAndApplyFontsInBackground(); 

                
                await EventManager.initEmojiPanel(); 
                await UIManager.navigateTo('messages');
                
            } catch (error) {
                console.error("应用初始化失败:", error);
                document.body.innerHTML = `<div style="text-align:center; padding: 50px; color: red;">应用初始化失败，请检查浏览器是否支持IndexedDB或清除网站数据后重试。错误: ${error}</div>`;
            }
        }
        
        document.addEventListener('DOMContentLoaded', initApp);

    })();
    </script>
</body>
</html>